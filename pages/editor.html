<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="/ressources/logo-1.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://kit.fontawesome.com/75303112de.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/5.3.0/ekko-lightbox.css" />
    <title>Editor</title>    
    <link rel="stylesheet" href="/css/type.css">
</head>
<body>
    
    <header>        
        <nav>
        <ul
            class="logo">
            <li><a href="/index.html"><img src="/ressources/logo-1.png" width="50" alt=""></a></li>
        </ul>
        <ul
        class="logo">
        <li><a href="#chap0">Avant Propos</a></li>
        </ul>
         <ul>
            <li class="title-item"><a href="#chap1">Chapitre 1</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#zero">1. Introduction aux éditeurs de texte</a></li>                         
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#un">1.1 Vim minimum viable</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#deux">1.2 Starting Vim</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trois">1.2.1 Exercises</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quatre">1.3 Édition de petits fichiers</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cinq">1.3.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#six">1.4 Sauvegarde et fermeture des fichiers</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#sept">1.4.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#huit">1.5 Suppression de contenu</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#neuf">1.5.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dix">1.6 Édition de fichiers volumineux</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#onze">1.6.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#douze">1.7 Résumé</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#treize">1.7.1 Exercices</a></li>               

         </ul>
         <ul>
            <li class="title-item"><a href="#chap2">Chapitre 2</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quatorze">2. Éditeurs de texte modernes</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quinze">2.1 Choisir un éditeur de texte</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#seize">2.1.1 Sublime Text</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dixsept">2.1.2 Visual Studio Code (VSCode)</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dixhuit">2.1.3 </a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dixneuf">2.1.4 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vin">2.2 Ouverture</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinun">2.2.1 Mise en évidence de la syntaxe</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vindeux">2.2.2 Aperçu de Markdown</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vintrois">2.2.3 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinquatre">2.3 Déplacement</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vincinq">2.3.1 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinsix">2.4 Sélection de texte</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinsept">2.4.1 Sélection d'un seul mot</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinhuit">2.4.2 Sélection d'une seule ligne</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinneuf">2.4.3 Sélection de plusieurs lignes</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trente">2.4.4 Sélection de l'ensemble du document</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trenteun">2.4.5 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentedeux">2.5 Couper, copier, coller</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentetrois">2.5.1 Coupe sautée</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentequatre">2.5.2 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentecinq">2.6 Suppression et annulation</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentesix">2.6.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentesept">2.7 Économies</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentehuit">2.7.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trenteneuf">2.8 Rechercher et remplacer</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quarante">2.8.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qun">2.9 Résumé</a></li>        
         </ul>
        
         <ul>
            <li class="title-item"><a href="#chap3">Chapitre 3</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qdeux">3. Édition de texte avancée</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qtrois">3.1 Saisie semi-automatique et déclencheurs d'onglets</a></li>               
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qquatre">3.1.1 Saisie semi-automatique</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qcinq">3.1.2 Déclencheurs d'onglets</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qsix">3.1.3 Exercices</a></li> 
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qsept">3.2 Écriture du code source</a></li>                              
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qhuit">3.2.1 Mise en évidence de la syntaxe </a></li>                
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qneuf">3.2.2 Commenter </a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cun">3.2.3 Indentation et retrait</a></li> 
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cdeux">3.2.4 Aller au numéro de ligne</a></li>  
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#ctrois">3.2.5 80 colonnes</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cquatre">3.2.6 Exercices</a></li>               
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#ccinq">3.3 Écriture d'un script exécutable</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#csix">3.3.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#csept">3.4 Projets d'édition</a></li> 
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#chuit">3.4.1 Ouverture floue</a></li>                              
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cneuf">3.4.2 Volets multiples</a></li>                
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#sun">3.4.3 Recherche et remplacement globaux</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#sdeux">3.4.4 Exercices</a></li> 
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#strois">3.5 Personnalisation</a></li>  
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#squatre">3.5.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#scinq">3.6 Résumé</a></li>  
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#ssix">3.7 Conclusion</a></li>  
                     
         </ul>     
        </nav>
    </header>
    <main>
        <!-- A propos -->     
        <section >
         <div class="container-video">
             <h1>Editor</h1>
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 
                 <h2 id="chap0"> QUI SUIS-JE ?</h2>

                <p class="lamda">
                   <b>ABDOULAYE DIALLO</b> est un développeur de logiciels passionné par l'enseignement. <br> Il a travaillé avec de nombreuses start-ups sur des projets personnels et en tant que freelance très bien noté sur les places de marché. <br>

                    <b>ABDOULAYE DIALLO</b> a enseigné la programmation et le marketing à plus de 100 000 étudiants en ligne et hors ligne en tant que formateur. <br>
                    
                    <b>ABDOULAYE DIALLO</b> maîtrise l'art d'expliquer des sujets très complexes de la manière la plus simple possible, facile à comprendre et à suivre. Ses cours vidéo sont également utilisés par des entreprises pour former leurs employés et par des universités pour préparer leurs étudiants et améliorer leurs compétences en fonction des exigences du secteur.
                    
                    
                  
                </p>
                <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
         
        </section>

        <!-- 1 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="zero">Introduction aux éditeurs de texte</h2>

                 <p class="lamba">643-code Text Editor  est conçu pour vous aider à apprendre à utiliser ce qui est sans doute l’élément le plus important dans le sac d’astuces de l’ aspirant magicien informatique : un éditeur de texte ( Figure  1.1 ).Apprendre à utiliser un éditeur de texte est un élément essentiel de la sophistication technique .

                 </p>
                 <p class="cycle spec"><img src="/ressources/e1.png" alt=""></p>
                  <p class="fig">Figure 1.1 : Un éditeur de texte.</p>
                  <p class="lamda">Contrairement à d'autres didacticiels d'éditeur de texte, qui sont généralement liés à un éditeur spécifique, ce didacticiel est conçu pour présenter l'ensemble de la catégorie d'application, une catégorie dont beaucoup de gens ne savent même pas qu'elle existe.De plus, les tutoriels spécifiques aux éditeurs ont tendance à s'adresser aux développeurs professionnels et supposent généralement des années d'expérience, mais 643-code Text Editor  ne suppose même pas que vous savez ce qu'est un « éditeur de texte ».Son seul prérequis est une compréhension de base de la ligne de commande Unix, telle que celle fournie par 643-code Command Line  .</p>
                  <p class="lamda">Parce que 643-code Text Editor  fait partie d'une série de tutoriels conçus pour enseigner les fondamentaux du développement logiciel (avec un accent particulier sur les prérequis pour apprendre le développement Web avec le tutoriel ruby ), il est idéal pour tous ceux qui souhaitent acquérir les compétences nécessaires pour travailler avec des développeurs ou devenir eux-mêmes développeurs.Enfin, même si vous savez déjà utiliser un éditeur de texte, suivre ce tutoriel (et faire les exercices) vous aidera à combler vos lacunes dans vos connaissances, et vous pourriez même apprendre quelques nouvelles astuces.</p>
                  <p class="lamda">Contrairement à la plupart des programmes utilisés pour produire des documents écrits, tels que les traitements de texte et les clients de messagerie, un éditeur de texte est une application spécifiquement conçue pour éditer du texte brut (souvent appelé simplement « texte » en abrégé).Apprendre à utiliser un éditeur de texte est important car le texte est omniprésent dans l'informatique moderne : il est utilisé pour le code, le balisage, les fichiers de configuration et bien d'autres choses .(En effet, j'utilise du texte brut pour écrire ce document.)Bien qu'il soit étonnamment difficile de définir exactement ce qu'est un « texte brut », d'un point de vue pratique, cela signifie que le texte lui-même n'a aucun formatage, ou du moins aucun qui compte.Il n'y a aucune notion de texte mis en valeur ou en gras , de taille de policetypeface , etc. — la seule chose qui compte, c'est le contenu .Par exemple, bien que la phrase précédente contienne une sortie formatée comme celle-ci , sa source est du texte brut et apparaît comme dans la liste  1.1.3</p>
                  <p class="cod">
                    Liste 1.1 : La source HTML d'une phrase dans ce tutoriel. <br>
                       <code><span></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Il n'y a aucune notion de </font><font dir="auto" style="vertical-align: inherit;">texte </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt; </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">em </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> souligné </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt;/ </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">em </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> ou </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt; </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">strong </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> gras </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt;/ </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">strong </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt; ,</font></font></span><font dir="auto" style="vertical-align: inherit;"></font><font></font><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">
la </font><font dir="auto" style="vertical-align: inherit;">taille </font><span class="p"><font dir="auto" style="vertical-align: inherit;">de </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">la </font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;">police </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">et </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">la </font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;">police </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">de </font></span></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">caractères</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> n'ont </font><span class="p"><font dir="auto" style="vertical-align: inherit;">pas </font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;">d' </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">importance </font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;">,</font></span><font dir="auto" style="vertical-align: inherit;">​</font><font dir="auto" style="vertical-align: inherit;">​</font></font><span class="nt"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><font dir="auto" style="vertical-align: inherit;"></font><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><font dir="auto" style="vertical-align: inherit;"></font><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><font dir="auto" style="vertical-align: inherit;"></font><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><font dir="auto" style="vertical-align: inherit;"></font><font></font><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">
etc. </font></font><span class="ni"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">—</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> la seule chose qui compte est le </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt; </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">em </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> contenu </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt;/ </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">em </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> .
</font></font></code>
                  </p>
                  <p class="lamda">Dans la liste  1.1 , les options de formatage souhaitées sont indiquées avec des balises spéciales (telles que la balise d'emphase HTML <em>…</em>) plutôt qu'en modifiant l'apparence du texte lui-même.C'est la raison principale pour laquelle les programmes de traitement de texte plus familiers tels que Word ne sont pas bien adaptés à l'édition de texte brut, et un autre type d'outil est nécessaire ( Encadré  1.1 ).</p>
                  <p class="comment">
                    Encadré 1.1. Traitements de texte et éditeurs de texte <br>
Même si vous n'avez jamais utilisé d'éditeur de texte, il y a de fortes chances que vous ayez utilisé un outil similaire, un traitement de texte .Il existe de nombreux chevauchements entre les fonctionnalités des traitements de texte et des éditeurs de texte.Par exemple, ils vous permettent tous deux de créer des documents, de rechercher et de remplacer ou de couper/copier/coller du texte et d'enregistrer les résultats.La principale différence est que les traitements de texte sont généralement conçus pour produire des documents selon le principe « What You See Is What You Get » (WYSIWYG, prononcé « WIZ-ee-wig »), de sorte que les effets tels que l'emphase ou le gras sont obtenus directement dans l'application, au lieu d'utiliser un balisage en texte brut comme <em>emphasis</em>ou **boldface**.La plupart du temps, les traitements de texte enregistrent également leurs résultats dans des formats propriétaires qui peuvent parfois mal fonctionner (comme l'ont appris à leur grand désespoir de nombreuses personnes ayant essayé d'ouvrir d'anciens fichiers Word).

En revanche, les éditeurs de texte sont conçus pour modifier du texte brut, l’un des formats les plus universels et les plus durables.Les éditeurs de texte diffèrent également des traitements de texte en ayant des fonctionnalités destinées aux utilisateurs plus techniques, notamment la coloration syntaxique du code source ( Section  3.2.1 ), l'indentation automatique ( Section  3.2.3 ), la prise en charge des expressions régulières ( Section  3.4.3 ) et la personnalisation via des packages et des extraits ( Section  3.5 ).Un bon éditeur de texte est donc un outil essentiel dans la boîte à outils de tout technicien.
                  </p>
                  <p class="cycle spec"><img src="/ressources/e2.jpg" alt=""></p>
                  <p class="fig">Figure 1.2 : Pourquoi ne pas éditer du texte brut avec Microsoft Word ?</p>
                   <p class="lamda">S'appuyant sur le matériel développé dans 643-code Command Line  , 643-code Text Editor  commence par couvrir l'important éditeur Vim ( Section  1.1 ), qui peut être exécuté sur la ligne de commande directement dans une fenêtre de terminal.Vim nous donnera l'occasion de voir nos premiers exemples des fonctions les plus importantes d'un éditeur de texte, mais comme Vim peut être d'une complexité prohibitive pour un débutant, dans ce tutoriel nous ne couvrirons que le strict minimum nécessaire pour effectuer des modifications de base.Le reste du didacticiel développera les thèmes développés au chapitre  1 en décrivant certaines des nombreuses fonctionnalités puissantes requises dans tout éditeur de texte de niveau programmeur, avec des exemples tirés principalement de Sublime Text , un éditeur multiplateforme disponible gratuitement, 5 avec des concepts applicables aux éditeurs  6 et Visual Studio Code étroitement liés et à Cloud9 , un IDE cloud</p>
                   <p class="lamda">Comme pour 643-code Command Line  , ce tutoriel fait partie de la tradition Unix , qui inclut pratiquement tous les systèmes d'exploitation dont vous avez entendu parler (macOS, iOS, Android, Linux, etc.) à l'exception de Microsoft Windows.Bien que tous les éditeurs dont nous parlerons fonctionnent sous Windows, l'utilisation d'un système d'exploitation non Unix introduit des frictions dans le processus. Les utilisateurs de Windows sont donc encouragés à configurer un environnement de développement compatible Linux en suivant les étapes Windows décrites dans 643-code Dev Environment  ou à utiliser un IDE cloud basé sur Linux (qui est également abordé dans 643-code Dev Environment  ).

                   </p>
                   <p class="lamda">Tout au long de 643-code Text Editor , l'accent est mis sur les principes généraux. Ainsi, quel que soit l'éditeur que vous utilisez, vous disposerez d'une bonne liste de contrôle mentale des types de tâches que vous devez confier à votre éditeur.De plus, comme les détails varient selon l’éditeur de texte et le système, ce didacticiel constitue une occasion idéale de continuer à développer votre sophistication technique ( Encadré  1.2 ).Enfin, ne ressentez aucune pression pour tout maîtriser d’un coup.Vous pouvez être productif même avec un petit sous-ensemble de ce qui est inclus dans ce didacticiel.Parce que les personnes techniquement sophistiquées utilisent des éditeurs de texte pratiquement tous les jours, vous continuerez à apprendre de nouvelles astuces à perpétuité.</p>
                   <p class="comment">Encadré 1.2. Sophistication technique <br>
                    L'expression sophistication technique , mentionnée précédemment dansle tutorielde ligne de commande  , fait référence à la capacité générale à utiliser des ordinateurs et d'autres choses techniques.Cela comprend à la fois les connaissances existantes (telles que la familiarité avec les éditeurs de texte et la ligne de commande Unix) et la capacité d'acquérir de nouvelles connaissances, comme illustré dans « Tech Support Cheat Sheet » de xkcd .Contrairement aux « compétences techniques » telles que le codage et le contrôle de version, ce dernier aspect de la sophistication technique est une « compétence douce » – difficile à enseigner directement, mais essentielle à développer si vous souhaitez travailler avec des programmeurs informatiques ou devenir vous-même programmeur.
                    
                    Dans le contexte des éditeurs de texte, la sophistication technique comprend des choses comme la lecture des éléments de menu pour comprendre ce qu'ils font, l'utilisation du menu Aide pour découvrir de nouvelles commandes, l'apprentissage des raccourcis clavier en lisant les éléments de menu ou en effectuant une recherche sur Google, etc.Cela implique également une tolérance à l'ambiguïté : les lecteurs techniquement avertis ne paniqueront pas si un tutoriel indique d'utiliser ⌘Z pour annuler quelque chose alors qu'il s'agit en fait de ⌃Z sur leur système.Ils ne paniqueront pas non plus s'ils voient ⌘Z mais ne savent pas ce que ⌘ signifie, car ils savent qu'ils peuvent parcourir la page pour trouver quelque chose comme le tableau  2.1 , ou simplement le rechercher sur Google .L’aspect le plus important de la sophistication technique est peut-être l’ attitude : une confiance et un esprit d’initiative face à la confusion, qui méritent d’être cultivés.
                    
                    Tout au long du reste de 643-code Text Editor  , nous nous référerons à cette boîte chaque fois que nous rencontrerons des exemples de problèmes qui nécessitent un peu de sophistication technique pour être résolus.Avec l’expérience, vous deviendrez vous aussi l’un des « informaticiens » de « Tech Support Cheat Sheet » qui semblent avoir la capacité magique de comprendre les choses techniques.( Attention : vous aurez peut-être besoin d'une nouvelle chemise ( Figure  1.3 ).)</p>


                    <button class="btn">Commencer: le chapitre</button>


             </div>
             
         </div>
 
        </section>
        <!-- 2 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="un">1.1 Vim minimum viable</h2>

               <p class="lamda">L'éditeur vi (prononcé « vee-eye ») remonte aux premiers jours d'Unix, et Vim (prononcé « vim ») est une version mise à jour qui signifie « Vi IMproved ».Vim est un éditeur de texte absolument puissant, et de nombreux développeurs l'utilisent pour leurs besoins d'édition quotidiens, mais la barrière à la maîtrise de Vim est élevée, et il nécessite une personnalisation substantielle et une sophistication technique ( Encadré  1.2 ) pour atteindre son plein potentiel.Vim dispose également d'un ensemble de commandes vaste et souvent obscur, qui correspondent rarement aux raccourcis clavier natifs, ce qui rend Vim difficile à apprendre et à mémoriser.Par conséquent, je recommande généralement aux débutants d’apprendre un éditeur « moderne » ( chapitre  2 ) pour une utilisation quotidienne.Néanmoins, je considère qu'une maîtrise minimale de Vim est essentielle, simplement parce que Vim est omniprésent : il est présent sur pratiquement tous les systèmes de type Unix dans l'univers connu, ce qui signifie que si vous vous connectez via SSH à un serveur aléatoire à l'autre bout du monde, Vim sera probablement là.</p>
               <p class="lamda">Ce chapitre inclut uniquement le minimum viable de Vim, juste assez pour utiliser Vim pour effectuer des tâches telles que modifier de petits fichiers de configuration ou des commits Git.Ce n’est même pas suffisant  .</p>
               <p class="lamda">Mais il convient de noter que même la maîtrise de Minimum Viable Vim vous place dans une compagnie d'élite - parce que Vim est si difficile, même une petite connaissance de Vim est le genre de chose qui peut impressionner vos amis (ou un recruteur).</p>
               <p class="lamda">Remarque : si vous utilisez macOS, vous devez suivre les instructions de l’encadré  1.3 pour le moment.</p>
               <div class="comment">
                Encadré 1.3. Passer de macOS à Bash <br>
                Si vous utilisez macOS, à ce stade, vous devez vous assurer que vous utilisez le bon programme shell pour ce didacticiel.Le shell par défaut de macOS Catalina est Z shell (Zsh), mais pour obtenir des résultats cohérents avec ce tutoriel, vous devez passer au shell appelé Bash .
                
                La première étape consiste à déterminer quel shell votre système exécute, ce que vous pouvez faire à l'aide de la echocommande :
                 <p class="cod">
                  $ echo $SHELL <br>
                  /bin/bash
                </p>
                Ceci imprime la $SHELL variable d'environnement .Si vous voyez le résultat affiché ci-dessus, indiquant que vous utilisez déjà Bash, vous avez terminé et pouvez continuer le reste du didacticiel.(Dans de rares cas, $SHELLcela peut différer du shell actuel, mais la procédure ci-dessous passera toujours correctement d'un shell à un autre.)Pour plus d'informations, notamment sur la manière de passer à Z Shell et de l'utiliser avec ce didacticiel, consultez l'article de blog 643-code « Utilisation de Z Shell sur Mac avec les didacticiels 643-code ».
                
                L’autre résultat possible echoest le suivant :
                <p class="cod">
                  $ echo $SHELL <br>
                  /bin/zsh
                  </p>
                Si c'est le résultat que vous obtenez, vous devez utiliser la chshcommande (« change shell ») comme suit :
                <p class="cod">
                  $ chsh -s /bin/bash
                </p>
                Vous serez presque certainement invité à saisir votre mot de passe système à ce stade, ce que vous devriez faire.Quittez ensuite complètement votre programme shell en utilisant Commande-Q et relancez-le.
                
                Vous pouvez confirmer que le changement a réussi en utilisant echo:
                <p class="cod">
                  $ echo $SHELL <br>
                  /bin/bash
                </p>
                À ce stade, vous commencerez probablement à voir l’alerte suivante, que vous devez ignorer :
                <p class="cod">
                  L'interpréteur de commandes interactif par défaut est désormais zsh. <br>
                  Pour mettre à jour votre compte et utiliser zsh, exécutez <br>
                  « chsh -s /bin/zsh ». <br>
                  Pour plus d'informations, consultez <br>
                  la page https://support.apple.com/kb/HT208050. <br>
                
                  [~]$
                  </p>
                Notez que la procédure ci-dessus est entièrement réversible, vous n’avez donc pas à craindre d’endommager votre système.Consultez « Utilisation de Z Shell sur Mac avec les didacticiels 643-code » pour plus d’informations.
               </div>  
               
               <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div> 
     
        </section>
        <!-- 3 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="deux">1.2 Démarrage de Vim</h2>
                 <p class="lamda">Contrairement à la plupart des éditeurs modernes décrits à partir du chapitre  2 , Vim peut être exécuté directement dans une fenêtre de terminal et ne nécessite aucune interface graphique .Il vous suffit de taper vimà l'invite :</p>
                 <p class="cod">$ vim</p>
                 <p class="lamda">Les résultats typiques de l’exécution de la vimcommande apparaissent dans la liste  1.2 et la figure  1.4 .Dans les deux cas, les tildes (~) ne sont pas des caractères du fichier mais représentent plutôt des lignes qui n'ont pas encore été définies.</p>
                 <p class="cod">
                    Liste 1.2 : Une représentation textuelle d'une fenêtre Vim (le message et les versions peuvent différer). <br>
                    ~ <br>
                    ~ <br>
                    ~ <br>
                    ~ <br>
                    ~ <br>
                    ~ VIM - Vi IMproved <br>
                    ~  <br>
                    ~ version 7.3 <br>
                    ~ par Bram Moolenaar et al. <br>
                    ~ Vim est open source et distribuable gratuitement  <br><br>
                    ~ 
                    ~ Aidez les enfants pauvres en Ouganda ! <br>
                    ~ tapez :help iccf<Entrée> pour plus d'informations <br> <br>
                    ~ 
                    ~ tapez :q<Entrée> pour quitter <br>
                    ~ tapez :help<Entrée> ou <F1> pour l'aide en ligne <br>
                    ~ tapez :help version7<Entrée> pour les informations de version 
                 </p>
                 <p class="cycle spec"><img src="/ressources/e3.png" alt=""></p>
                 <p class="fig">Figure 1.4 : Vim exécuté dans une fenêtre de terminal.</p>
                 <p class="lamda">Si démarrer Vim est facile, apprendre à l'utiliser, au moins au début, peut être incroyablement difficile.Cela est principalement dû au fait que Vim est un éditeur modal , ce qui est probablement différent de tout ce que vous avez utilisé auparavant ( Encadré  1.4 ).Vim possède deux modes principaux , appelés mode normal et mode d'insertion .Le mode normal permet d'effectuer des opérations telles que déplacer le fichier, supprimer du contenu ou rechercher et remplacer du texte, tandis que le mode d'insertion permet d'insérer du texte.</p>
                 <p class="comment">Encadré 1.4. Modal Vim <br>
                    Lorsque j'ai commencé à apprendre la programmation dans la tradition Unix (par opposition à mon expérience d'enfance avec Microsoft DOS, BASIC et Pascal), je me souviens distinctement avoir été absolument mortifié par l'éditeur incroyablement primitif que j'étais censé utiliser.À l’époque, j’étais en première année de licence à l’Université de Harvard et je travaillais dans un groupe de recherche au Centre d’astrophysique Harvard-Smithsonian .L'outil qui m'avait été remis était vi.Dire que cela ressemble à une rétrogradation par rapport aux traitements de texte est un euphémisme ( Figure  1.2 ).
                    
                    Ce qui m'a le plus choqué à propos de vi était l'édition modale : contrairement aux traitements de texte, vi ne me permettait pas simplement de cliquer dans la fenêtre et de commencer à taper.Au lieu de cela, il y avait une profusion d'options ( i, aet oparmi elles) pour passer en mode insertion , et il suffisait de quelques mauvaises frappes de touches pour que l'enfer se déchaîne.Bien que les années intermédiaires aient vu une prolifération d'éditeurs de texte plus modernes, dont la conception ressemble beaucoup plus à l'interface de type « cliquer-et-taper » que j'attendais de mon expérience avec les traitements de texte, la popularité durable de vi (via Vim) signifie qu'apprendre les bases de l'édition modale est une compétence précieuse, même si cela peut sembler ridiculement étranger au premier abord.</p>
                 <p class="lamda">Aller-retour entre ces deux modes peut entraîner beaucoup de confusion, d'autant plus que pratiquement tous les autres programmes d'édition de texte (y compris les traitements de texte, les clients de messagerie et la plupart des éditeurs de texte) n'ont qu'un mode d'insertion.Ce qui rend Vim particulièrement déroutant, c'est qu'il démarre en mode normal, ce qui signifie que si vous essayez de saisir du texte immédiatement après le démarrage de Vim (comme dans la liste  1.2 ), le résultat sera le chaos.</p>
                 <p class="lamda">Étant donné que la confusion est le résultat le plus probable si vous n'êtes pas habitué à l'édition modale de Vim, nous allons commencer notre étude de Vim avec la commande Vim la plus importante™ .Un de mes amis d'université, qui était un fervent partisan d'Emacs, le rival historique de vi (et donc de Vim) ( Encadré  1.5 ), prétendait que la commande la plus importante de Vim™ était la seule qu'il ait jamais voulu apprendre.C'est ici:</p>
                 <p class="cod">
                    <code><span></span><span class="go"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">ESC:q!&lt;retour&gt;</font></font></span>
                    </code>
                    </p>
                    <p class="lamda">Cette commande signifie « Appuyez sur la touche Échap, puis tapez « deux points q point d'exclamation », puis appuyez sur la touche Retour. »Nous apprendrons dans un instant ce que cela fait et pourquoi, mais pour l'instant nous allons commencer par le pratiquer plusieurs fois dans les exercices.</p>
                 <p class="comment">
                    Encadré 1.5. Guerres saintes : vi contre Emacs <br>
                    Le Jargon File définit les guerres saintes comme suit :
                    
                    guerres saintes : n.
                    
                    [de Usenet , mais peut être antérieur ; courant] guerres de flammes sur des questions religieuses .L'article de Danny Cohen qui a popularisé les termes big-endian et little-endian en lien avec la controverse LSB-first/MSB-first s'intitulait On Holy Wars and a Plea for Peace .
                    
                    Les grandes guerres saintes du passé ont inclus ITS contre Unix , Unix contre VMS , BSD Unix contre System V, C contre Pascal , C contre FORTRAN, etc.En 2003, les favoris populaires du jour étaient KDE contre GNOME, vim contre elvis, Linux contre [Free|Net|Open]BSD.Les plantes vivaces robustes incluent EMACS contre vi , mon ordinateur personnel contre l'ordinateur personnel de tout le monde, ad nauseam.La caractéristique qui distingue les guerres saintes des conflits techniques normaux est que, dans une guerre sainte, la plupart des participants passent leur temps à essayer de faire passer des choix de valeurs personnelles et des attachements culturels pour des évaluations techniques objectives.Cela se produit précisément parce que dans une véritable guerre sainte, les différences substantielles entre les parties sont relativement mineures.Voir aussi théologie .
                    
                    Comme indiqué dans l'entrée du fichier Jargon, l'une des guerres saintes les plus longues est menée entre les partisans de vi et son rival Emacs (parfois écrit « EMACS »), qui ont tous deux joué un rôle important dans la tradition informatique d'Unix.Les deux bénéficient également d'un large soutien populaire, même si je suppose qu'avec la popularité de Vim, vi a pris une avance décisive ces dernières années.Bien sûr, c’est exactement le genre de déclaration qui sert à perpétuer une guerre sainte, incitant probablement les partisans d’Emacs à, par exemple, faire des déclarations sur la puissance supérieure et la personnalisation de leur éditeur préféré.
                    
                    Si vous vouliez lancer une nouvelle guerre sainte, vous pourriez essayer quelque chose comme : « Heureusement, la guerre sainte entre vi et Emacs est désormais principalement une curiosité historique, car quiconque est quelqu'un est passé à un éditeur moderne comme  SublimeText ou Vscode.» <br>Ce sera un spectacle formidable, mieux vaut apporter du pop-corn ( Figure  1.5 ).
                 </p>
                 <p class="cycle spec"><img src="/ressources/e4.jpg" alt=""></p>
                 <p class="fig">Figure 1.5 : Regarder une guerre sainte se dérouler peut être divertissant.</p>
                  
                 <h2 id="trois">1.2.1 Exercices</h2>
                 <p class="exo">1-Démarrez Vim dans un terminal, puis exécutez la commande Vim la plus importante™.</p>
                 <p class="exo">2-Redémarrez Vim dans un terminal.Avant de taper quoi que ce soit d’autre, tapez la chaîne « Ceci est un document Vim ».Ce qui s'est passé?C'est déroutant, n'est-ce pas ?</p>
                 <p class="exo">3-Utilisez la commande Vim la plus importante™ pour récupérer de l’exercice précédent et revenir à l’invite de ligne de commande normale.</p>
                 <button class="btn">Commencer: le chapitre</button>
                
                </div>
             
         </div>
 
        
        </section>
        <!-- 4 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="quatre">1.3 Édition de petits fichiers</h2>
                 <p class="lamda">Maintenant que nous connaissons la commande la plus importante de Vim™, nous allons commencer à apprendre à utiliser Vim pour de vrai en ouvrant et en modifiant un petit fichier.Dans la section  1.2 , nous avons commencé par l'exécuter vimseul, mais il est plus courant d'utiliser un nom de fichier comme argument.Naviguons jusqu'au répertoire personnel de notre système, puis exécutons une telle commande, qui ouvrira le fichier correspondant (s'il existe) ou le créera (s'il n'existe pas) :</p>
                 <p class="cod">
                    $ cd <br>
                    $ vim .bashrc
                 </p>
                 <p class="lamda">Voici .bashrcun fichier de configuration standard pour Bash.</p>
                 <p class="lamda">Comme indiqué ci-dessus, la vim .bashrccommande créera automatiquement le .bashrcfichier correspondant s'il n'existe pas déjà sur votre système.Ce fichier important est utilisé pour configurer le shell , qui est le programme qui fournit une ligne de commande, dans ce cas, Bash , qui est un pseudo-acronyme signifiant Bourne Again SHell (également écrit « Bourne-again shell »). 12(Rappelez-vous de l'encadré  1.3 que la valeur par défaut sur macOS est désormais Zsh, donc si vous êtes sur un Mac, vous devez suivre les instructions pour passer à Bash si vous ne l'avez pas déjà fait.)</p>
                 <p class="lamda">Comme c'est courant sur les systèmes basés sur Unix, le fichier de configuration de Bash commence par un point, indiquant (comme indiqué dans Apprendre une ligne de commande suffisamment dangereuse ) que le fichier est caché .Autrement dit, il n'apparaît pas par défaut lors de la liste du contenu du répertoire avec ls, ou même lors de la visualisation du répertoire à l'aide d'un navigateur de fichiers graphique.</p>
                 <p class="lamda">Nous apprendrons dans la section  1.4 comment enregistrer les modifications apportées à ce fichier, mais pour l'instant, nous allons simplement ajouter du contenu factice afin de pouvoir nous entraîner à nous déplacer.Dans la section  1.2 , nous avons appris que Vim démarre en mode normal, ce qui signifie que nous pouvons changer d'emplacement, supprimer du texte, etc.Passons en mode insertion pour ajouter du contenu.La première étape consiste à appuyer sur la itouche pour insérer du texte.Ensuite, tapez quelques lignes (séparées par des retours), comme indiqué dans la liste  1.3.13(Il peut y avoir d’autres contenus existants, que vous devriez simplement ignorer.)</p>
                 <p class="cod">
                    Liste 1.3 : Ajout de texte après la saisie ipour insérer. <br>
                    ~/.bashrc <br>
                    1 lorem ipsum <br>
                     2 dolor sit amet <br>
                     3 foo bar baz <br>
                     4 J'ai fait celui-ci plus long que d'habitude parce que je n'ai pas eu le temps de le faire plus court.
                 </p>
             
                  <p class="lamda">Après avoir saisi le texte dans la liste  1.3 , appuyez sur ESC(la touche Échap) pour passer du mode insertion au mode normal.</p>
                  <p class="lamda">Maintenant que nous avons du texte sur quelques lignes, nous pouvons apprendre quelques commandes pour déplacer de petits fichiers.(Nous aborderons certaines commandes permettant de naviguer dans des fichiers volumineux dans la section  1.6 .)Le moyen le plus simple de se déplacer est d’utiliser les touches fléchées (haut, bas, gauche, droite), ce que je recommande .Vim dispose littéralement de milliards de façons de se déplacer, et si vous décidez d'utiliser Vim comme éditeur de texte principal, je vous recommande de les apprendre, mais pour nos besoins, les touches fléchées conviennent parfaitement.Les deux seules commandes supplémentaires que je considère comme essentielles sont celles qui permettent de se déplacer au début et à la fin de la ligne, qui sont respectivement 0 et $.</p>
                  <h2 id="cinq">1.3.1 Exercices</h2>
                  <p class="exo">1-Utilisez les touches fléchées pour accéder à la ligne 4 du fichier de la liste  1.3</p>
                  <p class="exo">2-Utilisez les touches fléchées pour aller jusqu'à la fin puis au début de la ligne 4.Encombrant, hein ?
                </p>
                  <p class="exo">3-Allez au début de la ligne 4 en utilisant la commande mentionnée dans le texte</p>
                  <p class="exo">4-Allez à la fin de la ligne 4 en utilisant la commande mentionnée dans le texte.</p>
             
                  <button class="btn">Commencer: le chapitre</button>
             
                </div>
             
         </div>
 
        
        </section>
        <!-- 6 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="six">1.4 Sauvegarde et fermeture des fichiers</h2>
                  <p class="lamda">Après avoir appris un peu comment se déplacer et insérer du texte, nous allons maintenant apprendre à enregistrer un fichier.Notre exemple spécifique impliquera la création d'une nouvelle commande Bash utile, mais nous devons d'abord gérer l'état actuel du fichier de profil Bash.Le texte que nous avons ajouté dans la liste  1.3 est du charabia (du moins du point de vue de Bash), donc ce que nous aimerions faire est de quitter le fichier sans enregistrer aucune modification.Pour des raisons historiques , certaines commandes Vim (en particulier celles liées à la manipulation de fichiers) commencent par deux points  :, et la manière normale de quitter un fichier est d'utiliser deux points :q<return>, mais cela ne fonctionne que lorsqu'il n'y a aucune modification à enregistrer.Dans le cas présent, nous obtenons le message d’erreur « Aucune écriture depuis la dernière modification (ajoutez ! pour remplacer) », comme illustré dans la Figure  1.6 .</p>
                  <p class="cycle spec"><img src="/ressources/e5.png" alt=""></p>
                  <p class="fig">Figure 1.6 : Tentative de fermeture d’un fichier avec des modifications non enregistrées.</p>
                  <p class="lamda">En suivant les conseils du message, nous pouvons taper :q!<return>pour forcer Vim à quitter sans enregistrer les modifications ( Figure  1.7 ), ce qui nous ramène à la ligne de commande.</p>
                  <p class="cycle spec"><img src="/ressources/e6.png" alt=""></p>
                  <p class="fig">Figure 1.7 : Forcer Vim à quitter.</p>
                  <p class="lamda">Vous avez peut-être remarqué que nous sommes maintenant en mesure de comprendre la commande Vim™ la plus importante introduite dans la section  1.2 : peu importe les choses terribles que vous avez pu faire à un fichier, tant que vous tapez ESC(pour sortir du mode insertion si nécessaire) 16 suivi de :q!<return>(pour forcer la fermeture), vous êtes assuré de ne faire aucun dommage.</p>
                  <p class="lamda">Bien sûr, Vim n'est vraiment utile que si nous pouvons enregistrer nos modifications, alors ajoutons du texte utile, puis écrivons le résultat.Comme dans la section  1.3 , nous travaillerons sur le .bashrcfichier, et la modification que nous effectuerons ajoutera un alias à notre shell.Dans un contexte informatique, un alias est simplement un synonyme d'une commande ou d'un ensemble de commandes.L'utilisation principale des alias Bash est de définir des commandes plus courtes pour les combinaisons couramment utilisées .</p>
                  <p class="lamda">Dans ce cas, nous définirons la commande lr(abréviation de « list reverse ») comme un alias pour ls -hartl, qui est la commande permettant de lister les fichiers et les répertoires en utilisant des valeurs lisibles par l' homme pour les tailles (par exemple, 29 Ko au lieu de 29 592 pour un fichier de 29 kilo-octets), y compris tous (même ceux cachés), classés par temps inverse , forme longue .Cette commande, que vous avez peut-être reconnue dans un exercice de 643-code Command Line  , est utile pour voir quels fichiers et répertoires ont récemment changé (en plus d'être, pour des raisons évidentes, l'un de mes favoris personnels).Après avoir défini l'alias, nous pourrons remplacer le plus verbeux</p>
                  <p class="cod">$ ls -hartl</p>
                  <p class="lamda">avec le plus concis</p>
                  <p class="cod">$ lr</p>                
                  <p class="lamda">
                    Les étapes se présentent comme suit : <br>
                    1-Appuyez ipour entrer en mode insertion. <br>
                    2-Saisissez le contenu indiqué dans la liste  1.4 .(Sur certains systèmes, le .bashrcfichier peut inclure du contenu préexistant, que vous pouvez simplement laisser en place.) <br>
                    3-Appuyez ESCpour quitter le mode d'insertion. <br>
                    4-Écrivez le fichier en utilisant :w<return>. <br>
                    5-Quittez Vim en tapant :q<return>.
                  </p>
                
                  <p class="lamda">Remarque : si vous faites des erreurs, vous pouvez taper ESCsuivi de upour annuler l'une des étapes précédentes.(La plupart des programmes utilisent Commande-Z ou Ctrl-Z pour annuler des choses, un autre exemple de raccourcis clavier non natifs utilisés par Vim.En revanche, les éditeurs évoqués à partir du chapitre  2 prennent tous en charge les raccourcis clavier natifs.)</p>
                  <p class="cod">
                    Liste 1.4 : Définition d’un alias Bash. <br>
                    ~/.bashrc <br>
                    alias  lr = 'ls -hartl'
                  </p>
                  <p class="lamda">Après avoir ajouté l' lralias à .bashrc, écrit le fichier et quitté, vous serez peut-être surpris de constater que la commande ne fonctionne pas encore :</p>
                  <p class="cod">
                    $ lr  <br>
                    -bash : lr : commande non trouvée
                  </p>
                  <p class="lamda">C'est parce que nous devons informer le shell du fichier de profil Bash mis à jour en le « sourçant » à l'aide de la sourcecommande, comme indiqué dans la liste  1.5</p>
                  <p class="cod">
                    Liste 1.5 : Activation de l’alias en sourçant le profil Bash. <br>
                    $ source .bashrc
                  </p>
                  <p class="lamda">Avec cela, la lrcommande devrait fonctionner comme annoncé :</p>
                  <p class="cod">
                    $ lr <br>
                    . <br>
                   . <br>
                   . <br>
                   drwx------+ 15 mhartl staff 510B 4 sept. 18:58 Bureau <br>
                   -rw------- 1 mhartl staff 13K 4 sept. 19:13 .viminfo <br>
                   -rw-r--r-- 1 mhartl staff 46B 4 sept. 19:14 .bashrc <br>
                   drwxr-xr-x+ 117 mhartl staff 3.9K 4 sept. 19:14 .

                  </p>
                  <p class="lamda">Au fait, le .bashrcfichier est sourcé automatiquement lorsque nous ouvrons un nouvel onglet ou une nouvelle fenêtre de terminal, donc un sourçage explicite n'est nécessaire que lorsque nous voulons qu'une modification soit reflétée dans le terminal actuel .</p>
                  <h2 id="sept">1.4.1 Exercices</h2>
                  <p class="exo">1-Définissez un alias gpour la fonction grep insensible à la casse grep -i couramment utilisée .Que se passe-t-il si, après avoir effectué vos modifications et appuyé sur ESC, vous émettez la commande :wqau lieu de :wet :qséparément ?</p>
                  <p class="exo">2-Vous vous souvenez peut-être de la curlcommande de 643-code Command Line  , qui nous permet d'interagir avec les URL via la ligne de commande.Définir getcomme alias pour curl -OL, qui est la commande permettant de télécharger un fichier sur le disque local (tout en suivant les redirections rencontrées en cours de route).</p>
                  <p class="exo">3-Utilisez l'alias de l'exercice précédent pour exécuter la commande affichée dans la liste  1.6 , qui télécharge un fichier texte plus long à utiliser dans la section  1.6 .</p>
                  <p class="cod">
                    Liste 1.6 : Téléchargement d’un fichier texte plus long à utiliser dans une section ultérieure. <br>
                    $ obtenir cdn.learnenough.com/sonnets.txt
                  </p>
                  <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
        </section>
        <!-- 7 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="huit">1.5 Suppression de contenu</h2>
                 <p class="lamda">Comme pour chaque catégorie de manipulation de texte, Vim dispose d'un nombre énorme de commandes pour supprimer du contenu, mais dans cette section, nous allons simplement couvrir le strict minimum.Nous commencerons par supprimer des caractères individuels, ce que nous pouvons faire en mode normal à l'aide de la xcommande :</p>
                  <p class="lamda">
                    1-Ouvrez .bashrcet insérez le mot mal orthographié aliaes. <br>
                    2-Revenez au mode normal en appuyant sur ESC. <br>
                    3-Déplacez le curseur sur l' eentrée aliaes( Figure  1.8 ) et appuyez sur x.
                  </p>
                <p class="cycle spec"><img src="/ressources/e7.png" alt=""></p>
                <p class="fig">Figure 1.8 : Préparation de la suppression d’une lettre à l’aide de x.</p>
                <p class="lamda">Il existe de nombreuses façons sophistiquées de supprimer du texte, mais en appuyant plusieurs fois, xil est facile (même si c'est un peu fastidieux) de supprimer des mots entiers ou même des lignes entières.En revanche, la suppression de lignes est un cas suffisamment particulier pour mériter d’être inclus.Débarrassons-nous du supplément que aliasnous avons ajouté en appuyant sur ddpour supprimer la ligne.Voilà  !Il devrait avoir disparu ( Figure  1.9 ).Pour le récupérer, vous pouvez appuyer psur « mettre » la ligne, ce qui vous permet également de simuler le copier-coller d’une ligne à la fois.(Encore une fois, il s'agit d'un sous-ensemble minimal de Vim ; si vous décidez de vous y perfectionner, vous apprendrez de nombreuses meilleures façons de faire les choses.)</p>
                <p class="cycle spec"><img src="/ressources/e8.png" alt=""></p>
                <p class="fig">Figure 1.9 : Résultat de la suppression d'une ligne avec dd.</p>
                <h2 id="neuf">1.5.1 Exercices</h2>
                <p class="exo">1-À l’aide de Vim, ouvrez un nouveau fichier </p>
                <p class="exo">2-Insérez la chaîne « Un léopard ne peut pas changer ses taches. » ( Figure  1.10 ).</p>
                <p class="exo">3-A l'aide de la xtouche , supprimez le caractère nécessaire pour corriger l'erreur dans la ligne que vous venez de saisir.(Si vous ne trouvez pas l’erreur, reportez-vous au tableau  1.1 .)</p>
                <p class="exo">4-Utilisez ddpour supprimer la ligne, puis utilisez ppour la coller à plusieurs reprises dans le document.
                </p>
                <p class="exo">5-Enregistrez le document et quittez en utilisant une seule commande. Astuce : voir le premier exercice de la section  1.4.1 .</p>

                <p class="cycle spec"><img src="/ressources/e9.jpg" alt=""></p>
                <p class="fig">Figure 1.10 : Les capacités de cet animal à changer de tache sont fréquemment remises en question.</p>


                <button class="btn">Commencer: le chapitre</button>

             </div>
             
         </div>
 
         
        </section>
        <!-- 8 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="dix">1.6 Modification de fichiers volumineux</h2>
                 <p class="lamda">Les compétences finales nécessaires pour votre Vim minimum viable impliquent la navigation dans des fichiers volumineux.Si vous n'avez pas téléchargé sonnets.txtles exercices de la section  1.4 , vous devriez le faire maintenant ( liste  1.7 ).</p>
                   <p class="cod">
                    Liste 1.7 : Téléchargement des sonnets de Shakespeare . <br>
                    $ curl -OL https://cdn.learnenough.com/sonnets.txt
                   </p>

                  <p class="lamda">Le fichier résultant contient le texte intégral des Sonnets de Shakespeare , qui compte 2620 lignes, 17670 mots et 95635 caractères, ce que nous pouvons vérifier à l'aide de la commande de comptage de mots  wc décrite dans Apprendre une ligne de commande suffisamment dangereuse :</p>
                  <p class="cod">
                    $ wc sonnets.txt <br>
                    2620 17670 95635 sonnets.txt
                  </p>
                  <p class="lamda">Sur de nombreux systèmes, Vim affiche certaines des mêmes statistiques de base lors de l'ouverture du fichier :</p>
                  <p class="cod">
                    $ vim sonnets.txt
                  </p>
                  <p class="lamda">Le résultat sur mon système apparaît dans la Figure  1.11 .En raison de sa longueur, ce fichier est beaucoup trop long pour être parcouru facilement à la main.</p>
                  <p class="cycle spec"><img src="/ressources/e10.png" alt=""></p>
                  <p class="fig">Figure 1.11 : Quelques statistiques de fichiers affichées au démarrage de Vim.</p>
                  
                  <p class="cod"></p>
                  <p class="lamda">Comme auparavant, il existe de nombreuses commandes pour se déplacer, mais je trouve que les plus utiles impliquent de déplacer un écran à la fois, de se déplacer au début ou à la fin, ou d'effectuer une recherche.Les commandes pour déplacer un écran à la fois sont Ctrl-F (Avant) et Ctrl-B (Arrière).Pour aller à la fin du fichier, nous pouvons utiliser G, et pour aller au début, nous pouvons utiliser 1G.Enfin, la commande de navigation la plus puissante est peut-être la recherche , qui consiste à taper une barre oblique  /suivie de la chaîne que vous souhaitez rechercher.L'astuce consiste à taper /<string>suivi de retour, puis à appuyer npour passer à la correspondance suivante (le cas échéant).</p>
                  <p class="cod"></p>
                  <p class="lamda">Tout cela peut sembler un peu familier, car c'est la même que l'interface du lessprogramme abordé dansle tutorielde ligne de commande  .C’est l’un des avantages de l’apprentissage des commandes Unix de base : de nombreux modèles se reproduisent dans de nombreux contextes différents.</p>
                  <p class="cod"></p>
                  
                  <h2 id="onze">1.6.1 Exercices</h2>
                  <p class="exo">1-Avec sonnets.txtouvert dans Vim, descendez de trois écrans, puis remontez de trois écrans.</p>
                  <p class="exo">2-Aller à la fin du fichier.Quelle est la dernière ligne du sonnet final ?</p>
                  <p class="exo">3-Revenez en haut pour changer l’ancien nom « Shakespeare » sur la ligne 1 en sonnets.txt« Shakespeare » plus moderne, et enregistrez le résultat.</p>
                  <p class="exo">4-Utilisez la fonction de recherche de Vim pour découvrir quel sonnet contient des références à Cupidon, le dieu romain de l'amour.</p>
                  <p class="exo">5-Confirmez que cela 18Gva à la dernière ligne du premier sonnet.Que pensez-vous que fait cette commande ? Astuce : rappelez-vous que cela 1Gva au début du fichier, c'est-à-dire à la ligne 1.</p>



                  <button class="btn">Commencer: le chapitre</button>

             </div>
             
         </div>
 
        </section>
        <!-- 9 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="douze">1.7 Résumé</h2>
                 <p class="lamda">Les commandes importantes de ce chapitre sont résumées dans le tableau  1.1 .Si vous souhaitez en savoir plus sur Vim, taper « learn vim » dans un moteur de recherche est une bonne idée.Le didacticiel interactif Vim est particulièrement recommandé.</p>
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Commande</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Description</font></font></strong></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ESC:q!&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">La commande Vim la plus importante™</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">i</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Quitter le mode normal, entrer en mode insertion</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ESC</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Quitter le mode insertion, entrer en mode normal</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Touches fléchées</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Se déplacer</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">0</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Aller au début de la ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">$</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Aller jusqu'au bout de la ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">:w&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Enregistrer (écrire) un fichier</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">:q&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Quitter un fichier (doit être enregistré)</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">:wq&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Écrire et quitter un fichier</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">:q!&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Forcer la fermeture d'un fichier, en annulant toutes les modifications</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">u</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Défaire</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">x</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Supprimer le caractère sous le curseur</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">dd</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Supprimer une ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">p</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Coller le texte supprimé</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">it’s spots</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Non, tu veux dire</font></font><code class="tt">its spots</code>
                    </td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">Ctrl-F</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Avancer d'un écran</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">Ctrl-B</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Revenir à l'écran précédent</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">G</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Aller à la dernière ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">1G</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Aller à la première ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">/&lt;string&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Rechercher</font></font><code class="tt">&lt;string&gt;</code>
                    </td>
                    </tr>
                    </tbody>
                    </table>

                    <h2 id="treize">1.7.1 Exercices</h2>
                    <p class="exo">1-Ouvrir sonnets.txt</p>
                    <p class="exo">2-Allez à la dernière ligne</p>
                    <p class="exo">3-Allez jusqu'à la fin de la dernière ligne</p>
                    <p class="exo">4-Créez une nouvelle ligne qui dit « C'est tout, les amis !Barde dehors.<laisse tomber le micro>”.Assurez-vous de déplacer le curseur d'un espace vers la droite afin de ne pas faire glisser le point final.</p>
                    <p class="exo">5-Écrivez le fichier.</p>
                    <p class="exo">6-Annulez vos modifications.</p>
                    <p class="exo">7-Écrivez et quittez le fichier</p>
                    <p class="exo">8-Rouvrez le fichier et tapez 2620dd</p>
                    <p class="exo">9-Sachez que vous venez de supprimer l'intégralité du contenu du fichier et appliquez la commande Vim la plus importante™ pour vous assurer qu'aucun dommage n'est causé.</p>
                    <button class="btn">Commencer: le chapitre</button>
             
                </div>
             
         </div>
 
        </section>
        <!-- 10 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3 id="chap2">Chapitre 2 </h3>
                 <h2 id="quatorze">Éditeurs de texte modernes</h2>
                <p class="lamda">  Après avoir appris les bases minimales de l'édition de texte avec Vim, nous sommes désormais en mesure d'apprécier les éditeurs de texte « modernes » préférés mentionnés au début de ce tutoriel. Ces éditeurs comprennent des éditeurs natifs multiplateformes tels que Sublime Text, Visual Studio Code et , ainsi que des éditeurs dans le cloud comme Cloud9. Les éditeurs modernes se distinguent par leur combinaison de puissance et de facilité d'utilisation : vous pouvez effectuer des opérations sophistiquées telles que la recherche et le remplacement globaux, mais (contrairement à Vim) ils vous permettent simplement de cliquer dans une fenêtre et de commencer à taper. De plus, beaucoup d'entre eux (y compris  et Sublime) incluent une option permettant de fonctionner en mode de compatibilité Vim. Ainsi, même si vous finissez par adorer Vim, vous pouvez toujours utiliser un éditeur moderne sans avoir à abandonner complètement Vim.</p>
                <p class="lamda">Dans la suite de ce tutoriel, nous explorerons les capacités des éditeurs de texte modernes. Nous aborderons tous les sujets abordés dans notre discussion sur Vim (chapitre 1), ainsi que de nombreux autres sujets plus avancés, notamment l'ouverture de fichiers, le déplacement, la sélection de texte, le couper/copier/coller, la suppression et l'annulation, l'enregistrement et la recherche/remplacement, qui sont tous importants pour l'édition quotidienne. Nous aborderons également les éléments de menu et les raccourcis clavier, qui vous aideront à rendre votre édition de texte plus rapide et plus efficace.</p>
                <p class="lamda">À titre de référence, le tableau 2.1 présente les symboles correspondant aux différentes touches d'un clavier Macintosh standard. Si votre clavier est différent, faites appel à vos connaissances techniques (encadré 1.2).</p>
                
                <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong>Key</strong></td>
                    <td class="align_left"><strong>Symbol</strong></td>
                    </tr>
                    <tr>
                    <td class="align_left">Command</td>
                    <td class="align_left">⌘</td>
                    </tr>
                    <tr>
                    <td class="align_left">Control</td>
                    <td class="align_left">⌃</td>
                    </tr>
                    <tr>
                    <td class="align_left">Shift</td>
                    <td class="align_left">⇧</td>
                    </tr>
                    <tr>
                    <td class="align_left">Option</td>
                    <td class="align_left">⌥</td>
                    </tr>
                    <tr>
                    <td class="align_left">Up, down, left, right</td>
                    <td class="align_left">↑ ↓ ← →</td>
                    </tr>
                    <tr>
                    <td class="align_left">Enter/Return</td>
                    <td class="align_left">↵</td>
                    </tr>
                    <tr>
                    <td class="align_left">Tab</td>
                    <td class="align_left">⇥</td>
                    </tr>
                    <tr>
                    <td class="align_left">Delete</td>
                    <td class="align_left">⌫</td>
                    </tr>
                    </tbody>
                    </table>
                
                    <p class="fig">Table 2.1: Symboles divers du clavier.</p>
            
            
            
                    <button class="btn">Commencer: le chapitre</button>
            </div>
             
         </div>
 
         
        </section>
        <!-- 11 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="quinze">2.1 Choisir un éditeur de texte</h2>
                 <p class="lamda">Bien que les IDE cloud présentent de nombreux avantages, tout aspirant magicien de l'informatique devrait apprendre à utiliser au moins un éditeur natif (c'est-à-dire un éditeur qui fonctionne sur votre système d'exploitation de bureau). Il existe de nombreux éditeurs parmi lesquels choisir, mais les éditeurs de texte modernes les plus prometteurs actuellement utilisés sont probablement Sublime Text (parfois simplement appelé « Sublime »), Visual Studio Code (VScode) et .1 Chacun présente ses propres avantages et inconvénients.
                 <h2 id="seize">2.1.1 Sublime Text</h2>
                <p class="lamda">
                    <h3>Advantages</h3> <br>
                    
                   1-Puissant, personnalisable et facile à utiliser <br>
                    2-Peut être utilisé gratuitement en « mode évaluation » <br>
3-Rapide et robuste, même lors de l'édition de fichiers/projets volumineux <br>
4-Fonctionne sur plusieurs plateformes (Windows, macOS, Linux) <br>
5-Soutenu par une entreprise rentable qui a fait ses preuves en matière d'assistance et de développement
                   <h3>Disadvantages</h3> 
                    Gratuit 
                     <br>
Comporte une fenêtre contextuelle légèrement agaçante qui ne disparaît que si vous achetez une licence <br>
Coûte 70 $ à la date de rédaction de cet article <br>
La configuration des outils en ligne de commande nécessite quelques manipulations
                    <h2>2.1.2 Visual Studio Code (VSCode)</h2>
                    <h3>Advantages</h3>
                   Puissant, avec de nombreux packages <br>
                    Utilisation gratuite <br>
Rapide et robuste, même lors de l'édition de fichiers/projets volumineux <br>
Fonctionne sur plusieurs plateformes (Windows, macOS, Linux) <br>
Soutenu par Microsoft
                    <h3>Disadvantages</h3>
                   Non open source <br>
                    Soutenu par Microsoft <br>
                    <h2> 2.1.3 Atom</h2>
                    <h3>Advantages</h3>
                    Puissant, piratable et facile à utiliser <br>
Gratuit au sens propre comme au sens figuré (c'est-à-dire qu'il ne coûte rien et qu'il s'agit d'un logiciel open source) <br>
Fonctionne sur plusieurs plateformes (Windows, macOS, Linux) <br>
Outils de ligne de commande faciles à configurer <br>
Soutenu par GitHub, le géant de la collaboration <br>
                    <h3>Disadvantages</h3>
                    Rapports indiquant qu'il est parfois plus lent que Sublime ou VSCode <br>
Depuis l'acquisition de GitHub par Microsoft, soutenu par Microsoft <br>
Archivé par GitHub (voir détails ci-dessous) <br>
 Il est difficile de se tromper avec l'un de ces choix. En raison de sa simplicité et de sa gratuité totale, je recommandais auparavant  comme le meilleur choix pour les nouveaux utilisateurs. Comme nous l'avons brièvement évoqué au chapitre 1, GitHub a toutefois annoncé en juin 2022 son intention d'archiver le projet  dans un article de blog intitulé « Sunsetting ». Étant donné que  est open source, il est probable qu'il continue d'être disponible sous une forme ou une autre, mais dans ces circonstances, nous encourageons particulièrement les lecteurs de ce tutoriel à envisager Visual Studio Code ou Sublime Text comme alternatives. En raison de la difficulté à mettre à jour les vidéos, les screencasts qui accompagnent ce tutoriel utilisent toujours , mais les captures d'écran et les principaux exemples dans le texte écrit utilisent désormais Sublime Text, qui est en fait mon éditeur principal au quotidien. (Heureusement, Sublime Text et  sont presque identiques à bien des égards, même au niveau des raccourcis clavier.)
                                       <br> La bonne nouvelle, c'est que les compétences présentées dans les sections suivantes sont quasi universelles ; si vous apprenez  mais décidez de passer à Sublime Text ou VSCode (ou même à un IDE cloud) pour vos tâches d'édition quotidiennes, la plupart des idées fondamentales seront facilement transposables. C'est précisément en raison d'événements imprévisibles tels que la fin de  que 643-code Text Editor  se concentre sur des principes généraux plutôt que sur des éditeurs spécifiques. Par conséquent, les exemples de ce tutoriel qui utilisent  restent pertinents malgré cette évolution. Cela souligne également l'importance cruciale de la sophistication technique (encadré 1.2), qui vous permet de vous adapter à de tels changements sans difficulté majeure.
                    
            

                   <p class="lamda">Il est difficile de se tromper avec l'un de ces choix. En raison de sa simplicité et de sa gratuité totale, je recommandais auparavant  comme le meilleur choix pour les nouveaux utilisateurs. Comme nous l'avons brièvement évoqué au chapitre 1, GitHub a toutefois annoncé en juin 2022 son intention d'archiver le projet  dans un article de blog intitulé « Sunsetting ». Étant donné que  est open source, il est probable qu'il continuera d'être disponible sous une forme ou une autre, mais dans ces circonstances, nous encourageons particulièrement les lecteurs de ce tutoriel à envisager Visual Studio Code ou Sublime Text comme alternatives. En raison de la difficulté à mettre à jour les vidéos, les screencasts qui accompagnent ce tutoriel utilisent toujours , mais les captures d'écran et les principaux exemples dans le texte écrit utilisent désormais Sublime Text, qui est en fait mon éditeur principal au quotidien. (Heureusement, Sublime Text et Atom sont presque identiques à bien des égards, même en ce qui concerne les raccourcis clavier.)</p>
                                    <p class="lamda">La bonne nouvelle, c'est que les compétences présentées dans les sections suivantes sont quasi universelles ; si vous apprenez  mais décidez de passer à Sublime Text ou VSCode (ou même à un IDE cloud) pour vos tâches d'édition quotidiennes, la plupart des concepts fondamentaux resteront facilement applicables. C'est précisément en raison d'événements imprévisibles tels que la fin de  que l'éditeur de texte 643-code  se concentre sur des principes généraux plutôt que sur des éditeurs spécifiques. Par conséquent, les exemples de ce tutoriel qui utilisent  restent pertinents malgré cette évolution. Cela souligne également l'importance cruciale de la sophistication technique (encadré 1.2), qui vous permet de vous adapter à de tels changements sans difficulté majeure.
                 
<h2 id="dixneuf">2.1.4 Exercices</h2>
                 <p class="lamda">Installez et configurez un éditeur de texte sur votre système comme suit :</p>
                <p class="exo">1-Installez et configurez un éditeur de texte sur votre système comme suit :</p>
                <p class="exo">2-Si vous utilisez Sublime Text, configurez la commande subl en recherchant « sublime text command line » sur Google et en suivant les instructions pour votre système. Si vous rencontrez des difficultés, mettez à profit votre sophistication technique (encadré 1.2). Vous pouvez également passer à la section 3.3 pour savoir comment configurer le chemin d'accès de votre système.
                
<p class="exo">3-Si vous utilisez VSCode, configurez la commande code en recherchant « visual studio code command line » sur Google et en suivant les instructions pour votre système. </p>
                <p class="exo">4-Si vous utilisez , allez dans  > Install Shell Commands pour activer la commande  dans la ligne de commande (Figure 2.1).</p>
               
<p class="cycle spec"><img src="/ressources/e11.png" alt=""></p>
               <p class="fig">Figure 2.1 : Installation des commandes shell.</p>

               <button class="btn">Commencer: le chapitre</button>


             </div>
             
         </div>
 
         
        </section>
        <!-- 12 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 
<h3>Chapitre 2</h3>
                 <h2 id="vin">2.2 Ouverture</h2>
                <p class="lamda">Pour ouvrir des fichiers, nous allons utiliser la commande configurée dans la section 2.1.4 afin de lancer l'éditeur et d'ouvrir le fichier en même temps (une méthode que nous avons utilisée avec vim dans la section 1.3). Dans la section 3.4, nous aborderons une deuxième méthode (appelée « ouverture floue ») qui est utile lorsque vous modifiez un projet comportant plusieurs fichiers. Je pars du principe que vous utilisez la commande subl, mais si vous utilisez un autre éditeur, vous devrez effectuer les substitutions appropriées (par exemple,  ou code à la place de subl).</p>
                
<p class="lamda">Commençons par télécharger un fichier exemple, README.md, depuis le Web. Comme dans les sections 2.7.1 et 1.6, nous utiliserons la commande curl pour télécharger le fichier à partir de la ligne de commande :</p>
                <p class="cod">
Listing 2.1 : Téléchargement du fichier README avec curl. <br>
                    
$ curl -OL https://cdn.learnenough.com/README.md
                </p>
<p class="lamda">Comme l'indique l'extension .md, le fichier téléchargé est écrit en Markdown, un langage de balisage lisible par l'homme, conçu pour être facilement convertible en HTML, le langage du World Wide Web.
                
<p class="lamda">Après avoir téléchargé README.md, nous pouvons l'ouvrir à partir de la ligne de commande comme suit :</p>
                <p class="cod">$ subl README.md</p>
                <p class="lamda">(Si cela ne fonctionne pas, assurez-vous d'avoir installé les commandes shell Sublime Text comme indiqué dans la section 2.1.4.) Le résultat de l'ouverture de README.md dans Sublime Text devrait ressembler à la figure 2.2 ou à la figure 2.3. (Si c'est la première fois que vous ouvrez Sublime Text, il est également possible que vous voyiez un écran d'accueil unique. Comme d'habitude, appliquez l'encadré 1.2.) La figure 2.2 montre le réglage par défaut habituel, qui consiste à désactiver le « retour à la ligne automatique » ; comme les fichiers Markdown sont généralement écrits en utilisant une longue ligne pour chaque paragraphe, ce réglage n'est pas idéal dans ce cas, je recommande donc d'activer le retour à la ligne automatique à l'aide de l'élément de menu illustré à la figure 2.4.
                
<p class="cycle spec"><img src="/ressources/e12.png"   alt=""></p>
                <p class="fig">Figure 2.2 : Exemple de fichier avec le retour à la ligne automatique désactivé.
                
<p class="cycle spec"><img src="/ressources/e13.png" alt=""></p>
                <p class="fig">Figure 2.3 : Exemple de fichier avec le retour à la ligne automatique activé.
                
<p class="cycle spec"><img src="/ressources/e14.png" alt=""></p>
                <p class="fig">Figure 2.4 : Élément de menu permettant d'activer ou de désactiver le retour à la ligne automatique.
                <p class="lamda">Dans certains éditeurs, tels que l'IDE cloud de Cloud9, il est plus courant d'ouvrir les fichiers à l'aide du navigateur du système de fichiers (bien qu'en réalité, la commande c9 puisse être utilisée pour ouvrir des fichiers dans la ligne de commande Cloud9).2 Double-cliquez sur README.md dans le navigateur du système de fichiers (Figure 2.5) pour ouvrir le fichier dans l'éditeur Cloud9, comme illustré dans la Figure 2.6. (Si vos résultats ne correspondent pas, assurez-vous d'avoir exécuté la commande curl indiquée dans le listing 2.1.) La figure 2.7 montre le fichier après avoir cliqué sur Navigate pour fermer le navigateur du système de fichiers, et nous voyons que, comme dans la figure 2.2, la ligne s'étend de manière gênante hors de l'écran. Nous pouvons corriger cela à l'aide de View > Wrap Lines, comme le montre la figure 2.8, le résultat du retour à la ligne apparaissant comme dans la figure 2.9. (Comprendre qu'un élément de menu tel que View > Wrap Lines active le retour à la ligne est exactement le genre de chose que vous devriez être capable de comprendre grâce à vos connaissances techniques (encadré 1.2).)
                
<p class="cycle spec"><img src="/ressources/e15.png" alt=""></p>
                <p class="fig">Figure 2.5 : Le navigateur du système de fichiers Cloud9.
<p class="cycle spec"><img src="/ressources/e16.png" alt=""></p>
                
<p class="fig">Figure 2.6 : Cloud9 après avoir double-cliqué sur README.md.</p>
                <p class="cycle spec"><img src="/ressources/e17.png" alt=""></p>
                <p class="fig">Figure 2.7 : Cloud9 avec le retour à la ligne automatique désactivé.</p>
                
<p class="cycle spec"><img src="/ressources/e18.png" alt=""></p>
                <p class="fig">Figure 2.8 : Activation du retour à la ligne automatique dans Cloud9.
<p class="cycle spec"><img src="/ressources/e19.png" alt=""></p>
                
<p class="fig">Figure 2.9 : Cloud9 avec le retour à la ligne automatique activé. </p>
                <h2 id="vinun">2.2.1 Mise en évidence de la syntaxe</h2>
                <p class="lamda">En examinant les figures 2.3 et 2.9, vous avez peut-être remarqué que Sublime Text et Cloud9 affichent différents aspects du fichier dans des couleurs différentes. Par exemple, Sublime Text affiche les caractères entre crochets [] (qui représentent le texte des liens HTML) dans une couleur plus claire que le reste du texte, tandis que Cloud9 affiche le même texte en vert. Cette pratique, appelée mise en évidence de la syntaxe, facilite considérablement l'identification visuelle des formats de texte spéciaux. Il est essentiel de comprendre que cette pratique est strictement à notre avantage ; pour l'ordinateur, le document en question reste du texte brut.
                <p class="lamda">Vous vous demandez peut-être comment Sublime Text et Cloud9 ont su quel schéma de mise en évidence utiliser. La réponse est qu'ils déduisent le format du document à partir de l'extension du type de fichier (dans ce cas, .md pour Markdown). La mise en évidence dans le cas de Cloud9 est assez contrastée, mais dans le cas de Sublime Text, elle n'est pas particulièrement visible ; les éléments les plus significatifs sont les différentes couleurs utilisées pour les titres</p>
                 
<p class="cod"># Exemple de document</p>
                 <p class="lamda">et pour les liens tels que
                 <p class="cod">[Michael Hartl](https://www.michaelhartl.com/)</p>
                 
<p class="lamda">Nous verrons des exemples plus spectaculaires de mise en évidence de la syntaxe dans la section 2.7 et surtout dans la section 3.2.
                 </p>
                 
<h2 id="vindeux">2.2.2 Prévisualisation de Markdown</h2>
                 <p class="lamda">Pour finir, j'aimerais souligner que certains éditeurs permettent de prévisualiser Markdown au format HTML. Cette section utilise  car son outil de prévisualisation Markdown est particulièrement facile à utiliser, mais consultez la section 3.5 pour savoir comment configurer Sublime Text afin d'obtenir le même résultat. </p>
                 <p class="lamda">Nous pouvons découvrir comment prévisualiser Markdown avec  en utilisant nos connaissances techniques (encadré 1.2), dans ce cas en cliquant sur le menu Aide et en recherchant « Aperçu » (figure 2.10). Le résultat est un package intégré appelé Markdown Preview, qui convertit Markdown en HTML et affiche le résultat, comme le montre la figure 2.11. Dans ce contexte, il est pratique de travailler avec une largeur étendue afin que la source et l'aperçu soient suffisamment larges pour être facilement visibles, comme le montre la figure 2.12. Pour ce faire, il suffit de passer la souris sur le côté de la fenêtre pour faire apparaître une icône en forme de double flèche, puis de la faire glisser pour augmenter la taille. Nous verrons un autre exemple de cette configuration à « double volet » dans un contexte plus général à partir de la section 3.4.
                 
<p class="cycle spec"><img src="/ressources/e120.png" alt=""></p>
                 <p class="fig">Figure 2.10 : Utilisation du menu Aide pour apprendre à prévisualiser Markdown.
<p class="cycle spec"><img src="/ressources/e21.png" alt=""></p>
                 
<p class="fig">Figure 2.11 : Aperçu Markdown dans .</p>
                 <p class="cycle spec"><img src="/ressources/e22.png" alt=""></p>
                 <p class="fig">Figure 2.12 : Utilisation d'une fenêtre plus large pour la source et l'aperçu.
               
<h2 id="vintrois">2.2.3Exercices</h2>
                <p class="exo">1-En appliquant les méthodes de l'encadré 1.2, trouvez un aperçu Markdown en ligne (c'est-à-dire qui fonctionne dans un navigateur web) et utilisez-le pour voir un aperçu de README.md. Comment les résultats se comparent-ils à ceux de la figure 2.11 ?</p>
                <p class="exo">2-Ouvrez un nouveau document appelé lorem.txt et remplissez-le avec le texte présenté dans le listing 2.2. Le résultat comporte-t-il une coloration syntaxique ?</p>
                
<p class="exo">3-Ouvrez un nouveau document appelé test.rb et remplissez-le avec le texte indiqué dans le listing 2.3. Le résultat comporte-t-il une coloration syntaxique ?</p>
                <p class="cod">
Listing 2.2 : Texte lorem ipsum. <br>
~/lorem.txt <br>
Lorem ipsum dolor sit amet
</p>
                
<p class="cod">
                    Listing 2.3 : Un fichier test. <br>
~/test.rb <br>
puts « test »
</p>
<button class="btn">Commencer : le chapitre</button>
</div>
</div>
 
         
        </section>
        <!-- 13 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="vinquatre">2.3 Déplacement</h2>
                    <p class="lamda">Contrairement aux commandes de déplacement dans Vim (chapitre 1, résumées dans le tableau 1.1), les commandes de déplacement dans les éditeurs modernes correspondent généralement aux techniques utilisées dans d'autres programmes tels que les traitements de texte, les programmes de messagerie électronique et les navigateurs web.
 Par conséquent, il est possible que vous connaissiez déjà certaines ou toutes ces techniques ; si ce n'est pas le cas, en suivant les étapes décrites dans cette section, vous améliorerez votre maîtrise d'autres programmes. 
Pour commencer, ouvrons le fichier volumineux de la section 1.6 contenant le texte intégral des Sonnets de Shakespeare :
                     
<p class="cod">$ subl sonnets.txt</p>
                     <p class="lamda">(Si cela ne fonctionne pas, vous devrez peut-être exécuter la commande du listing 1.7, et vous devrez également vérifier que vous êtes dans le bon répertoire.) Le résultat apparaît dans la figure 2.13.
 Notez que la figure 2.13 montre le fichier sonnets.txt dans son propre onglet, le fichier README.md de la section 2.2 occupant l'autre onglet. Votre résultat peut varier ; dans tous les cas, nous aborderons plus en détail les onglets dans la section 3.4. 
                      <p class="cycle spec"><img src="/ressources/e23.png" alt=""></p>
                      
<p class="fig">Figure 2.13 : Ouverture des Sonnets de Shakespeare dans un éditeur de texte. </p>
                      <p class="lamda">Comme avec la plupart des autres programmes natifs tels que les traitements de texte, les navigateurs web, etc., vous pouvez vous déplacer dans un éditeur moderne à l'aide de la souris ou du pavé tactile. Vous pouvez cliquer pour placer le curseur, faire défiler à l'aide d'une molette ou de gestes multi-touch, ou cliquer et faire glisser la barre de défilement.
 La figure 2.14 montre la barre de défilement de Sublime Text. La figure 2.14 montre également le type d'affichage à deux volets brièvement mentionné dans la figure 2.12, que nous aborderons plus en détail dans la section 3.4.                       
Figure 2.14 : La barre de défilement de Sublime Text.
                      
<p class="fig">Figure 2.14 : La barre de défilement de Sublime Text. </p>
                      <p class="lamda">En plus d'utiliser la souris ou le pavé tactile, j'aime aussi utiliser les touches fléchées pour me déplacer, généralement en combinaison avec la touche Commande ⌘ (Tableau 2.1). (Sous Linux, la touche Commande est généralement remplacée par la touche de fonction fn, et sous Windows, c'est généralement la touche Ctrl, mais vous devrez appliquer l'encadré 1.2 pour connaître les détails.) Mon édition de texte implique généralement beaucoup de ⌘← et ⌘→ pour me déplacer au début et à la fin des lignes, et ⌘↑ et ⌘↓ pour me déplacer en haut et en bas du fichier. Un exemple de déplacement à la fin de la ligne dans README.md apparaît dans la figure 2.15, et un exemple de déplacement à la fin du fichier dans sonnets.txt apparaît dans la figure 2.16. 
                      <p class="cycle spec"><img src="/ressources/e25.png" alt=""></p>
                      
<p class="fig">Figure 2.15 : Déplacement à la fin d'une ligne avec ⌘→. </p>
                      <p class="cycle spec"><img src="/ressources/e26.png" alt=""></p>
<p class="fig">Figure 2.16 : Déplacement à la fin du fichier avec ⌘↓. </p>
                      
<h2 id="vincinq">2.3.1 Exercices</h2>
                      <p class="exo">1-Dans votre éditeur de texte, comment vous déplacez-vous vers la gauche et vers la droite d'un mot à la fois ? Indice : sur certains systèmes, la touche Option ⌥ peut s'avérer utile. </p>
                      <p class="exo">2-Dans README.md, déplacez-vous vers l'avant-dernière ligne non vide en utilisant la technique de votre choix. Déplacez-vous ensuite vers le troisième mot à partir du début de cette ligne.
                      <p class="exo">3-Quelle est la commande permettant d'aller à un numéro de ligne particulier ? Utilisez cette commande pour vous rendre à la ligne 293 de sonnets.txt. Que font les vents violents ?</p>
                      <p class="exo">4-En vous déplaçant vers la dernière ligne non vide de sonnets.txt et en appuyant sur ⌘→ puis sur ⌘←, montrez que ⌘← s'arrête en fait dès qu'il atteint un espace blanc, avec le résultat indiqué dans la figure 2.17. Comment accéder au véritable début de la ligne ?</p>
                      <p class="cycle spec"><img src="/ressources/e27.png" alt=""></p>
<p class="fig">Figure 2.17 : Lorsque vous utilisez ⌘←, le curseur s'arrête sur l'espace blanc.


                      <button class="btn">Commencer: le chapitre</button>

                
             </div>
             
         </div>
 
        
        </section>
        <!-- 14 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="vinsix">2.4 Sélectionner du texte</h2>
                   <p class="lamda">La sélection de texte est une compétence importante qui est particulièrement utile pour supprimer ou remplacer du contenu, ainsi que pour couper, copier et coller (section 2.5). La plupart des techniques présentées dans cette section font directement appel aux commandes de déplacement décrites dans la section 2.3. Comme dans cette section, les idées présentées ici sont assez générales et s'appliquent à une grande variété d'applications, pas seulement aux éditeurs de texte. 
                    <p class="lamda">De la même manière que les éditeurs modernes facilitent l'utilisation de la souris pour déplacer le curseur, ils facilitent également l'utilisation de la souris pour sélectionner du texte. Il suffit de cliquer et de faire glisser le curseur de la souris, comme le montre la figure 2.18. Une autre technique étroitement liée consiste à cliquer sur un emplacement, puis à cliquer sur un autre emplacement tout en maintenant la touche Maj enfoncée pour sélectionner tout le texte entre les deux. 
                 <p class="cycle spec"><img src="" alt=""></p>
                 
<p class="fig">Figure 2.18 : Résultat obtenu en cliquant et en faisant glisser le curseur de la souris. </p>
                 
<h2 id="vinsept">2.4.1 Sélectionner un seul mot</h2>
<p class="lamda">
<p>Lors de la sélection de texte, certains cas particuliers méritent d'être examinés individuellement. Nous commencerons par quelques techniques permettant de sélectionner un seul mot :</p> <br>
                    1-Cliquez et faites glisser le curseur de la souris sur le mot. <br>
2-Double-cliquez sur le mot avec la souris. <br>
3-Appuyez sur ⌘D (dépend du système ; voir encadré 1.2). <br>
 </p>
               
<h2 id="vinhuit">2.4.2 Sélectionner une seule ligne</h2>
               <p class="lamda">
                   <p>Une autre technique, particulièrement importante lors de l'édition de texte basé sur des lignes comme du code informatique (ou des sonnets), consiste à sélectionner une ligne entière ou un ensemble de lignes. Nous commençons par les méthodes permettant de mettre en surbrillance une seule ligne :</p> <br>
                   
1-Cliquez au début de la ligne et faites glisser le curseur jusqu'à la fin.<br>
                   2-Cliquez à la fin de la ligne et faites glisser le curseur jusqu'au début <br>
                   3-Appuyez sur ⌘← (deux fois) pour aller au début de la ligne, puis appuyez sur ⇧⌘→ pour sélectionner jusqu'à la fin de la ligne. <br>
                   4-Appuyez sur ⌘→ pour vous rendre à la fin de la ligne, puis appuyez sur ⇧⌘← (deux fois) pour sélectionner le début de la ligne. <br>
</p>
 <h2 id="vinneuf">2.4.3 Sélectionner plusieurs lignes</h2>
                
<p class="lamda">
                    <p>Une technique tout aussi importante consiste à sélectionner plusieurs lignes :</p> <br>
1-Cliquez et faites glisser le curseur de la souris sur les mots/lignes. <br>
2-Maintenez la touche Maj enfoncée et déplacez les touches fléchées haut et bas (⇧↑ et ⇧↓). <br>
                                 
</p>
                  <p class="lamda">Cette dernière technique est l'une de mes préférées, et l'une de mes tâches d'édition les plus courantes consiste à appuyer sur ⌘← pour aller au début de la première ligne que je souhaite sélectionner, puis à appuyer plusieurs fois sur ⇧↓ jusqu'à ce que j'aie sélectionné toutes les lignes souhaitées (Figure 2.19). (Comme indiqué dans la section 2.3.1, dans de nombreux éditeurs, ⌘← s'arrête sur les espaces blancs, donc pour se déplacer au début de la ligne, il faut en fait appuyer deux fois de suite sur ⌘←. Être capable de comprendre des détails et des cas particuliers comme celui-ci est la marque d'une sophistication technique croissante (encadré 1.2).)</p>
                                
<p class="cycle spec"><img src="/ressources/e29.png" alt=""></p>
               <p class="fig">Figure 2.19 : Sélection d'un couplet de Shakespeare à l'aide de ⌘← et ⇧↓.
<h2 id="trente">2.4.4 Sélectionner l'intégralité du document
              
<p class="lamda">
                <p>Enfin, il est parfois utile de pouvoir sélectionner l'ensemble du document en une seule fois. Pour cela, il existe deux techniques principales :</p>
1-Utilisez un élément de menu appelé « Sélectionner tout » ou similaire. Les détails dépendent de l'éditeur ; la figure 2.20 montre l'utilisation du menu Sélection dans Sublime Text.
2-Appuyez sur ⌘A.
              
</p>
               <p class="lamda">Notez dans la figure 2.20 que le menu affiche en fait la commande correspondante (⌘A) ; utiliser les éléments du menu pour acquérir des connaissances est un excellent moyen d'apprendre les raccourcis clavier, qui, avec le temps, rendront l'édition de texte beaucoup plus efficace.
               
<p class="cycle spec"><img src="/ressources/e29.png" alt=""></p>
               <p class="fig">Figure 2.20 : Sélection de l'ensemble du document à l'aide du menu Sélection (Sublime Text).</p>
               <h2 id="trenteun">2.4.5 Exercices</h2>
               
<p class="exo">1-Sélectionnez le deuxième sonnet de Shakespeare en cliquant au début, puis en cliquant tout en maintenant la touche Maj enfoncée à la fin. 
               <p class="exo">2-Sélectionnez la première ligne du fichier en vous déplaçant au début avec ⌘↑ et en appuyant sur ⇧⌘→ (ou l'équivalent pour votre système).
               
<p class="exo">3-Supprimez la sélection de l'exercice précédent (à l'aide de la touche Suppr).
            </p>
               <p class="exo">4-Sélectionnez le mot « document » dans README.md et remplacez-le par « README ».</p>


               <button class="btn">Commencer: le chapitre</button>



             </div>
             
         </div>.
 
        
        </section>
        <!-- 15 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="trentedeux">2.5 Couper, copier, coller</h2>
                 <p class="lamda">Le trio Couper/Copier/Coller est l'un des ensembles d'opérations les plus utiles lors de l'édition de texte, en particulier lorsqu'il est exécuté via les raccourcis clavier ⌘X/⌘C/⌘V, facilement accessibles. (Couper/Copier/Coller sont disponibles dans les menus (Figure 2.21), mais ces opérations sont si courantes que je recommande vivement d'apprendre et d'utiliser les raccourcis clavier dès le début.) Bien que seul ⌘C soit mnémonique (« C » pour « Copier »), les touches sont commodément situées sur trois rangées consécutives de la rangée inférieure d'un clavier QWERTY standard, ce qui facilite leur utilisation en combinaison ou en succession rapide (Figure 2.22).</p>
                 
<p class="cycle spec"><img src="/ressources/e31.png" alt=""></p>
                 <p class="fig">Figure 2.21 : Les éléments de menu Couper/Copier/Coller (que vous ne devriez jamais utiliser).</p>
                 
<p class="lamda"></p>
                 <p class="cycle spec"><img src="/ressources/e32.jpg" alt=""></p>
                 <p class="fig">Figure 2.22 : Les touches XCV sur un clavier QWERTY standard.
                 <p class="lamda">Pour utiliser les fonctions Couper ou Copier, vous devez d'abord sélectionner le texte (section 2.4), puis appuyer sur ⌘X pour couper ou ⌘C pour copier. Lorsque vous utilisez ⌘C pour copier, le texte sélectionné est placé dans un tampon (zone de mémoire temporaire) ; en vous déplaçant à l'emplacement souhaité (section 2.3) et en appuyant sur ⌘V, vous pouvez coller le contenu dans le document à l'emplacement du curseur. ⌘X fonctionne de la même manière que ⌘C, sauf que le texte est supprimé du document et copié dans le tampon.
                 <p class="lamda">À titre d'exemple concret, sélectionnons un lien Markdown dans le fichier README.md, comme illustré à la figure 2.23. Après avoir copié avec ⌘C, nous pouvons coller le lien plusieurs fois (avec des retours entre chaque) en appuyant plusieurs fois sur ⌘V et la touche Entrée, comme illustré à la figure 2.24.
 Enfin, la figure 2.25 montre le résultat de la suppression de README du texte principal et de son collage à la fin du fichier. 
                 <p class="cycle spec"><img src="/ressources/e33.png" alt=""></p>
                 <p class="fig">Figure 2.23 : Sélection d'un lien Markdown.
                 
<p class="lamda"></p>
                 <p class="cycle spec"><img src="/ressources/e34.png" alt=""></p>
                 <p class="fig">Figure 2.24 : Collage du texte du lien plusieurs fois (avec des retours à la ligne entre chaque). </p>
                 <p class="lamda"></p>
                 <p class="cycle spec"><img src="/ressources/e35.png" alt=""></p>
                 <p class="fig">Figure 2.25 : Résultat de la suppression de « README » et du collage à la fin du fichier.
                 
<h2 id="trentetrois">2.5.1 Jumpcut</h2>
                 <p class="lamda">Bien que les fonctions Couper/Copier/Coller soient tout ce qui est strictement nécessaire pour l'édition quotidienne, elles présentent un inconvénient majeur : le tampon ne peut contenir qu'une seule chaîne. Cela signifie notamment que si vous coupez quelque chose et que vous appuyez accidentellement sur « copier » au lieu de « coller » (ce qui est facile, car les lettres sont adjacentes sur le clavier), vous écrasez le tampon et le texte que vous avez coupé est perdu à jamais (à moins que vous n'annuliez l'opération comme décrit dans la section 2.6). Si vous développez sur un Mac, il existe une solution à ce problème : un programme gratuit appelé Jumpcut. Cette petite application utilitaire remarquable étend la mémoire tampon en conservant plusieurs entrées dans l'historique. Vous pouvez naviguer dans cette mémoire tampon étendue à l'aide du menu Jumpcut (Figure 2.26) ou des raccourcis clavier ⌃⌥V (avancer) et ⇧⌃⌥V (reculer). J'utilise Jumpcut des dizaines, voire des centaines de fois par jour, et je vous recommande vivement de l'essayer. </p>
                 <p class="cycle spec"><img src="/ressources/e36.png" alt=""></p>
                 <p class="fig">Figure 2.26 : Jumpcut étend la mémoire tampon de copier-coller pour inclure un historique plus long.
                 
<h2 id="trentequatre">2.5.2 Exercices</h2>
                 <p class="exo">1-Sélectionnez l'ensemble du document, copiez-le et collez-le plusieurs fois. Le résultat devrait ressembler à la figure 2.27.
                
</p>
                 <p class="exo">2-Sélectionnez l'intégralité du document et coupez-le. Pourquoi cette méthode est-elle préférable à la suppression ?
</p>
                 <p class="exo">3-Sélectionnez et copiez le couplet à la fin du Sonnet 1 et collez-le dans un nouveau fichier appelé sonnet_1.txt. Comment créer un nouveau fichier directement dans votre éditeur ?</p>
                 
<p class="cycle spec"><img src="/ressources/e37.png" alt=""></p>
                 <p class="fig">Figure 2.27 : Résultat après avoir collé plusieurs fois l'intégralité du document. </p>









                 <button class="btn">Commencer: le chapitre</button>

                
             </div>
             
         </div>
 
         
        </section>
        <!-- 16-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="trentecinq">2.6 Suppression et annulation</h2>
                <p class="lamda">Nous avons déjà évoqué la suppression dans la section 2.4.5 (exercices de la section 2.4), qui consiste bien sûr simplement à appuyer sur la touche Suppr, parfois représentée par ⌫ (tableau 2.1).
 Comme pour Couper/Copier/Coller (section 2.5), la suppression est particulièrement utile lorsqu'elle est combinée avec les techniques de sélection de la section 2.4.                <p class="lamda">En plus de la technique évidente qui consiste à sélectionner et à supprimer du texte, sur un Mac, j'aime particulièrement utiliser ⌥⌫ pour supprimer un mot à la fois.
 J'utilise fréquemment cette combinaison lorsque je dois supprimer un nombre moyen de mots (disons 2 à 5) pour recommencer une phrase lorsque j'écris. Pour les suppressions plus courtes, comme un seul mot, il est généralement plus rapide d'appuyer plusieurs fois sur ⌫, car le changement de contexte pour utiliser ⌥⌫ entraîne une certaine surcharge qui rend plus rapide la suppression directe. Ne vous inquiétez pas trop pour ces micro-optimisations ; avec l'expérience, vous trouverez naturellement vos propres techniques préférées. 
                <p class="lamda">Associée à la suppression, l'une des commandes les plus importantes de l'histoire de l'univers est la commande « Undo » (Annuler). Dans les éditeurs modernes, la commande « Undo » utilise le raccourci clavier natif, généralement ⌘Z ou ⌃Z. Son inverse, « Redo » (Refaire), est généralement ⇧⌘Z ou ⌘Y. Vous pouvez également utiliser le menu (généralement « Edit », comme le montre la figure 2.28), mais, comme pour « Cut/Copy/Paste » (Couper/Copier/Coller, section 2.5), « Undo » est tellement utile que je vous recommande de mémoriser le raccourci dès que possible. Sans Undo, des opérations telles que la suppression seraient irréversibles et donc potentiellement dangereuses, mais avec Undo, il est facile de corriger les erreurs que vous commettez lors de l'édition. 
                 <p class="cycle spec"><img src="/ressources/e38.png" alt=""></p>
                 <p class="fig">Figure 2.28 : Undo et Redo dans le menu de l'éditeur.
                 <p class="lamda">Je recommande d'utiliser Couper plutôt que Supprimer lorsque vous n'êtes pas sûr à 100 % de ne plus jamais vouloir réutiliser le contenu. Même si vous pouvez généralement utiliser Annuler pour récupérer un élément important supprimé par erreur, le fait de placer le contenu dans le tampon avec Couper vous offre une redondance supplémentaire. (L'utilisation de Jumpcut (section 2.5.1) vous offre une redondance supplémentaire.)</p>
                 <p class="lamda">Enfin, la fonction « Undo » (Annuler) nous offre une astuce utile pour retrouver le curseur, une tâche courante lors de l'édition de fichiers volumineux. Le problème est que vous écrivez du texte, puis que vous devez vous déplacer (section 2.3) ou rechercher (section 2.8) un autre endroit dans le document. Dans ces cas-là, il peut être difficile de retrouver le curseur. Il existe plusieurs façons de contourner ce problème : vous pouvez utiliser les touches fléchées ou simplement commencer à taper, mais ma technique préférée consiste à utiliser la fonction « Undo » (Annuler), puis immédiatement « Redo » (Rétablir) (⌘Z/⇧⌘Z ou ⌘Z/⌘Y), ce qui vous garantit de retrouver le curseur sans apporter de modifications indésirables.
                               
<h2 id="trentesix">2.6.1 Exercices</h2>
                 <p class="exo">1-Utilisez la fonction Annuler à plusieurs reprises jusqu'à ce que toutes les modifications que vous avez apportées à README.md aient été annulées.
                 <p class="exo">2-À l'aide de n'importe quelle technique de la section 2.4, sélectionnez le mot « written » dans README.md et supprimez-le, puis annulez la modification.
                 
<p class="exo">3-Reprenez la modification de l'exercice précédent, puis annulez-la à nouveau. </p>
                 <p class="exo">4-Apportez une modification quelque part dans le fichier sonnets.txt, puis faites défiler le texte pour vous perdre. Utilisez la fonction Annuler/Refaire pour retrouver le curseur. Continuez ensuite à utiliser la fonction Annuler pour annuler toutes vos modifications. </p>

                 <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
         
        </section>
        <!-- 17-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="trentesept">2.7 Enregistrement</h2>
                 <p class="lamda">Une fois que nous avons apporté des modifications à un fichier, nous pouvons l'enregistrer à l'aide du menu ou de la touche ⌘S. Je recommande vivement d'utiliser le raccourci clavier, qui, entre autres, facilite l'enregistrement du fichier chaque fois que vous faites une pause temporaire dans votre écriture ou votre codage — une habitude précieuse à cultiver. En gros, si vous ne faites rien d'autre, vous devriez appuyer sur Enregistrer. Cette habitude contribue grandement à éviter la perte de travail (et, comme nous l'avons vu dans 643-code Git , elle est particulièrement efficace lorsqu'elle est associée au contrôle de version).</p>
                 <p class="lamda">À titre d'exemple, nous pouvons ajouter du code source à notre fichier README et enregistrer le résultat. Nous commençons par coller le code du listing 2.4, comme le montre la figure 2.29 (qui inclut une mise en évidence syntaxique très contrastée). Comme vous pouvez le voir grâce à l'indicateur encerclé dans la figure 2.29, Sublime Text (comme la plupart des éditeurs modernes) inclut un indicateur subtil qui signale que le fichier n'est pas enregistré, en l'occurrence un petit cercle ouvert. Après avoir exécuté Enregistrer (via ⌘S, par exemple), le cercle disparaît et est remplacé par un X (Figure 2.30).</p>
                 <p class="cod">
                    Listing 2.4 : Un extrait de code. <br>
                    ```ruby <br>
                    def hello <br>
                      puts « hello, world! » <br>
                    
end
                 </p>
                 <p class="cycle spec"><img src="/ressources/e39.png" alt=""></p>
                 <p class="fig">Figure 2.29 : Un fichier non enregistré.
                 <p class="cycle spec"><img src="/ressources/e40.png" alt=""></p>
                 
<p class="fig">Figure 2.30 : Le fichier de la figure 2.29 après enregistrement. 
                 <h2 id="trentehuit">2.7.1 Exercices
                 <p class="exo">1-Annulez le collage du code source pour restaurer le fichier dans son état d'origine.
                 
<p class="exo">2-Découvrez comment « Enregistrer sous », puis enregistrez README.md sous le nom code_example.md, collez l'exemple de code et enregistrez le fichier. </p>
                 <p class="exo">3-L'invite Bash par défaut de mon terminal en ligne de commande apparaît comme dans le listing 2.5, mais je préfère l'invite plus compacte présentée dans le listing 2.6. Dans 643-code Command Line , j'ai promis de montrer comment personnaliser l'invite dans 643-code Text Editor . Je tiens cette promesse en modifiant le fichier .bashrc pour y inclure les lignes indiquées dans le listing 2.7. Sourcez le profil Bash comme dans le listing 1.5 et vérifiez que l'invite de votre système correspond à celle indiquée dans le listing 2.6. (Pour savoir comment personnaliser l'invite à l'aide du shell Z, le shell par défaut actuel sur macOS, consultez l'article du blog 643-code « Utilisation du shell Z sur Mac avec les tutoriels 643-code »).
                </p>
                 
<p class="cod">
                    Listing 2.5 : L'invite de commande par défaut sur mon système. <br>
MacBook-Air:~ mhartl$
</p>
<p class="cod">
Listing 2.6 : Mon invite de commande préférée, plus compacte. <br>
[~]$
</p>
                 
<p class="cod">
                    Liste 2.7 : Lignes Bash nécessaires pour personnaliser l'invite comme indiqué dans la liste 2.6. <br>
~/.bashrc <br>
alias lr=“ls -hartl” <br>
# Personnaliser l'invite pour n'afficher que le répertoire de travail. <br>
PS1=“[\W]\$ ”
</p>










                 <button class="btn">Commencer: le chapitre</button>


                
             </div>
             
         </div>
 
        
        </section>
        <!-- 18-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 
<h2 id="trenteneuf">2.8 Rechercher et remplacer</h2>
                 <p class="lamda">L'une des fonctionnalités les plus puissantes de tout bon éditeur de texte est la possibilité de rechercher et, éventuellement, de remplacer du texte. Dans cette section, nous allons apprendre à rechercher et remplacer dans un seul fichier ; dans la section 3.4, nous aborderons la méthode plus puissante (et beaucoup plus dangereuse) qui consiste à rechercher et remplacer dans plusieurs fichiers. </p>
                 <p class="lamda">Pour effectuer une recherche dans un fichier, vous pouvez utiliser le menu Rechercher, illustré à la figure 2.31, qui indique également que ⌘F est le raccourci clavier correspondant. L'un ou l'autre fait apparaître une fenêtre modale dans laquelle vous pouvez saisir la chaîne que vous recherchez (Figure 2.32).</p>
                 <p class="cycle spec"><img src="/ressources/e41.png" alt=""></p>
                 <p class="fig">Figure 2.31 : Recherche à l'aide du menu. </p>
                 <p class="cycle spec"><img src="/ressources/e42.png" alt=""></p>
                 <p class="fig">Figure 2.32 : Fenêtre modale pour la recherche et le remplacement.
                 <p class="lamda">Supposons, par exemple, que nous recherchions la chaîne « sample ». Comme le montre la figure 2.33, « Sample » et « sample » sont tous deux mis en surbrillance. La raison pour laquelle notre recherche trouve les deux est que nous avons choisi de rechercher sans distinction de casse (ce qui est généralement le cas par défaut).</p>
                 <p class="cycle spec"><img src="/ressources/e43.png" alt=""></p>
                 <p class="lamda">La figure 2.34 montre comment utiliser la fenêtre modale pour rechercher « sample » et le remplacer par « example ». Afin d'éviter de remplacer « Sample », nous cliquons d'abord sur Rechercher pour sélectionner la correspondance suivante, puis sur Remplacer pour remplacer la deuxième correspondance (figure 2.35). (Dans ce cas, il serait également possible de passer à une recherche sensible à la casse ; l'apprentissage de cette technique est laissé à l'appréciation de l'utilisateur (section 2.8.1).)</p>
                 <p class="fig">Figure 2.33 : Recherche de la chaîne « sample ». </p>
                 <p class="cycle spec"><img src="/ressources/e44.png" alt=""></p>
                 <p class="fig">Figure 2.34 : Recherche et remplacement.
                 <p class="cycle spec"><img src="/ressources/e45.png" alt=""></p>
                 
<p class="fig">Figure 2.35 : Résultat du remplacement de « sample » par « example ».</p>
                 <p class="lamda">Comme le montre la figure 2.31, vous pouvez également taper ⌘G pour rechercher la correspondance suivante à l'aide d'un raccourci clavier. Cette combinaison ⌘F/⌘G fonctionne également dans de nombreuses autres applications, telles que les traitements de texte et les navigateurs web. </p>
                 <p class="lamda">Enfin, notez que nous avons maintenant remplacé « a sample » par « a example ». La dernière étape consiste donc à remplacer cela par « an example » (Figure 2.36).</p>
                 
<p class="cycle spec"><img src="/ressources/e49.png" alt=""></p>
                 <p class="fig">Figure 2.36 : Faire un « an example » (un exemple) de cela. </p>
                 <h2 id="quarante">2.8.1 Exercices</h2>
                 <p class="exo">1-Dans la section 2.3.1, nous avons trouvé le Sonnet 18 en allant directement à la ligne 293, mais bien sûr, je n'ai pas cherché le fichier ligne par ligne pour rédiger l'exercice. J'ai plutôt cherché « shall I compare thee ». Utilisez votre éditeur de texte pour rechercher cette chaîne dans sonnets.txt. À quelle ligne apparaît « rosy lips and cheeks » ?
                </p>
                 <p class="exo">2-L'exemple de cette section montre l'un des pièges de la recherche et du remplacement mécaniques de texte : nous nous sommes retrouvés avec le résultat grammaticalement incorrect « a example » au lieu de « an example ». Plutôt que de corriger cela à la main, utilisez la fonction « rechercher et remplacer » pour remplacer « a example » par « an example » dans votre document. (Bien que dans le cas présent, il n'y ait qu'une seule occurrence, cette technique plus générale s'applique à des documents beaucoup plus longs que notre exemple simplifié.)</p>
                 <p class="exo">3-Quel est le raccourci clavier dans votre éditeur pour rechercher la correspondance précédente ?</p>
                 <p class="exo">4-Quel est le raccourci clavier pour remplacer dans le tampon (fichier) actuel ? En quoi diffère-t-il du raccourci clavier permettant simplement de rechercher ?</p>
             
             
             
                 <button class="btn">Commencer: le chapitre</button>
             
                </div>
             
         </div>
 
         
        </section>
        <!-- 19-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="qun">2.9 Résumé</h2>
                 <p class="lamda">
                    1- Sublime Text et VSCode sont tous deux d'excellents choix pour un éditeur de texte moderne principal. <br>
                    2- Une méthode courante pour ouvrir des fichiers consiste à utiliser une commande dans la ligne de commande. <br>
                    
3-Pour les fichiers contenant des éléments tels que du texte avec de longues lignes, il est conseillé d'activer le retour à la ligne automatique. <br>
                    4-Il existe plusieurs façons de se déplacer dans les fichiers texte, notamment à l'aide de la souris et des touches fléchées (en particulier en combinaison avec la touche Commande/Contrôle). <br>
                    5-Une méthode pratique pour sélectionner du texte consiste à maintenir la touche Maj enfoncée et à déplacer le curseur. <br>
                    6-Le trio Couper/Copier/Coller est extrêmement utile. <br>
 7-La fonction Annuler peut vous sauver la mise (Figure 2.37).
                 </p>
 
                 <p class="cycle spec"><img src="/ressources/e47.jpg" alt=""></p>
                 
<p class="fig">Figure 2.37 : La fonction Annuler peut vous sauver la mise. </p>
                 <p class="lamda">Les commandes importantes de ce chapitre sont résumées dans le tableau 2.2. </p>
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    
<td class="align_left"><strong>Commande</strong></td>
                    <td class="align_left"><strong>Description</strong></td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘←</td>
                    <td class="align_left">Déplacer au début de la ligne (s'arrête sur un espace blanc)</td>
                    
</tr>
                    <tr>
                    <td class="align_left">⌘→</td>
                    <td class="align_left">Aller à la fin de la ligne</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘↑</td>
                    <td class="align_left">Aller au début du fichier</td>
                    
</tr>
                    <tr>
<td class="align_left">⌘↓</td>
<td class="align_left">Aller à la fin du fichier</td>
</tr>
<tr>
<td class="align_left">⇧-déplacer</td>
<td class="align_left">Sélectionner du texte</td>
                    
</tr>
                    <tr>
<td class="align_left">⌘D</td>
<td class="align_left">Sélectionner le mot actuel</td>
</tr>
<tr>
<td class="align_left">⌘A</td>
<td class="align_left">Tout sélectionner (document entier)</td>
                    
</tr>
                    <tr>
<td class="align_left">⌘X/⌘C/⌘V</td>
<td class="align_left">Couper/Copier/Coller</td>
</tr>
<tr>
<td class="align_left">⌘Z</td>
                    
<td class="align_left">Annuler</td>
                    </tr>
<tr>
<td class="align_left">⇧⌘Z ou ⌘Y</td>
<td class="align_left">Rétablir</td>
</tr>
<tr>
<td class="align_left">⌘S</td>
                    
<td class="align_left">Enregistrer</td>
                    </tr>
<tr>
<td class="align_left">⌘F</td>
<td class="align_left">Rechercher</td>
</tr>
<tr>
<td class="align_left">⌘G</td>
                    
<td class="align_left">Rechercher suivant</td>
                    </tr>
                    </tbody>
                    </table>
                    <p class="fig">Tableau 2.2 : Commandes importantes du chapitre 2.</p>
                    <button class="btn">Commencer : le chapitre</button>
             </div>
         </div>
                  
</section>
        <!-- 20-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 
</div>
     
                <div class="buttons">
                    <button id="play-pause">
                        <img src="/ressources/play.svg">
                    </button>
                    <button id="mute">Mute</button>
                     
<input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
              
<div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="qdeux">Édition de texte avancée</h2>
                 <p class="lamda">Après avoir abordé les fonctions de base des éditeurs de texte modernes au chapitre 2, nous allons maintenant découvrir quelques-unes des fonctionnalités avancées les plus courantes. Plus encore que dans le chapitre 2, les détails varieront en fonction de l'éditeur que vous choisirez, alors utilisez vos connaissances techniques grandissantes (encadré 1.2) pour trouver les informations nécessaires. La leçon la plus importante à retenir est que les fonctions avancées présentées dans ce chapitre sont toutes disponibles dans les éditeurs professionnels. Vous devriez donc être capable de les utiliser quel que soit l'éditeur que vous utilisez.
                 
<button class="btn">Commencer : le chapitre</button>
             </div>
</div>
</section>
<!-- 21-->
<section >
<div class="container-video">
<video src="/ressources/video.mp4" class="video"></video>
                  
<div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     
<button id="mute">Couper le son</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
              
</div>
    <div class="contenu">
    <div class="intro">
    <h3>Chapitre 3</h3>
    <h2 id="qtrois">3.1 Autocomplete et tab triggers</h2>
                <p class="lamda">Deux des fonctionnalités les plus utiles des éditeurs de texte sont l'autocomplétion et les déclencheurs de tabulation, que l'on peut considérer comme une sorte de complétion par tabulation de type ligne de commande pour les fichiers texte. (Voir 643-code Ligne de commande  pour plus de détails sur la complétion par tabulation.) Ces deux fonctionnalités nous permettent de saisir de grandes quantités de texte en quelques frappes seulement.
                 
<h2 id="qquatre">3.1.1 Saisie semi-automatique</h2>
                 <p class="lamda">La variante la plus courante de la saisie semi-automatique nous permet de taper les premières lettres d'un mot (suivies de la tabulation, selon l'éditeur), puis nous donne la possibilité de le compléter à partir d'un menu d'options, généralement en utilisant les touches fléchées et en appuyant sur la tabulation pour accepter la complétion. Un exemple de complétion automatique du mot « Markdown » dans README.md est présenté dans la figure 3.1. (Notez que la figure 3.1 restaure le contenu du fichier README d'origine, que vous pouvez reproduire en réexécutant la commande curl du listing 2.1.)</p>
                
<p class="cycle spec"><img src="/ressources/e48.png" alt=""></p>
                <p class="fig">Figure 3.1 : Complétion automatique pour « Markdown ». </p>
                <p class="lamda">Le menu de saisie semi-automatique lui-même est rempli à partir du document actuel, ce qui rend la saisie semi-automatique particulièrement utile dans les documents plus longs qui contiennent un grand nombre de complétions possibles. Par exemple, le code source de l'éditeur de texte 643  (qui est écrit à l'aide du puissant langage de balisage LATEX) utilise un grand nombre d'étiquettes pour créer des références croisées, et ces étiquettes sont souvent suffisamment longues pour qu'il soit beaucoup plus facile de les compléter automatiquement que de les taper à la main. Un exemple est la boîte 1.2 souvent citée, dont le code source ressemble au listing 3.1.
                
<p class="cod">
                    Listing 3.1 : Une référence croisée avec une étiquette que je complète généralement automatiquement. <br>
                    Encadré~\ref{aside:technical_sophistication}
                </p>
                <p class="lamda">Lorsque j'écris une chaîne telle que technical_sophistication dans le listing 3.1, j'utilise presque toujours la saisie automatique au lieu de la taper en entier.1 (Comme mentionné ci-dessous, le reste de la référence croisée est généré à l'aide d'un déclencheur de tabulation personnalisé.) Des considérations similaires se posent fréquemment lors de l'écriture de code source, où (comme nous l'apprendrons dans 643-code ruby ) nous pouvons rencontrer quelque chose comme ceci :</p>
                 
<p class="cod">ReallyLongClassName < ReallyLongBaseClassName</p>
                 <p class="lamda">Dans de tels cas, plutôt que de taper les noms longs à la main, il est généralement plus facile de taper Rea, puis de sélectionner la complétion automatique appropriée.


                  
<h2 id="qcinq">3.1.2 Déclencheurs de tabulation</h2>
                  <p class="lamda">Les déclencheurs de tabulation sont similaires à l'autocomplétion dans la mesure où ils nous permettent de taper quelques lettres puis d'appuyer sur la touche de tabulation pour obtenir un résultat magique, mais dans ce cas, beaucoup d'entre eux sont prédéfinis dans l'éditeur, les déclencheurs exacts étant généralement basés sur le type particulier de document que nous éditons. Par exemple, dans Markdown et d'autres fichiers de balisage (HTML, LATEX, etc.), taper lorem⇥ ou lo⇥ produit ce qu'on appelle du texte lorem ipsum, un fragment latin légèrement corrompu tiré d'un livre de Cicéron qui est souvent utilisé comme texte factice en programmation et en conception. Nous avons déjà vu brièvement le lorem ipsum dans le listing 2.2 ; un deuxième exemple apparaît dans la figure 3.2, qui montre le résultat de la saisie de lo dans Sublime Text. Un gros plan apparaît dans la figure 3.3. Après avoir appuyé sur ⇥ pour invoquer le déclencheur de tabulation, le texte lorem ipsum complet apparaît comme dans la figure 3.4.
                  
<p class="cycle spec"><img src="/ressources/e49.png" alt=""></p>
                <p class="fig">Figure 3.2 : La saisie de « lo » dans Sublime Text prépare l'activation d'un déclencheur de tabulation.
                
<p class="cycle spec"><img src="/ressources/e50.png" alt=""></p>
                <p class="fig">Figure 3.3 : Vue plus détaillée du déclencheur de la figure 3.2.
                
<p class="cycle spec"><img src="/ressources/e51.png" alt=""></p>
                <p class="fig">Figure 3.4 : Résultat du déclencheur de tabulation de la figure 3.2.
                <p class="lamda">Les déclencheurs de tabulation sont particulièrement utiles lors de l'édition de types de fichiers à syntaxe complexe, tels que les fichiers HTML et les codes sources. Par exemple, lors de l'écriture de HTML, de nombreux éditeurs prennent en charge la création d'un squelette HTML à l'aide du déclencheur html⇥, associé à des balises HTML (abordées dans 643-code HTML ) en utilisant le nom de la balise avec une tabulation, comme h1⇥ pour une balise h1 ou une balise d'en-tête de niveau supérieur. Dans Sublime Text, nous pouvons faire quelque chose comme ceci :</p>
                <p class="cod">$ subl index.html</p>
                
<p class="lamda">Le résultat de l'application des différents déclencheurs de tabulation peut alors ressembler à la figure 3.5. 
                <p class="cycle spec"><img src="/ressources/e52.png" alt=""></p>
                <p class="fig">Figure 3.5 : Résultat de l'application des déclencheurs de tabulation HTML.
                
<p class="lamda">Comme HTML, ou HyperText Markup Language, est le langage du World Wide Web, la navigation vers le fichier dans un navigateur affiche alors une page web simple mais réelle (Figure 3.6).</p>
                <p class="cycle spec"><img src="/ressources/e53.png" alt=""></p>
                
<p class="fig">Figure 3.6 : Résultat de l'application de déclencheurs de tabulation à une page HTML. </p>
                <p class="lamda">De même, lorsque vous écrivez du code ruby, taper def⇥ dans Sublime Text crée une instruction ruby define pour créer une fonction, qui ressemble à ceci :. </p>
                <p class="cod">
                    def nom_de_la_méthode <br> <br>
                    
end
                </p>
                <p class="lamda">Après avoir tapé le nom de la fonction (qui remplace le texte de remplacement method_name), nous pouvons appuyer à nouveau sur ⇥ pour placer le curseur au bon endroit et commencer à écrire la partie principale de la fonction. Ce type d'auto-expansion du contenu peut considérablement accélérer la production de code, tout en réduisant la charge cognitive de la programmation.
 Nous verrons un exemple concret de cette technique dans la section 3.2. 
Enfin, il est possible de définir vos propres déclencheurs de tabulation. Je fais moi-même un usage intensif des déclencheurs de tabulation dans mon travail d'édition ; par exemple, pour créer le texte du listing 3.1, au lieu de taper
                
<p class="cod">Box~\ref{aside:technical_sophistication}</p>
                <p class="lamda">à la main, j'ai utilisé le déclencheur de tabulation personnalisé bref (pour « box reference ») pour générer
               
                <p class="cod">Box~\ref{aside:}</p>
                <p class="lamda">puis j'ai rempli l'étiquette technical_sophistication à l'aide de la fonction d'autocomplétion (section 3.1.1). La définition de déclencheurs de tabulation personnalisés dépend fortement de l'éditeur et dépasse le cadre de ce tutoriel, mais vous trouverez quelques conseils pour vous aider à les découvrir par vous-même dans la section 3.5.
               
<h2 id="qsix">3.1.3 Exercices</h2>
               <p class="exo">1-Ajoutez du texte lorem ipsum à README.md à l'aide d'un déclencheur de tabulation.
               <p class="exo">2-Ajoutez une autre occurrence du mot « consectetur » à l'aide de la fonction d'autocomplétion.
               
<p class="exo">3-Écrivez la phrase « Comme l'a dit Cicéron, « quis nostrud exercitation ullamco laboris » » en utilisant autant de fois que vous le souhaitez la fonction de saisie automatique.
</p>
<button class="btn">Commencer : le chapitre</button>
</div>
</div>
 
        
        </section>
        <!-- 22-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 
<h2 id="qsept">Écrire du code source</h2>
                 <p class="lamda">Comme indiqué dans la section 3.1.2, en plus d'être efficaces pour éditer des balises telles que HTML et Markdown, les éditeurs de texte excellent dans l'écriture de programmes informatiques. Tout bon éditeur de texte pour programmeurs prend en charge de nombreuses fonctions spécialisées pour l'écriture de code ; cette section couvre quelques-unes des plus utiles.
 Même si vous ne savez pas (encore !) programmer, il est toujours utile de connaître certaines des fonctionnalités des éditeurs de texte qui facilitent l'écriture de code. 
Le listing 3.2 présente un exemple de code informatique, qui montre une variante du programme « hello, world » écrit en langage ruby. (Vous n'êtes pas censé comprendre ce programme.)
                 
<p class="cod">
                    Listing 3.2 : Une variante de « hello, world » en ruby. <br>
                    1# Affiche un message de bienvenue. <br>
                    2def hello(location) <br>
                    3  puts « hello, #{location}! » <br>
                    4end <br>
                    5 <br>
                    6hello(« world »)
                 </p>
                 <p class="lamda">Pour voir le contenu du listing 3.2 dans un éditeur de texte, nous pouvons lancer Sublime Text comme suit :</p>
                 
<p class="cod">subl hello.rb</p>
                 <p class="lamda">Après avoir collé le contenu du listing 3.2, nous obtenons le résultat présenté dans la figure 3.7. (Pour obtenir des points supplémentaires, tapez le listing 3.2 à la main en utilisant le déclencheur de tabulation def décrit dans la section 3.1.)</p>
                               
<p class="cycle spec"><img src="/ressources/e54.png" alt=""></p>
                  <p class="fig">Figure 3.7 : Un programme ruby dans Sublime Text.</p>
<h2 id="qhuit">3.2.1 Mise en évidence de la syntaxe</h2>
                  <p class="lamda">Comme nous l'avons vu dans la section 2.2.1 avec README.md, Sublime Text utilise l'extension du nom de fichier pour déterminer la coloration syntaxique appropriée. Dans ce cas, la coloration (plutôt subtile) était destinée à Markdown ; dans le cas présent, Sublime Text déduit de l'extension .rb que le fichier contient du code ruby et le met en évidence en conséquence. Comme précédemment, il est essentiel de comprendre que la coloration n'est pas inhérente au texte, qui reste brut. La coloration syntaxique est purement destinée à faciliter la lecture du code. </p>
                  <p class="lamda">En plus de faciliter l'analyse visuelle du code source (par exemple, en distinguant les mots-clés, les chaînes de caractères, les constantes, etc.), la coloration syntaxique peut également être utile pour détecter les bogues. Par exemple, à un moment donné, lors de la modification du code 643-code Command Line , j'ai accidentellement supprimé une citation de fermeture LATEX (qui se compose de deux guillemets simples “”), avec le résultat montré dans la figure 3.8. Cela a changé la couleur du texte principal, qui est passé du blanc par défaut à la couleur utilisée pour les chaînes entre guillemets (vert), ce qui a permis de voir d'un seul coup d'œil que quelque chose n'allait pas. Une fois l'erreur corrigée, la coloration est revenue au blanc attendu, comme le montre la figure 3.9. 
<p class="cycle spec"><img src="/ressources/e55.png" alt=""></p>
<p class="fig">Figure 3.8 : Erreur dans le code source LATEX détectée par la coloration syntaxique.
                  
<p class="cycle spec"><img src="/ressources/e56.png" alt=""></p>
                  <p class="fig">Figure 3.9 : Erreur corrigée, surlignage syntaxique comme prévu. </p>
                  <h2 id="qneuf">3.2.2 Commenter</h2>
                  <p class="lamda">L'une des fonctions les plus utiles d'un éditeur de texte est la possibilité de « commenter » des blocs de code, une technique souvent utilisée pour empêcher temporairement l'exécution de certaines lignes sans avoir à les supprimer entièrement (ce qui est souvent particulièrement utile lors du débogage). La plupart des langages de programmation et de balisage prennent en charge les lignes de commentaire qui existent pour faciliter la lecture du code par les humains, mais qui sont ignorées par le langage de programmation lui-même.2 Un exemple de commentaire ruby apparaît dans la première ligne du listing 3.2 :</p>
<p class="cod"># Affiche un message de bienvenue.</p>
<p class="lamda">Ici, le symbole dièse # est utilisé par ruby pour indiquer une ligne de commentaire. </p>
                  <p class="lamda">Supposons que nous voulions commenter les trois lignes suivantes (lignes 2 à 4), pour changer</p>
                  <p class="cod"># Affiche un message d'accueil. <br>
                    def hello(location) <br>
                      puts « hello, #{location}! » <br>
                    end <br> <br>
                                        
hello(« world »)</p>
                    <p class="lamda">en
                    <p class="cod"># Affiche un message de bienvenue. <br>
                        # def hello(location) <br>
                        #  puts « hello, #{location}! » <br>
                        # end <br>
hello(« world »)</p>
                        <p class="lamda">Il est bien sûr possible de le faire à la main, simplement en insérant un # au début de chaque ligne. Cependant, cela n'est pas pratique et devient de plus en plus fastidieux à mesure que la longueur du texte commenté augmente. Au lieu de cela, nous pouvons sélectionner le texte souhaité (section 2.4) et utiliser un élément de menu ou un raccourci clavier pour commenter la sélection. Dans Sublime Text, nous pouvons commenter les lignes 2 et 3 en les sélectionnant (Figure 3.10) et en appuyant sur ⌘/, comme le montre la Figure 3.11. (Notez sur la figure 3.11 que l'indicateur de sauvegarde subtil montré dans la figure 2.30 a été rempli ; cela s'explique par le fait que j'ai l'habitude d'appuyer sur ⌘S après avoir apporté des modifications, comme recommandé dans la section 2.7.)</p>
<p class="cycle spec"><img src="/ressources/e57.png" alt=""></p>
                        
<p class="fig">Figure 3.10 : Préparation pour commenter certaines lignes. 
                        <p class="cycle spec"><img src="/ressources/e58.png" alt=""></p>
                        <p class="fig">Figure 3.11 : Lignes commentées.
                         <p class="lamda">La fonctionnalité de mise en commentaire permet généralement de basculer d'un état à l'autre. Ainsi, en appuyant une deuxième fois sur ⌘/, nous pouvons restaurer le fichier à son état précédent (Figure 3.10). Cela est utile pour restaurer du texte mis en commentaire après, par exemple, avoir effectué un débogage. </p>
                        <h2 id="cun">3.2.3 Indentation et désindentation</h2>
                        <p class="lamda">Un autre élément du formatage du code facilité par les éditeurs de texte est l'indentation, qui consiste à ajouter des espaces au début de certaines lignes. Il était courant d'utiliser des tabulations pour l'indentation, mais malheureusement, le nombre d'espaces affichés pour une tabulation dépend du système, ce qui conduit à des résultats imprévisibles : certaines personnes peuvent voir quatre « espaces » par tabulation, d'autres huit, et d'autres seulement deux.
                        <p class="lamda">Ces dernières années, de nombreux programmeurs sont passés aux tabulations émulées, où la pression de la touche de tabulation insère un nombre standard d'espaces ordinaires (généralement deux ou quatre). Les tabulations réelles ont toutefois encore quelques partisans, et le débat entre tabulations et espaces reste un sujet brûlant (encadré 1.5). (Heureusement, tout le monde s'accorde sur un point : mélanger tabulations et espaces est une mauvaise idée.)</p>
                        <p class="lamda">Pour comprendre comment cela fonctionne, nous pouvons examiner un exemple de code ruby, qui utilise généralement deux espaces pour l'indentation :</p>
                        
<p class="cod">def hello(location) <br>
                            puts « hello, #{location}! » <br>
                          end</p>
                        <p class="lamda">Pour obtenir ce résultat, il suffit généralement d'appuyer sur la touche Entrée après « (location) », puis sur la touche Tabulation, bien que deux pressions sur la barre d'espace fonctionnent également. En supposant que l'éditeur ait été configuré pour utiliser deux espaces pour émuler les tabulations, nous obtiendrions le résultat ci-dessus. Dans la plupart des langages, cela équivaudrait à ce qui suit :</p>
                        <p class="cod">
                            def hello(location) <br>
                            puts « hello, #{location}! » <br>
                            
end
                        </p>
<p class="lamda">Ce deuxième exemple est toutefois plus difficile à lire, et il est important d'indenter correctement pour faciliter la lecture du code par les humains, même si le langage de programmation s'en moque.
                        <p class="lamda">Les éditeurs de texte aident à maintenir une indentation correcte de deux manières principales. Tout d'abord, les nouvelles lignes sont généralement insérées au même niveau d'indentation que la ligne précédente, ce que vous pouvez vérifier en allant à la fin de la ligne 3 du listing 3.2 et en tapant les deux lignes suivantes :</p>
                        <p class="cod">puts « Uh, oh. » <br>
                            puts « Goodbye, #{location}! »</p>
                            
<p class="lamda">Le résultat apparaît dans la figure 3.12.</p>
                            <p class="cycle spec"><img src="/ressources/e59.png" alt=""></p>
                            <p class="fig">Figure 3.12 : Ajout de deux lignes indentées.</p>
                            <p class="lamda">La deuxième façon principale dont les éditeurs de texte aident à maintenir un bon formatage du code est de prendre en charge l'indentation de blocs, qui fonctionne de la même manière que le commentaire de blocs de code. Supposons, par exemple, que (contrairement aux pratiques ruby conventionnelles) nous ayons décidé d'indenter les lignes 3 à 5 de la figure 3.12 de six espaces supplémentaires, pour un total de huit espaces. Comme pour les commentaires, la première étape consiste à sélectionner le texte que nous voulons indenter (Figure 3.13). Nous pouvons ensuite appuyer sur la touche de tabulation ⇥ pour indenter un « tabulation souple » (qui correspond généralement à deux espaces pour ruby) à la fois. (Si, pour une raison quelconque, l'indentation par défaut de votre éditeur ne correspond pas à la convention du langage que vous utilisez, faites appel à vos connaissances techniques (encadré 1.2) pour trouver comment la modifier.) Le résultat de l'application de trois tabulations successives est illustré dans la figure 3.14.
                            
<p class="cycle spec"><img src="/ressources/e60.png" alt=""></p>
                            <p class="fig">Figure 3.13 : Préparation à l'indentation de certaines lignes.
                            <p class="cycle spec"><img src="/ressources/e61.png" alt=""></p>
                            
<p class="fig">Figure 3.14 : Un bloc de code ruby indenté plus que d'habitude. </p>
                            <p class="lamda">Comme chaque tabulation supplémentaire ne fait qu'indenter davantage le bloc, nous ne pouvons pas utiliser la même commande pour annuler l'indentation comme nous l'avons fait pour commenter le code. Nous devons plutôt utiliser une commande distincte, « dedent », qui dans Sublime Text est ⇧⇥. En appliquant cette commande trois fois de suite, nous revenons à l'état initial, comme le montre la figure 3.15. (À noter que de nombreux éditeurs, y compris Sublime Text, prennent en charge les raccourcis clavier alternatifs ⌘] et ⌘[ pour l'indentation et la désindentation, respectivement.)</p>
                                                        
<p class="cycle spec"><img src="/ressources/e62.png" alt=""></p>
                            <p class="fig">Figure 3.15 : Dé-indentation du bloc de code de la figure 3.14.
                            <h2 id="cdeux">3.2.4 Aller à un numéro de ligne
                            <p class="lamda">Il est souvent important de pouvoir aller à un numéro de ligne particulier, par exemple lors du débogage d'un programme qui comporte une erreur à la ligne 187 (par exemple). Nous avons vu cette fonctionnalité dans la section 1.6, où nous avons appris que la commande Vim <n>G nous amène à la ligne <n>. Dans de nombreux autres éditeurs, le raccourci correspondant est ⌃G. Cela ouvre une boîte modale dans laquelle vous pouvez saisir le numéro de ligne, comme le montre la figure 3.16. (Soit dit en passant, la syntaxe :<numéro> illustrée dans la figure 3.16, qui est destinée à Sublime Text, fonctionne également dans Vim.)</p>
                                
<p class="cycle spec"><img src="/ressources/e63.png" alt=""></p>
                                <p class="fig">Figure 3.16 : Boîte modale permettant d'accéder à un numéro de ligne particulier.


                                <h2 id="ctrois">3.2.5 80 colonnes</h2>
                                <p class="lamda">Enfin, de nombreux éditeurs de texte aident les programmeurs à respecter une limite de 80 caractères par ligne, généralement appelée « limite de 80 colonnes ». Tous les programmeurs ne respectent pas cette limite, mais le fait de limiter notre code à 80 colonnes facilite sa lecture et son affichage, par exemple dans les terminaux à largeur fixe, les articles de blog ou les tutoriels comme celui-ci.5 Une limite de 80 colonnes impose également une bonne discipline de codage, car le dépassement de 80 colonnes est souvent le signe qu'il serait judicieux d'introduire une nouvelle variable ou un nouveau nom de fonction. 6 Comme il est difficile de voir d'un seul coup d'œil si une ligne particulière dépasse 80 caractères, de nombreux éditeurs (Sublime Text) incluent une option permettant d'afficher une ligne verticale subtile indiquant où se trouve la limite, comme le montre la figure 3.17.7 Si l'indicateur de limite de 80 colonnes n'est pas affiché par défaut dans votre éditeur, faites appel à vos compétences techniques pour trouver comment l'activer. (Elle est souvent associée à un paramètre appelé « word wrap column » (colonne de retour à la ligne).)</p>
                                    <p class="cycle spec"><img src="/ressources/e64.png" alt=""></p>
                                    <p class="fig">Figure 3.17 : Flèches peu subtiles pointant vers l'indicateur subtil de 80 colonnes dans Sublime Text.
                                                            
<h2 id="cquatre">3.2.6 Exercices</h2>
                                 <p class="exo">1-Créez le fichier foo.rb, puis définissez la classe FooBar (listing 3.3) à l'aide d'un déclencheur de tabulation. Indice : il y a de fortes chances que le déclencheur soit quelque chose comme cla⇥.
                                 <p class="exo">2-En vous référant au listing 3.4, ajoutez la définition de bazquux à l'aide du déclencheur def⇥, puis ajoutez la dernière ligne indiquée en utilisant la saisie automatique pour taper FooBar et bazquux. (Tapez le .new. interstitiel à la main.)</p>
                                 
<p class="exo">3-À l'aide des déclencheurs de tabulation et de la saisie automatique, créez un fichier appelé greeter.rb avec le contenu indiqué dans le listing 3.5.</p>
                                 <p class="exo">4-En copiant-collant le texte de la définition hello et en indentant le bloc, transformez le listing 3.5 en listing 3.6.</p>
                                 
<p class="cod">
                                    Listing 3.3 : Création d'une classe à l'aide d'un déclencheur de tabulation. <br>
                                    ~/foo.rb <br>
                                    class FooBar <br> <br>
end
</p>
                                 <p class="cod">
                                    Listing 3.4 : Utilisation de la fonction d'autocomplétion pour créer un nom de classe. <br>
                                    ~/foo.rb <br>
                                    class FooBar <br>
                                      def bazquux <br>
                                        puts « Baz quux! » <br>
                                      end <br>
                                    end <br><br>
                                    FooBar.new.bazquux
                                 
</p>
                                 <p class="cod">
                                    Listing 3.5 : Une classe proto-Greeter en ruby. <br>
                                    ~/greeter.rb <br>
                                    class Greeter <br>
                                    end <br> <br>
                                    def hello(location) <br>
                                      puts « hello, #{location}! » <br>
end <br> <br>
Greeter.new.hello(« world »)
</p>
<p class="cod">
Listing 3.6 : Une classe Greeter complète en ruby. <br>
class Greeter <br>
def hello(location) <br>
                                        
puts « hello, #{location}! » <br>
end <br>
end <br> <br>
Greeter.new.hello(« world »)
</p>
<button class="btn">Commencer: le chapitre</button>
</div>
</div>
 
         
        </section>
        <!-- 23-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         
<div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 
<h2 id="ccinq">3.3 Écrire un script exécutable</h2>
                 <p class="lamda">En guise d'application pratique du contenu de la section 3.2, nous allons dans cette section écrire quelque chose d'utile : un script shell conçu pour tuer un programme de la manière la plus sûre possible. (Un script est un programme généralement utilisé pour automatiser des tâches courantes, mais la définition détaillée n'est pas importante à ce stade.) En cours de route, nous aborderons les étapes nécessaires pour ajouter ce script à notre shell en ligne de commande. </p>
                 <p class="lamda">Comme indiqué dans 643-code Ligne de commande , les tâches utilisateur et système Unix s'exécutent dans un conteneur bien défini appelé processus. Il arrive parfois que l'un de ces processus se bloque ou se comporte de manière anormale. Dans ce cas, nous pouvons être amenés à le terminer à l'aide de la commande kill, qui envoie un code de terminaison pour tuer le processus avec un identifiant donné :</p>
                 <p class="cod">
$ kill -15 12241
</p>
                 <p class="lamda"> (Pour plus d'informations sur la manière de trouver cet identifiant sur votre système, consultez la section 643-code Command Line .) Ici, nous avons utilisé le code de terminaison 15, qui tente de tuer le processus aussi doucement que possible (c'est-à-dire qu'il donne au processus la possibilité de nettoyer tous les fichiers temporaires, de terminer toutes les opérations nécessaires, etc. Cependant, le code de terminaison 15 n'est parfois pas suffisant et nous devons augmenter le niveau d'urgence jusqu'à ce que le processus soit bel et bien terminé. Il s'avère qu'une bonne séquence de codes est 15, 2, 1 et 9. Notre tâche consiste à écrire une commande pour mettre en œuvre cette séquence, que nous appellerons ekill (pour « escalating kill », ou « escalade de la suppression »), afin de pouvoir supprimer un processus comme indiqué dans le listing 3.7. 
                 <p class="lamda"></p>
                 <p class="cod">
                    Listing 3.7 : Exemple d'utilisation de ekill (à définir). <br>
                    $ ekill 12241
</p>
 <p class="lamda">Comme pour l'exemple ruby de la section 3.2, ne vous souciez pas des détails du code ; concentrez-vous plutôt sur les mécanismes de l'édition de texte. </p>
                 <p class="lamda">Afin de préparer l'ajout d'ekill à notre système, nous allons d'abord créer un nouveau répertoire dans notre répertoire personnel appelé bin (pour « binaire ») :</p>
                 <p class="cod">
$ mkdir ~/bin
</p>
                 
<p class="lamda">(Il est possible que ce répertoire existe déjà sur votre système, auquel cas vous recevrez un message d'avertissement sans conséquence.) Nous passerons ensuite au répertoire bin et ouvrirons un nouveau fichier appelé ekill :</p>
                 <p class="lamda"></p>
                 <p class="cod">
$ cd ~/bin <br>
                    
$ subl ekill
                 </p>
<p class="lamda">Le script ekill lui-même commence par une ligne « shebang » (prononcé « shuh-BANG », de « shell » et « bang », ce dernier étant la prononciation courante du point d'exclamation !) :</p>
<p class="lamda"></p>
                 
<p class="cod">
                    #!/bin/bash
                 </p>
                 <p class="lamda">Cette ligne indique à notre système d'utiliser le programme shell situé dans /bin/bash pour exécuter le script. Le programme bash correspond au shell Bourne-again (Bash) mentionné dans la section 1.3, et dans ce contexte, un script shell est souvent appelé script Bash.8 Malgré les apparences, ici, le symbole dièse # n'est pas un caractère de commentaire, ce qui peut prêter à confusion car (comme en ruby) # est le caractère habituellement utilisé pour une ligne de commentaire Bash. En effet, la version initiale de notre script comprend plusieurs lignes de commentaire, comme le montre le listing 3.8. 
                 <p class="lamda"></p>
                 <p class="cod">
                    Listing 3.8 : Un script kill personnalisé à escalade. <br>
                    ~/bin/ekill <br>
1#!/bin/bash <br>
2 <br>
3# Tuer un processus de la manière la plus sûre possible. <br>
4# Tente de tuer un processus en utilisant une série de signaux dont l'urgence augmente progressivement. <br>
5# Utilisation : ekill <pid><br>
6
                    
7# Attribuer l'identifiant du processus au premier argument. <br>
                    8pid=$1 <br>
9kill -15 $pid || kill -2 $pid || kill -1 $pid || kill -9 $pid <br>
</p>
                 <p class="lamda">À l'exception du shebang à la ligne 1, toutes les autres utilisations de # introduisent des commentaires. Ensuite, la ligne 8 attribue l'identifiant de processus pid à $1, qui dans un script shell est le premier argument de la commande, par exemple 12241 dans le listing 3.7. La ligne 9 utilise ensuite l'opérateur « ou » || pour exécuter la commande kill en utilisant le code 15 ou 2 ou 1 ou 9, s'arrêtant à la première exécution réussie de kill. (Encore une fois, ne vous inquiétez pas si cela vous semble confus ; j'ajoute cette explication par souci d'exhaustivité, mais à ce stade, il n'est pas nécessaire d'en comprendre les détails.)</p>
                 <p class="lamda">Après avoir saisi le contenu du listing 3.8 dans le fichier script, vous remarquerez peut-être que le résultat ne comporte pas de mise en évidence syntaxique, comme le montre la figure 3.18. Cela s'explique par le fait que, contrairement à README.md (section 2.2) et hello.rb (section 3.2), le nom ekill n'a pas d'extension de fichier. Bien que certaines personnes utiliseraient un nom tel que ekill.sh pour des scripts shell comme celui-ci, ce qui permettrait en fait à notre éditeur de mettre automatiquement en évidence la syntaxe, l'utilisation d'une extension explicite sur un script shell est une mauvaise pratique, car le nom du script est l'interface utilisateur du programme. En tant qu'utilisateurs du système, nous ne nous soucions pas de savoir si ekill est écrit en Bash, ruby ou C, donc l'appeler ekill.sh expose inutilement le langage d'implémentation à l'utilisateur final. En effet, si nous écrivions la première implémentation en Bash, puis décidions de la réécrire en ruby, puis en C, chaque programme (et programmeur) utilisant le script devrait changer le nom de ekill.sh à ekill.rb, puis à ekill.c, ce qui serait une complication ennuyeuse et évitable. 
                 <p class="cycle spec"><img src="/ressources/e65.png" alt=""></p>
                 
<p class="fig">Figure 3.18 : Le script ekill sans mise en évidence de la syntaxe. </p>
                 <p class="lamda">Même si nous avons choisi de ne pas utiliser d'extension de nom de fichier pour le script ekill, nous aimerions tout de même que la mise en évidence de la syntaxe fonctionne. Une solution consiste à cliquer sur « Plain Text » (Texte brut) dans le coin inférieur droit de l'éditeur (Figure 3.18) et à changer la langue de mise en évidence pour celle que nous utilisons. Cela nécessite toutefois de connaître la langue, et il serait préférable que l'éditeur puisse la déterminer automatiquement. Heureusement, c'est exactement ce que nous pouvons faire, simplement en fermant le fichier et en le rouvrant. Pour ce faire, cliquez sur le X pour fermer l'onglet ekill (ou appuyez sur ⌘W), puis rouvrez-le à partir de la ligne de commande :</p>
                 <p class="cod">$ subl ekill</p>
                 <p class="lamda">Grâce à la ligne shebang du listing 3.8, Sublime Text déduit que le fichier est un script Bash. En conséquence, le type de fichier détecté passe de « Texte brut » à « Script shell » et la coloration syntaxique est activée (Figure 3.19).</p>
                 <p class="cycle spec"><img src="/ressources/e66.png" alt=""></p>
                 
<p class="fig">Figure 3.19 : Le script ekill avec mise en évidence de la syntaxe et un nouveau type de fichier détecté.
                </p>
 
 <p class="lamda">À ce stade, nous disposons d'un script shell complet, mais la saisie de ekill <pid> dans la ligne de commande ne fonctionne toujours pas. Pour ajouter ekill à notre système, nous devons faire deux choses : <br>
1-S'assurer que le répertoire ~/bin se trouve dans le chemin d'accès du système, qui est l'ensemble des répertoires dans lesquels le programme shell recherche les scripts exécutables. <br>
2-Rendre le script lui-même exécutable. <br>
                    
3-La liste des répertoires du chemin d'accès est accessible via la variable spéciale $PATH dans la ligne de commande :
                </p>
                 <p class="cod">
                    $ echo $PATH
                 </p>
                 <p class="lamda">Si ~/bin figure dans la liste, vous pouvez ignorer cette étape, mais il n'y a aucun inconvénient à la suivre. </p>
                 <p class="lamda">Remarque : le répertoire littéral ~/bin n'apparaîtra pas dans la liste $PATH ; à la place, le tilde sera remplacé par votre répertoire personnel. Pour moi, ~/bin est identique à /Users/mhartl/bin, c'est donc ce qui apparaît dans mon PATH, mais ce sera différent pour vous. </p>
                 <p class="lamda">Pour nous assurer que ~/bin se trouve dans le chemin, nous allons modifier le fichier de profil Bash, qui est lié au fichier .bashrc que nous avons vu dans la section 1.3. Ouvrez ~/.bash_profile comme suit :</p>
                
<p class="cod">$ subl ~/.bash_profile</p>
                <p class="lamda">Ajoutez ensuite la ligne d'exportation indiquée dans le listing 3.9. Si la ligne source n'est pas déjà présente, vous devez également l'ajouter. Elle garantit que tous les alias définis dans .bashrc sont ajoutés lorsque .bash_profile est exécuté.
                 
<p class="cod">
                    Listing 3.9 : Ajout de ~/bin au chemin. <br>
                    ~/.bash_profile <br>
                    export PATH="~/bin:$PATH" <br>
                    source ~/.bashrc</p>
                 <p class="lamda">Cela utilise la commande Bash export pour ajouter ~/bin au chemin actuel. (Il convient de noter que certains systèmes utilisent la variable d'environnement $HOME à la place de ~, mais les deux sont synonymes. Si, pour une raison quelconque, ~ ne fonctionne pas pour vous, il vaut mieux essayer $HOME à la place, comme dans $HOME/bin:$PATH.)</p>
                 
<p class="lamda">Pour l'utiliser, nous devons utiliser source comme dans la section 1.4 :</p>
                 <p class="cod">$ source ~/.bash_profile</p>
                 <p class="lamda">Pour rendre le script résultant exécutable, nous devons utiliser la commande « change mode » chmod pour ajouter le « bit d'exécution » x comme suit :</p>
                 
<p class="lamda"></p>
                 <p class="cod">$ chmod +x ~/bin/ekill</p>
                 <p class="lamda">À ce stade, nous pouvons vérifier que le script ekill est prêt à être utilisé à l'aide de la commande which :</p>
                 
<p class="lamda"></p>
                 <p class="cod">$ which ekill</p>
                 <p class="lamda">(Cette commande est décrite dans 643-code Command Line .) Le résultat devrait être le chemin complet vers ekill, qui sur mon système ressemble à ceci :</p>
                 <p class="cod">$ which ekill <br>
                    
/Users/mhartl/bin/ekill</p>
                <p class="lamda">Sur certains systèmes, l'exécution de source sur .bash_profile peut ne pas suffire pour placer ekill dans le chemin d'accès. Si la commande which ekill ne renvoie aucun résultat, essayez de quitter et de redémarrer le programme shell pour recharger les paramètres.
                <p class="lamda">Comme vous pouvez le constater en tapant ekill seul dans la ligne de commande, le comportement actuel prête à confusion si nous négligeons d'inclure un identifiant de processus :</p>
                 
<p class="cod">
                    $ ekill <br>
                    message d'erreur déroutant>
                 </p>
                 <p class="lamda">Pour rendre ekill plus convivial dans ce cas, nous allons faire en sorte d'afficher un message d'utilisation à l'écran si l'utilisateur oublie d'inclure un identifiant de processus.
 Nous pouvons le faire à l'aide du code du listing 3.10, que je vous recommande de taper plutôt que de copier-coller. Lorsque vous écrivez l'instruction if, je vous recommande tout particulièrement d'essayer if⇥ pour voir si votre éditeur dispose d'un déclencheur de tabulation pour créer des instructions if Bash. 
                 <p class="cod">
                    Listing 3.10 : version améliorée du script kill escalatoire. <br>
                    
~/bin/ekill <br>
                    #!/bin/bash <br> <br>
# Tuer un processus de la manière la plus sûre possible. <br>
# Tente de tuer un processus en utilisant une série de signaux dont l'urgence augmente progressivement. <br>
# Utilisation : ekill <pid> <br>
                                        
# Si le nombre d'arguments est inférieur à 1, quitter avec une déclaration d'utilisation. <br>
                    if [[ $# -lt 1 ]]; then <br>
                      echo « utilisation : ekill <pid> » <br>
                      exit 1 <br>
                    fi <br>
                    # Attribuer l'identifiant du processus au premier argument. <br>
                    pid=$1 <br>
                    kill -15 $pid || kill -2 $pid || kill -1 $pid || kill -9 $pid
                 </p>
                 <p class="lamda">Après avoir ajouté le code du listing 3.10, l'exécution de ekill sans argument devrait produire un message utile :</p>
                 
<p class="cod">$ ekill <br>
                    utilisation : ekill <pid></p>
<p class="lamda">Il ne nous reste plus qu'à vérifier que ekill peut réellement être utilisé pour tuer un processus. Ceci est laissé comme exercice (section 3.3.1.)</p>
                  
<h2 id="csix">3.3.1 Exercices</h2>
                  <p class="exo">1-Testons la fonctionnalité de ekill en créant un processus qui se bloque et en appliquant les leçons tirées de la recherche de processus dans 643-code Command Line . Nous commencerons par ouvrir deux onglets de terminal. Dans un onglet, tapez tail pour obtenir un processus qui se bloque. Dans l'autre onglet, utilisez ps aux | grep tail pour trouver l'identifiant du processus, puis exécutez ekill <pid> (en remplaçant <pid> par l'identifiant réel). Dans l'onglet où tail est exécuté, vous devriez obtenir quelque chose comme « Terminated: 15 » (Figure 3.20).</p>
                  <p class="exo">2-Écrivez un script exécutable appelé hello qui prend un argument et affiche « Hello » suivi de l'argument. Veillez à utiliser chmod sur le script afin qu'il puisse s'exécuter correctement. Indice : utilisez la commande echo. Indice supplémentaire : les scripts Bash interpolent les variables avec le signe dollar dans les chaînes, de sorte que la variable $1 du listing 3.8 peut être utilisée dans une chaîne comme celle-ci : « Hello, $1 ».</p>
                   <p class="cycle spec"><img src="/ressources/e67.png" alt=""></p>
                   <p class="fig">Figure 3.20 : Résultat de l'utilisation de ekill pour tuer un processus tail. </p>

                   <button class="btn">Commencer : le chapitre</button>
             
</div>
        </div>
 
        
        </section>
        <!-- 24-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
             <div class="controls">
                 
<div class="barre-orange">
                     <div class="juice"></div>
                 </div>
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     
<input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 
<h2 id="csept">3.4 Modification de projets</h2>
                 <p class="lamda">Jusqu'à présent, nous avons utilisé notre éditeur de texte pour modifier des fichiers individuels, mais il peut également être utilisé pour modifier des projets entiers en une seule fois. À titre d'exemple, nous allons télécharger l'application type de la 3e édition du tutoriel ruby. Nous n'exécuterons pas cette application, mais elle nous fournira un projet de grande envergure sur lequel travailler. Comme dans les sections 1.6 et 2.2, nous utiliserons la commande curl pour télécharger le fichier sur notre disque local :</p>
                 <p class="cod">
$ cd <br>
                    
$ curl -OL https://source.railstutorial.org/sample_app.zip
                 </p>
                 <p class="lamda">Comme l'indique l'extension .zip du nom de fichier, il s'agit d'un fichier ZIP. Nous allons donc le décompresser (à l'aide de la commande unzip), puis accéder au répertoire de l'application exemple à l'aide de la commande cd :</p>
                 
<p class="cod">
                    $ unzip sample_app.zip <br>
                    création : sample_app_3rd_edition-master/ <br>
                    . <br>
                    . <br>
                    . <br>
                 $ cd sample_app_3rd_edition-master/
                 </p>
                 <p class="lamda">Pour ouvrir un projet, il faut utiliser un éditeur de texte afin d'ouvrir l'intégralité du répertoire. Rappelez-vous (par exemple, en parcourant les répertoires dans 643-code Command Line ) que . (« point ») correspond au répertoire actuel, ce qui signifie que nous pouvons l'ouvrir à l'aide de « subl dot » :</p>
                 
<p class="cod">$ subl .</p>
                 <p class="lamda">La fenêtre de l'éditeur de texte qui s'affiche comprend la structure du répertoire de notre projet, appelée « arborescence », comme le montre la figure 3.21. Nous pouvons basculer son affichage à l'aide du menu Affichage ou d'un raccourci clavier (figure 3.22).
                 
</p>
                 <p class="cycle spec"><img src="/ressources/e68.png" alt=""></p>
                 <p class="fig">Figure 3.21 : L'application exemple du tutoriel Rails dans Sublime Text.
                 
<p class="cycle spec"><img src="/ressources/e69.png" alt=""></p>
                 <p class="fig">Figure 3.22 : Activation/désactivation de l'arborescence.
                 
<h2 id="chuit">3.4.1 Ouverture floue</h2>
                 <p class="lamda">Il est possible d'ouvrir un fichier en double-cliquant dessus dans l'arborescence, mais dans un projet comportant de nombreux fichiers, cela s'avère souvent fastidieux, en particulier lorsque le fichier est enfoui dans plusieurs sous-répertoires. Une alternative pratique est l'ouverture floue, qui permet d'ouvrir des fichiers en appuyant (dans Sublime Text) sur ⌘P, puis en tapant quelques lettres du nom du fichier souhaité. Par exemple, nous pouvons ouvrir un fichier appelé users_controller_test.rb en tapant, par exemple, « userscon », puis en sélectionnant le fichier dans le menu déroulant, comme illustré à la figure 3.23. Les lettres ne doivent pas nécessairement être contiguës dans le nom du fichier. Ainsi, taper « uctt » (pour users controller test) fonctionnera également, comme illustré à la figure 3.24.
                 
<p class="cycle spec"><img src="/ressources/e70.png" alt=""></p>
                 <p class="fig">Figure 3.23 : Une façon d'ouvrir un fichier avec l'ouverture floue.
                 
<p class="cycle spec"><img src="/ressources/e71.png" alt=""></p>
                 <p class="fig">Figure 3.24 : Une deuxième façon d'ouvrir un fichier avec l'ouverture floue.
                                 <p class="lamda">Après avoir ouvert plusieurs fichiers dans un projet, vous aurez généralement plusieurs onglets ouverts dans votre éditeur (Figure 3.25). Je vous recommande d'apprendre les raccourcis clavier pour passer de l'un à l'autre, qui sont généralement des combinaisons telles que ⌘1, ⌘2, etc. (À noter que cette astuce fonctionne également dans de nombreux navigateurs, tels que Chrome et Firefox.)</p>
                                
<p class="cycle spec"><img src="/ressources/e72.png" alt=""></p>
                 <p class="fig">Figure 3.25 : Ouverture de plusieurs onglets.
                 
<h2 id="cneuf"> 3.4.2 Volets multiples</h2>
                 <p class="lamda">La vue d'éditeur par défaut que nous avons vue dans la plupart des exemples précédents se compose d'un seul volet (comme dans « volet de fenêtre »), mais il est souvent pratique de diviser l'éditeur en plusieurs volets afin de pouvoir voir plusieurs fichiers à la fois (Figure 3.26) . J'aime particulièrement utiliser des volets différents pour différents types de fichiers, par exemple le volet gauche pour le code de test et le volet droit pour le code d'application. Il est également souvent utile d'ouvrir le même fichier dans deux volets différents (Figure 3.27) ; comme je l'ai écrit dans le méta-tutoriel 643-code Tutorial Writing :
                    <br>
                    Lorsque l'on effectue une recherche dans le document pour une raison quelconque (corriger une erreur, rechercher une étiquette pour une référence croisée, trouver une chaîne particulière, etc.), il est généralement peu pratique de déplacer le curseur et donc de perdre sa place. Dans ce contexte, il est utile d'ouvrir le même fichier dans deux fenêtres différentes de l'éditeur de texte... De cette façon, nous pouvons utiliser un volet comme zone d'écriture principale et l'autre volet comme une sorte de fenêtre « à accès aléatoire » pour se déplacer dans le document.
                 
</p>
                  <p class="lamda">Remarque : les « volets » sont parfois appelés « groupes » (par exemple, dans Sublime Text).</p>
                  <p class="cycle spec"><img src="/ressources/e73.png" alt=""></p>
                 <p class="fig">Figure 3.26 : Utilisation de plusieurs volets.</p>
                 
<p class="cycle spec"><img src="/ressources/e74.png" alt=""></p>
                 <p class="fig">Figure 3.27 : Ouverture du même fichier dans deux volets différents.
                 
<h2 id="sun">3.4.3 Recherche et remplacement globaux</h2>
                 <p class="lamda">Nous avons vu dans la section 2.8 comment rechercher et, éventuellement, remplacer du contenu dans un seul fichier. Lors de l'édition de projets, il est souvent utile de pouvoir effectuer une recherche et un remplacement globaux dans plusieurs fichiers. Comme d'habitude, la plupart des éditeurs proposent à la fois un élément de menu (Figure 3.28) et un raccourci clavier (souvent ⇧⌘F).</p>
                  <p class="cycle spec"><img src="/ressources/e75.png" alt=""></p>
<p class="fig">Figure 3.28 : Élément de menu pour la recherche et le remplacement globaux.
                  
<p class="lamda">La figure 3.29 montre un exemple de recherche globale, qui recherche la chaîne « @user » dans tous les fichiers du projet. La commande permettant de remplacer globalement cette chaîne par « @person » est illustrée à la figure 3.30. 
                  <p class="cycle spec"><img src="/ressources/e76.png" alt=""></p>
                  
<p class="fig">Figure 3.29 : Résultat de la recherche dans le projet. </p>
                  <p class="cycle spec"><img src="/ressources/e77.png" alt=""></p>
                  <p class="fig">Figure 3.30 : Résultat du remplacement dans le projet. </p>
                  <p class="lamda">Pour un remplacement vraiment avancé, nous pouvons utiliser un mini-langage pour la correspondance de motifs de texte appelé expressions régulières (ou regexes en abrégé). (Les regexes ont été brièvement mentionnées dans 643-code Command Line .) Voyons comment utiliser les regexes pour ajouter une annotation à toutes les définitions de fonctions du projet, en remplaçant</p>
                  
<p class="cod">def foo</p>
                  <p class="lamda">en
                  <p class="cod">def foo    # définition de fonction</p>
                  <p class="lamda">et
                  <p class="cod">def bar</p>
                  <p class="lamda">en
                  
<p class="cod">def bar    # définition de fonction</p>
                  <p class="lamda">Ma méthode préférée pour créer des expressions régulières consiste à utiliser une application web telle que regex101, qui nous permet de créer des expressions régulières de manière interactive (Figure 3.31). De plus, ces ressources comprennent généralement un guide de référence rapide qui nous aide à trouver le code correspondant à des modèles particuliers (Figure 3.32).</p>
                                   
<p class="cycle spec"><img src="/ressources/e78.png" alt=""></p>
                  <p class="fig">Figure 3.31 : Un testeur d'expressions régulières en ligne.
<p class="cycle spec"><img src="/ressources/e79.png" alt=""></p>
                  
<p class="fig">Figure 3.32 : Gros plan sur la référence regex. </p>
                  <p class="lamda">Nous pouvons utiliser la référence de la figure 3.32 pour découvrir une regex pour def suivie de n'importe quelle séquence de caractères, qui ressemble à ceci :</p>
<p class="cod">def .*</p>
                  <p class="lamda">Ici, . représente « n'importe quel caractère », tandis que * correspond à zéro ou plusieurs caractères. Une recherche globale à l'aide de l'expression régulière def .* correspond à toutes les définitions de fonction du projet, comme le montre la figure 3.33. Notez que dans la plupart des éditeurs, vous devrez activer la correspondance d'expressions régulières en cliquant sur l'icône de correspondance d'expressions régulières (.* dans la figure 3.33). </p>
                  <p class="cycle spec"><img src="/ressources/e80.png" alt=""></p>
<p class="fig">Figure 3.33 : Correspondance d'une expression régulière.
<p class="lamda">Nous pouvons effectuer le remplacement mentionné ci-dessus en utilisant des parenthèses pour créer deux groupes de correspondance :
                  
<p class="cod">(def) (.*)</p>
                  <p class="lamda">Le premier groupe de correspondance ici est simplement la chaîne constante def, tandis que le second est la définition de la fonction, quelle qu'elle soit. (Ces groupes de correspondance apparaissent également dans la figure 3.31.) Dans le champ « Remplacer » de l'éditeur, nous pouvons référencer ces groupes à l'aide de numéros de correspondance spéciaux précédés du signe dollar, afin de pouvoir remplacer</p>
                  <p class="cod">(def) (.*)</p>
<p class="lamda">par</p>
                  
<p class="cod">$1 $2    # définition de fonction</p>
                  <p class="lamda">Par exemple, lors de la correspondance avec def foo, $1 est def et $2 est foo ; lors de la correspondance avec def bar, $1 est toujours def, mais $2 est bar. Cela signifie que nous pouvons annoter toutes les définitions de fonction en même temps à l'aide des commandes illustrées dans la figure 3.34. La réalisation effective de ce remplacement est laissée à titre d'exercice (section 3.4.4).</p>
<p class="cycle spec"><img src="/ressources/e81.png" alt=""></p>
<p class="fig">Figure 3.34 : Utilisation d'un regroupement de correspondances.
                  <p class="lamda">Une chose à garder à l'esprit lorsque vous utilisez la recherche et le remplacement globaux est qu'il peut être difficile de les annuler. Dans le cas d'un seul fichier, il est assez facile d'annuler un mauvais remplacement avec ⌘Z (section 2.6), mais lorsque vous remplacez dans plusieurs fichiers, vous devez exécuter ⌘Z dans chaque fichier concerné, ce qui peut représenter des dizaines de fichiers. Par conséquent, je recommande d'utiliser la fonction de recherche et remplacement global avec beaucoup de prudence, et de préférence en combinaison avec un système de contrôle de version tel que Git. J'ai pour habitude d'effectuer un commit avant toute recherche et remplacement global afin de pouvoir facilement annuler l'opération en cas d'erreur. (Voir 643-code Git  pour plus d'informations.)</p>
                   
<h2 id="sdeux">3.4.4 Exercices</h2>
                   <p class="exo">1-Quel est le raccourci clavier de votre éditeur pour basculer entre l'affichage arborescent et l'affichage horizontal ?</p>
                   <p class="exo">2-Quel est le raccourci clavier de votre éditeur pour diviser les volets horizontalement ?</p>
                   <p class="exo">3-Dans le projet d'application exemple du tutoriel Rails, ouvrez le fichier static_pages_controller.rb à l'aide de l'ouverture floue. </p>
                   
<p class="exo">4-Utilisez la recherche globale pour trouver toutes les occurrences de la chaîne @user</p>
                   <p class="exo">5-Utilisez le remplacement global pour remplacer toutes les occurrences de @user par @person</p>
                   <p class="exo">6-Utilisez une expression régulière pour annoter toutes les définitions de fonction avec # function definition comme décrit dans le texte. </p>
                  
                   <button class="btn">Commencer : le chapitre</button>
                </div>
        </div>
 

        </section>
        <!-- 25-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 
<h2 id="strois">3.5 Personnalisation</h2>
                 <p class="lamda">Tous les bons éditeurs de texte sont hautement personnalisables, mais les options dépendent fortement de l'éditeur. Le plus important est (a) de savoir quel type de personnalisation est possible et (b) d'appliquer vos connaissances techniques (encadré 1.2) pour déterminer comment apporter les modifications souhaitées.
                 <p class="lamda">Par exemple, un étudiant du tutoriel ruby a écrit pour poser une question sur le fond sombre de l'éditeur Cloud9 (voir figure 2.5), se demandant s'il était possible d'utiliser un fond clair à la place. Je lui ai répondu qu'il était presque certain qu'il était possible de passer à un fond clair, même si je ne savais pas comment faire sur le moment. Je savais que tous les bons éditeurs de programmeurs proposaient plusieurs combinaisons de couleurs de surbrillance, tailles de police, tailles d'onglets, etc. J'étais donc convaincu que je pourrais trouver comment changer la couleur de fond de l'éditeur Cloud9. Et en effet, en cliquant un peu partout et en cherchant les éléments de menu prometteurs (une application classique de l'encadré 1.2), j'ai pu trouver la réponse (Préférences > Thèmes > Thème syntaxique > Cloud9 Day), comme le montre la figure 3.35. 
                  <p class="cycle spec"><img src="/ressources/e82.png" alt=""></p>
                  
<p class="fig">Figure 3.35 : L'éditeur Cloud9 avec un arrière-plan clair. </p>
                  <p class="lamda">Une autre fonctionnalité commune aux bons éditeurs de texte est une sorte de système de paquets. Par exemple, nous avons vu dans la section 2.2.2 que  est livré avec un paquet intégré pour prévisualiser Markdown, mais dans Sublime Text, nous devons installer un paquet séparé appelé Package Control pour le faire.
 Une façon de trouver de nouveaux paquets consiste à rechercher des informations sur Google, ce qui mène à un site comme celui illustré à la figure 3.36. Le résultat est une nouvelle option, Sublime Text > Préférences > Package Control, comme le montrent les figures 3.37 et 3.38. 
<p class="cycle spec"><img src="/ressources/e83.png" alt=""></p>
                  
<p class="fig">Figure 3.36 : Recherche d'un package Sublime Text. 
                  <p class="cycle spec"><img src="/ressources/e84.png" alt=""></p>
                  <p class="fig">Figure 3.37 : Élément de menu Package Control de Sublime Text.
                  
<p class="cycle spec"><img src="/ressources/e85.png" alt=""></p>
                  <p class="fig">Figure 3.38 : Contrôle des paquets de Sublime Text.
                  <p class="lamda">La plupart des éditeurs vous permettent de créer vos propres paquets de commandes et prennent souvent en charge des extraits de code qui vous permettent de définir vos propres déclencheurs de tabulation (section 3.1). Il s'agit là de sujets avancés, je vous recommande donc de les laisser de côté pour l'instant. Une fois que vous commencez à être agacé de devoir taper à plusieurs reprises le même code standard (comme dans le listing 3.11, par exemple), faites une recherche sur Google pour savoir comment ajouter des commandes personnalisées à votre éditeur. (Le code du listing 3.11 est généré à l'aide du déclencheur de tabulation personnalisé clist (pour « code listing ») de Sublime Text, que j'ai également porté vers Sublime Text.)</p>
                  
<p class="cod">
                    Listing 3.11 : Le modèle pour un listing de code dans ce document. <br>
\begin{codelisting} <br>
\label{code:} <br>
\codecaption{} <br>
%= lang: <br>
\begin{code} <br>
                                        
\end{code} <br>
                    \end{codelisting}
</p>
<h2>3.5.1 Exercices</h2>
<p class="exo">Déterminez comment modifier le thème de mise en évidence de la syntaxe dans votre éditeur. Utilisez le fichier du listing 3.6 pour confirmer la modification.
       




                  <button class="btn">Commencer: le chapitre</button>


             </div>
             
         </div>
 
         
        </section>
        <!-- 26-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="squatre">3.6 Résumé</h2>
                 <p class="lamda">
                    1-La saisie automatique et les raccourcis clavier facilitent la saisie rapide de longs textes. <br>
                    2-Tous les bons éditeurs de texte disposent de fonctionnalités spéciales pour faciliter l'écriture de code source informatique, notamment la coloration syntaxique, les commentaires, l'indentation et la désindentation, et le saut à un numéro de ligne. <br>
                    
3-De nombreux programmeurs pensent qu'il est tout à fait acceptable d'avoir des lignes de plus de 80 colonnes, mais ils ont tort. (À ce propos, rien n'est plus divertissant qu'une guerre sainte (encadré 1.5)…) <br>
                    4-Une fois que vous savez utiliser la ligne de commande et un éditeur de texte, il est facile d'ajouter des scripts shell personnalisés à votre système. <br>
                    
5-Il est courant d'ouvrir des projets entiers (tels que des applications ruby) en une seule fois à l'aide de la ligne de commande. <br>
                    6-L'ouverture floue est utile lors de l'édition de projets comportant un grand nombre de fichiers. <br>
7-L'utilisation de plusieurs volets permet à l'éditeur d'afficher plusieurs fichiers à la fois. <br>
8-La recherche et le remplacement globaux sont dangereux, mais puissants. <br>
                    
9-Tous les bons éditeurs de programmeurs sont extensibles et personnalisables.
                 </p>
                 <p class="lamda">Les commandes importantes de ce chapitre sont résumées dans le tableau 3.1.
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong>Commande</strong></td>
                    
<td class="align_left"><strong>Description</strong></td>
                    </tr>
<tr>
<td class="align_left">Sélectionner + ⌘/</td>
<td class="align_left">Activer/désactiver les commentaires</td>
                    </tr>
                    <tr>
                    <td class="align_left">Select + ⇥</td>
                    <td class="align_left">Indent</td>
                    </tr>
                    <tr>
                    <td class="align_left">Select + ⇧⇥</td>
                    <td class="align_left">Dedent</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌃G</td>
                    <td class="align_left">Goto line number</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘W</td>
                    <td class="align_left">Close a tab</td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">$ echo $PATH</code></td>
                    <td class="align_left">Show the current path variable</td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">$ chmod +x &lt;filename&gt;</code></td>
                    <td class="align_left">Make <code class="tt">filename</code> executable</td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">$ unzip &lt;filename&gt;.zip</code></td>
                    <td class="align_left">Unzip a ZIP archive</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘P</td>
                    <td class="align_left">Fuzzy opening</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘1</td>
                    <td class="align_left">Switch focus to tab #1</td>
                    </tr>
                    <tr>
                    <td class="align_left">⇧⌘F</td>
                    <td class="align_left">Global find and replace</td>
                    </tr>
                    </tbody>
                    </table>

                    <p class="fig">Table 3.1: Important commands from Chapter 3.</p>
                    <button class="btn">Commencer: le chapitre</button>
                
             </div>
             
         </div>
 
        
        </section>
        <!-- 27-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="scinq">3.7 Conclusion</h2>
                 <p class="lamda">Félicitations ! Vous en savez désormais suffisamment sur les éditeurs de texte . Si vous continuez dans cette voie technique, vous ne cesserez de vous améliorer dans l'utilisation des éditeurs de texte pendant des années, mais grâce au contenu de ce tutoriel, vous avez déjà pris un excellent départ. Pour l'instant, il vaut mieux que vous travailliez avec ce dont vous disposez, en appliquant vos connaissances techniques (encadré 1.2) lorsque cela est nécessaire. Une fois que vous aurez acquis un peu plus d'expérience, je vous recommande de rechercher des ressources spécifiques à l'éditeur de votre choix. Pour vous aider à démarrer, voici quelques liens vers la documentation des éditeurs mentionnés dans ce tutoriel :</p>
                  
<p class="lamda">
                    <ul>
<li>Documentation Sublime Text</li>
<li> Documentation</li>
<li>Documentation de l'éditeur Cloud9</li>
</ul>
</p>
                  
<p class="lamda">
                    Pour rappel, 643-code Text Editor  n'est qu'un tutoriel parmi une série conçue pour enseigner les bases du développement logiciel. La prochaine étape de la série est 643-code Git le guide !
                  </p>
                  <button class="btn">Bonne chance 💪💪💪  </button>
                 
             </div>
             
         </div>
 
        
        </section>       

    </main>
   
    
        <a href="#home" id="home" class="scroll-up-btn">
                <i class="fas fa-arrow-up"></i>
        </a>
   
        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-migrate/3.0.0/jquery-migrate.min.js"></script>
    <script src="/js/app.js"></script>
</body>
</html>