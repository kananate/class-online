<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="/ressources/logo-1.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://kit.fontawesome.com/75303112de.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/5.3.0/ekko-lightbox.css" />
    <title>Editor</title>    
    <link rel="stylesheet" href="/css/type.css">
</head>
<body>
    
    <header>        
        <nav>
        <ul
            class="logo">
            <li><a href="/index.html"><img src="/ressources/logo-1.png" width="50" alt=""></a></li>
        </ul>
        <ul
        class="logo">
        <li><a href="#chap0">Avant Propos</a></li>
        </ul>
         <ul>
            <li class="title-item"><a href="#chap1">Chapitre 1</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#zero">1. Introduction aux éditeurs de texte</a></li>                         
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#un">1.1 Vim minimum viable</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#deux">1.2 Starting Vim</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trois">1.2.1 Exercises</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quatre">1.3 Édition de petits fichiers</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cinq">1.3.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#six">1.4 Sauvegarde et fermeture des fichiers</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#sept">1.4.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#huit">1.5 Suppression de contenu</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#neuf">1.5.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dix">1.6 Édition de fichiers volumineux</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#onze">1.6.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#douze">1.7 Résumé</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#treize">1.7.1 Exercices</a></li>               

         </ul>
         <ul>
            <li class="title-item"><a href="#chap2">Chapitre 2</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quatorze">2. Éditeurs de texte modernes</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quinze">2.1 Choisir un éditeur de texte</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#seize">2.1.1 Sublime Text</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dixsept">2.1.2 Visual Studio Code (VSCode)</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dixhuit">2.1.3 Atom</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dixneuf">2.1.4 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vin">2.2 Ouverture</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinun">2.2.1 Mise en évidence de la syntaxe</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vindeux">2.2.2 Aperçu de Markdown</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vintrois">2.2.3 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinquatre">2.3 Déplacement</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vincinq">2.3.1 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinsix">2.4 Sélection de texte</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinsept">2.4.1 Sélection d'un seul mot</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinhuit">2.4.2 Sélection d'une seule ligne</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinneuf">2.4.3 Sélection de plusieurs lignes</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trente">2.4.4 Sélection de l'ensemble du document</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trenteun">2.4.5 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentedeux">2.5 Couper, copier, coller</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentetrois">2.5.1 Coupe sautée</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentequatre">2.5.2 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentecinq">2.6 Suppression et annulation</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentesix">2.6.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentesept">2.7 Économies</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trentehuit">2.7.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trenteneuf">2.8 Rechercher et remplacer</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quarante">2.8.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qun">2.9 Résumé</a></li>        
         </ul>
        
         <ul>
            <li class="title-item"><a href="#chap3">Chapitre 3</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qdeux">3. Édition de texte avancée</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qtrois">3.1 Saisie semi-automatique et déclencheurs d'onglets</a></li>               
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qquatre">3.1.1 Saisie semi-automatique</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qcinq">3.1.2 Déclencheurs d'onglets</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qsix">3.1.3 Exercices</a></li> 
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qsept">3.2 Écriture du code source</a></li>                              
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qhuit">3.2.1 Mise en évidence de la syntaxe </a></li>                
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qneuf">3.2.2 Commenter </a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cun">3.2.3 Indentation et retrait</a></li> 
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cdeux">3.2.4 Aller au numéro de ligne</a></li>  
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#ctrois">3.2.5 80 colonnes</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cquatre">3.2.6 Exercices</a></li>               
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#ccinq">3.3 Écriture d'un script exécutable</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#csix">3.3.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#csept">3.4 Projets d'édition</a></li> 
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#chuit">3.4.1 Ouverture floue</a></li>                              
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cneuf">3.4.2 Volets multiples</a></li>                
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#sun">3.4.3 Recherche et remplacement globaux</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#sdeux">3.4.4 Exercices</a></li> 
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#strois">3.5 Personnalisation</a></li>  
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#squatre">3.5.1 Exercices</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#scinq">3.6 Résumé</a></li>  
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#ssix">3.7 Conclusion</a></li>  
                     
         </ul>     
        </nav>
    </header>
    <main>
        <!-- A propos -->     
        <section >
         <div class="container-video">
             <h1>Noms de domaines</h1>
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 
                 <h2 id="chap0"> QUI SUIS-JE ?</h2>

                <p class="lamda">
                    ABDOULAYE DIALLO est un développeur de logiciels passionné par l'enseignement. <br> Il a travaillé avec de nombreuses start-ups sur des projets personnels et en tant que freelance très bien noté sur les places de marché. <br>

                    ABDOULAYE DIALLO a enseigné la programmation et le marketing à plus de 100 000 étudiants en ligne et hors ligne en tant que formateur. <br>
                    
                    ABDOULAYE DIALLO maîtrise l'art d'expliquer des sujets très complexes de la manière la plus simple possible, facile à comprendre et à suivre. Ses cours vidéo sont également utilisés par des entreprises pour former leurs employés et par des universités pour préparer leurs étudiants et améliorer leurs compétences en fonction des exigences du secteur.
                    
                    
                  
                </p>
                <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
         
        </section>

        <!-- 1 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="zero">Introduction aux éditeurs de texte</h2>

                 <p class="lamba">Learn Enough Text Editor to Be Dangerous est conçu pour vous aider à apprendre à utiliser ce qui est sans doute l’élément le plus important dans le sac d’astuces de l’ aspirant magicien informatique : un éditeur de texte ( Figure  1.1 ).Apprendre à utiliser un éditeur de texte est un élément essentiel de la sophistication technique .

                 </p>
                 <p class="cycle spec"><img src="/ressources/e1.png" alt=""></p>
                  <p class="fig">Figure 1.1 : Un éditeur de texte.</p>
                  <p class="lamda">Contrairement à d'autres didacticiels d'éditeur de texte, qui sont généralement liés à un éditeur spécifique, ce didacticiel est conçu pour présenter l'ensemble de la catégorie d'application, une catégorie dont beaucoup de gens ne savent même pas qu'elle existe.De plus, les tutoriels spécifiques aux éditeurs ont tendance à s'adresser aux développeurs professionnels et supposent généralement des années d'expérience, mais Learn Enough Text Editor to Be Dangerous ne suppose même pas que vous savez ce qu'est un « éditeur de texte ».Son seul prérequis est une compréhension de base de la ligne de commande Unix, telle que celle fournie par Learn Enough Command Line to Be Dangerous .</p>
                  <p class="lamda">Parce que Learn Enough Text Editor to Be Dangerous fait partie d'une série de tutoriels conçus pour enseigner les fondamentaux du développement logiciel (avec un accent particulier sur les prérequis pour apprendre le développement Web avec le tutoriel Ruby on Rails ), il est idéal pour tous ceux qui souhaitent acquérir les compétences nécessaires pour travailler avec des développeurs ou devenir eux-mêmes développeurs.Enfin, même si vous savez déjà utiliser un éditeur de texte, suivre ce tutoriel (et faire les exercices) vous aidera à combler vos lacunes dans vos connaissances, et vous pourriez même apprendre quelques nouvelles astuces.</p>
                  <p class="lamda">Contrairement à la plupart des programmes utilisés pour produire des documents écrits, tels que les traitements de texte et les clients de messagerie, un éditeur de texte est une application spécifiquement conçue pour éditer du texte brut (souvent appelé simplement « texte » en abrégé).Apprendre à utiliser un éditeur de texte est important car le texte est omniprésent dans l'informatique moderne : il est utilisé pour le code, le balisage, les fichiers de configuration et bien d'autres choses .(En effet, j'utilise du texte brut pour écrire ce document.)Bien qu'il soit étonnamment difficile de définir exactement ce qu'est un « texte brut », d'un point de vue pratique, cela signifie que le texte lui-même n'a aucun formatage, ou du moins aucun qui compte.Il n'y a aucune notion de texte mis en valeur ou en gras , de taille de policetypeface , etc. — la seule chose qui compte, c'est le contenu .Par exemple, bien que la phrase précédente contienne une sortie formatée comme celle-ci , sa source est du texte brut et apparaît comme dans la liste  1.1.3</p>
                  <p class="cod">
                    Liste 1.1 : La source HTML d'une phrase dans ce tutoriel. <br>
                       <code><span></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Il n'y a aucune notion de </font><font dir="auto" style="vertical-align: inherit;">texte </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt; </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">em </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> souligné </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt;/ </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">em </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> ou </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt; </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">strong </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> gras </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt;/ </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">strong </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt; ,</font></font></span><font dir="auto" style="vertical-align: inherit;"></font><font></font><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">
la </font><font dir="auto" style="vertical-align: inherit;">taille </font><span class="p"><font dir="auto" style="vertical-align: inherit;">de </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">la </font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;">police </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">et </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">la </font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;">police </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">de </font></span></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">caractères</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> n'ont </font><span class="p"><font dir="auto" style="vertical-align: inherit;">pas </font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;">d' </font></span><span class="p"><font dir="auto" style="vertical-align: inherit;">importance </font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;">,</font></span><font dir="auto" style="vertical-align: inherit;">​</font><font dir="auto" style="vertical-align: inherit;">​</font></font><span class="nt"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><font dir="auto" style="vertical-align: inherit;"></font><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><font dir="auto" style="vertical-align: inherit;"></font><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><font dir="auto" style="vertical-align: inherit;"></font><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"></font></span><font dir="auto" style="vertical-align: inherit;"></font><font></font><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">
etc. </font></font><span class="ni"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">—</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> la seule chose qui compte est le </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt; </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">em </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> contenu </font></font><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&lt;/ </font></font></span><span class="nt"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">em </font></font></span><span class="p"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">&gt;</font></font></span><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;"> .
</font></font></code>
                  </p>
                  <p class="lamda">Dans la liste  1.1 , les options de formatage souhaitées sont indiquées avec des balises spéciales (telles que la balise d'emphase HTML <em>…</em>) plutôt qu'en modifiant l'apparence du texte lui-même.C'est la raison principale pour laquelle les programmes de traitement de texte plus familiers tels que Word ne sont pas bien adaptés à l'édition de texte brut, et un autre type d'outil est nécessaire ( Encadré  1.1 ).</p>
                  <p class="comment">
                    Encadré 1.1. Traitements de texte et éditeurs de texte
Même si vous n'avez jamais utilisé d'éditeur de texte, il y a de fortes chances que vous ayez utilisé un outil similaire, un traitement de texte .Il existe de nombreux chevauchements entre les fonctionnalités des traitements de texte et des éditeurs de texte.Par exemple, ils vous permettent tous deux de créer des documents, de rechercher et de remplacer ou de couper/copier/coller du texte et d'enregistrer les résultats.La principale différence est que les traitements de texte sont généralement conçus pour produire des documents selon le principe « What You See Is What You Get » (WYSIWYG, prononcé « WIZ-ee-wig »), de sorte que les effets tels que l'emphase ou le gras sont obtenus directement dans l'application, au lieu d'utiliser un balisage en texte brut comme <em>emphasis</em>ou **boldface**.La plupart du temps, les traitements de texte enregistrent également leurs résultats dans des formats propriétaires qui peuvent parfois mal fonctionner (comme l'ont appris à leur grand désespoir de nombreuses personnes ayant essayé d'ouvrir d'anciens fichiers Word).

En revanche, les éditeurs de texte sont conçus pour modifier du texte brut, l’un des formats les plus universels et les plus durables.Les éditeurs de texte diffèrent également des traitements de texte en ayant des fonctionnalités destinées aux utilisateurs plus techniques, notamment la coloration syntaxique du code source ( Section  3.2.1 ), l'indentation automatique ( Section  3.2.3 ), la prise en charge des expressions régulières ( Section  3.4.3 ) et la personnalisation via des packages et des extraits ( Section  3.5 ).Un bon éditeur de texte est donc un outil essentiel dans la boîte à outils de tout technicien.
                  </p>
                  <p class="cycle spec"><img src="/ressources/e2.jpg" alt=""></p>
                  <p class="fig">Figure 1.2 : Pourquoi ne pas éditer du texte brut avec Microsoft Word ?</p>
                   <p class="lamda">S'appuyant sur le matériel développé dans Learn Enough Command Line to Be Dangerous , Learn Enough Text Editor to Be Dangerous commence par couvrir l'important éditeur Vim ( Section  1.1 ), qui peut être exécuté sur la ligne de commande directement dans une fenêtre de terminal.Vim nous donnera l'occasion de voir nos premiers exemples des fonctions les plus importantes d'un éditeur de texte, mais comme Vim peut être d'une complexité prohibitive pour un débutant, dans ce tutoriel nous ne couvrirons que le strict minimum nécessaire pour effectuer des modifications de base.Le reste du didacticiel développera les thèmes développés au chapitre  1 en décrivant certaines des nombreuses fonctionnalités puissantes requises dans tout éditeur de texte de niveau programmeur, avec des exemples tirés principalement de Sublime Text , un éditeur multiplateforme disponible gratuitement, 5 avec des concepts applicables aux éditeurs Atom 6 et Visual Studio Code étroitement liés et à Cloud9 , un IDE cloud</p>
                   <p class="lamda">Comme pour Learn Enough Command Line to Be Dangerous , ce tutoriel fait partie de la tradition Unix , qui inclut pratiquement tous les systèmes d'exploitation dont vous avez entendu parler (macOS, iOS, Android, Linux, etc.) à l'exception de Microsoft Windows.Bien que tous les éditeurs dont nous parlerons fonctionnent sous Windows, l'utilisation d'un système d'exploitation non Unix introduit des frictions dans le processus. Les utilisateurs de Windows sont donc encouragés à configurer un environnement de développement compatible Linux en suivant les étapes Windows décrites dans Learn Enough Dev Environment to Be Dangerous ou à utiliser un IDE cloud basé sur Linux (qui est également abordé dans Learn Enough Dev Environment to Be Dangerous ).

                   </p>
                   <p class="lamda">Tout au long de Learn Enough Text Editor to Be Dangerous, l'accent est mis sur les principes généraux. Ainsi, quel que soit l'éditeur que vous utilisez, vous disposerez d'une bonne liste de contrôle mentale des types de tâches que vous devez confier à votre éditeur.De plus, comme les détails varient selon l’éditeur de texte et le système, ce didacticiel constitue une occasion idéale de continuer à développer votre sophistication technique ( Encadré  1.2 ).Enfin, ne ressentez aucune pression pour tout maîtriser d’un coup.Vous pouvez être productif même avec un petit sous-ensemble de ce qui est inclus dans ce didacticiel.Parce que les personnes techniquement sophistiquées utilisent des éditeurs de texte pratiquement tous les jours, vous continuerez à apprendre de nouvelles astuces à perpétuité.</p>
                   <p class="comment">Encadré 1.2. Sophistication technique
                    L'expression sophistication technique , mentionnée précédemment dans Apprendre suffisamment de ligne de commande pour être dangereux , fait référence à la capacité générale à utiliser des ordinateurs et d'autres choses techniques.Cela comprend à la fois les connaissances existantes (telles que la familiarité avec les éditeurs de texte et la ligne de commande Unix) et la capacité d'acquérir de nouvelles connaissances, comme illustré dans « Tech Support Cheat Sheet » de xkcd .Contrairement aux « compétences techniques » telles que le codage et le contrôle de version, ce dernier aspect de la sophistication technique est une « compétence douce » – difficile à enseigner directement, mais essentielle à développer si vous souhaitez travailler avec des programmeurs informatiques ou devenir vous-même programmeur.
                    
                    Dans le contexte des éditeurs de texte, la sophistication technique comprend des choses comme la lecture des éléments de menu pour comprendre ce qu'ils font, l'utilisation du menu Aide pour découvrir de nouvelles commandes, l'apprentissage des raccourcis clavier en lisant les éléments de menu ou en effectuant une recherche sur Google, etc.Cela implique également une tolérance à l'ambiguïté : les lecteurs techniquement avertis ne paniqueront pas si un tutoriel indique d'utiliser ⌘Z pour annuler quelque chose alors qu'il s'agit en fait de ⌃Z sur leur système.Ils ne paniqueront pas non plus s'ils voient ⌘Z mais ne savent pas ce que ⌘ signifie, car ils savent qu'ils peuvent parcourir la page pour trouver quelque chose comme le tableau  2.1 , ou simplement le rechercher sur Google .L’aspect le plus important de la sophistication technique est peut-être l’ attitude : une confiance et un esprit d’initiative face à la confusion, qui méritent d’être cultivés.
                    
                    Tout au long du reste de Learn Enough Text Editor to Be Dangerous , nous nous référerons à cette boîte chaque fois que nous rencontrerons des exemples de problèmes qui nécessitent un peu de sophistication technique pour être résolus.Avec l’expérience, vous deviendrez vous aussi l’un des « informaticiens » de « Tech Support Cheat Sheet » qui semblent avoir la capacité magique de comprendre les choses techniques.( Attention : vous aurez peut-être besoin d'une nouvelle chemise ( Figure  1.3 ).)</p>


                    <button class="btn">Commencer: le chapitre</button>


             </div>
             
         </div>
 
        </section>
        <!-- 2 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="un">1.1 Vim minimum viable</h2>

               <p class="lamda">L'éditeur vi (prononcé « vee-eye ») remonte aux premiers jours d'Unix, et Vim (prononcé « vim ») est une version mise à jour qui signifie « Vi IMproved ».Vim est un éditeur de texte absolument puissant, et de nombreux développeurs l'utilisent pour leurs besoins d'édition quotidiens, mais la barrière à la maîtrise de Vim est élevée, et il nécessite une personnalisation substantielle et une sophistication technique ( Encadré  1.2 ) pour atteindre son plein potentiel.Vim dispose également d'un ensemble de commandes vaste et souvent obscur, qui correspondent rarement aux raccourcis clavier natifs, ce qui rend Vim difficile à apprendre et à mémoriser.Par conséquent, je recommande généralement aux débutants d’apprendre un éditeur « moderne » ( chapitre  2 ) pour une utilisation quotidienne.Néanmoins, je considère qu'une maîtrise minimale de Vim est essentielle, simplement parce que Vim est omniprésent : il est présent sur pratiquement tous les systèmes de type Unix dans l'univers connu, ce qui signifie que si vous vous connectez via SSH à un serveur aléatoire à l'autre bout du monde, Vim sera probablement là.</p>
               <p class="lamda">Ce chapitre inclut uniquement le minimum viable de Vim, juste assez pour utiliser Vim pour effectuer des tâches telles que modifier de petits fichiers de configuration ou des commits Git.Ce n’est même pas suffisant pour être dangereux .</p>
               <p class="lamda">Mais il convient de noter que même la maîtrise de Minimum Viable Vim vous place dans une compagnie d'élite - parce que Vim est si difficile, même une petite connaissance de Vim est le genre de chose qui peut impressionner vos amis (ou un recruteur).</p>
               <p class="lamda">Remarque : si vous utilisez macOS, vous devez suivre les instructions de l’encadré  1.3 pour le moment.</p>
               <div class="comment">
                Encadré 1.3. Passer de macOS à Bash
                Si vous utilisez macOS, à ce stade, vous devez vous assurer que vous utilisez le bon programme shell pour ce didacticiel.Le shell par défaut de macOS Catalina est Z shell (Zsh), mais pour obtenir des résultats cohérents avec ce tutoriel, vous devez passer au shell appelé Bash .
                
                La première étape consiste à déterminer quel shell votre système exécute, ce que vous pouvez faire à l'aide de la echocommande :
                 <p class="cod">
                  $ echo $SHELL <br>
                  /bin/bash
                </p>
                Ceci imprime la $SHELL variable d'environnement .Si vous voyez le résultat affiché ci-dessus, indiquant que vous utilisez déjà Bash, vous avez terminé et pouvez continuer le reste du didacticiel.(Dans de rares cas, $SHELLcela peut différer du shell actuel, mais la procédure ci-dessous passera toujours correctement d'un shell à un autre.)Pour plus d'informations, notamment sur la manière de passer à Z Shell et de l'utiliser avec ce didacticiel, consultez l'article de blog Learn Enough « Utilisation de Z Shell sur Mac avec les didacticiels Learn Enough ».
                
                L’autre résultat possible echoest le suivant :
                <p class="cod">
                  $ echo $SHELL <br>
                  /bin/zsh
                  </p>
                Si c'est le résultat que vous obtenez, vous devez utiliser la chshcommande (« change shell ») comme suit :
                <p class="cod">
                  $ chsh -s /bin/bash
                </p>
                Vous serez presque certainement invité à saisir votre mot de passe système à ce stade, ce que vous devriez faire.Quittez ensuite complètement votre programme shell en utilisant Commande-Q et relancez-le.
                
                Vous pouvez confirmer que le changement a réussi en utilisant echo:
                <p class="cod">
                  $ echo $SHELL <br>
                  /bin/bash
                </p>
                À ce stade, vous commencerez probablement à voir l’alerte suivante, que vous devez ignorer :
                <p class="cod">
                  L'interpréteur de commandes interactif par défaut est désormais zsh. <br>
                  Pour mettre à jour votre compte et utiliser zsh, exécutez <br>
                  « chsh -s /bin/zsh ». <br>
                  Pour plus d'informations, consultez <br>
                  la page https://support.apple.com/kb/HT208050. <br>
                
                  [~]$
                  </p>
                Notez que la procédure ci-dessus est entièrement réversible, vous n’avez donc pas à craindre d’endommager votre système.Consultez « Utilisation de Z Shell sur Mac avec les didacticiels Learn Enough » pour plus d’informations.
               </div>  
               
               <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div> 
     
        </section>
        <!-- 3 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="deux">1.2 Démarrage de Vim</h2>
                 <p class="lamda">Contrairement à la plupart des éditeurs modernes décrits à partir du chapitre  2 , Vim peut être exécuté directement dans une fenêtre de terminal et ne nécessite aucune interface graphique .Il vous suffit de taper vimà l'invite :</p>
                 <p class="cod">$ vim</p>
                 <p class="lamda">Les résultats typiques de l’exécution de la vimcommande apparaissent dans la liste  1.2 et la figure  1.4 .Dans les deux cas, les tildes (~) ne sont pas des caractères du fichier mais représentent plutôt des lignes qui n'ont pas encore été définies.</p>
                 <p class="cod">
                    Liste 1.2 : Une représentation textuelle d'une fenêtre Vim (le message et les versions peuvent différer). <br>
                    ~ <br>
                    ~ <br>
                    ~ <br>
                    ~ <br>
                    ~ <br>
                    ~ VIM - Vi IMproved <br>
                    ~  <br>
                    ~ version 7.3 <br>
                    ~ par Bram Moolenaar et al. <br>
                    ~ Vim est open source et distribuable gratuitement  <br><br>
                    ~ 
                    ~ Aidez les enfants pauvres en Ouganda ! <br>
                    ~ tapez :help iccf<Entrée> pour plus d'informations <br> <br>
                    ~ 
                    ~ tapez :q<Entrée> pour quitter <br>
                    ~ tapez :help<Entrée> ou <F1> pour l'aide en ligne <br>
                    ~ tapez :help version7<Entrée> pour les informations de version 
                 </p>
                 <p class="cycle spec"><img src="/ressources/e3.png" alt=""></p>
                 <p class="fig">Figure 1.4 : Vim exécuté dans une fenêtre de terminal.</p>
                 <p class="lamda">Si démarrer Vim est facile, apprendre à l'utiliser, au moins au début, peut être incroyablement difficile.Cela est principalement dû au fait que Vim est un éditeur modal , ce qui est probablement différent de tout ce que vous avez utilisé auparavant ( Encadré  1.4 ).Vim possède deux modes principaux , appelés mode normal et mode d'insertion .Le mode normal permet d'effectuer des opérations telles que déplacer le fichier, supprimer du contenu ou rechercher et remplacer du texte, tandis que le mode d'insertion permet d'insérer du texte.</p>
                 <p class="comment">Encadré 1.4. Modal Vim
                    Lorsque j'ai commencé à apprendre la programmation dans la tradition Unix (par opposition à mon expérience d'enfance avec Microsoft DOS, BASIC et Pascal), je me souviens distinctement avoir été absolument mortifié par l'éditeur incroyablement primitif que j'étais censé utiliser.À l’époque, j’étais en première année de licence à l’Université de Harvard et je travaillais dans un groupe de recherche au Centre d’astrophysique Harvard-Smithsonian .L'outil qui m'avait été remis était vi.Dire que cela ressemble à une rétrogradation par rapport aux traitements de texte est un euphémisme ( Figure  1.2 ).
                    
                    Ce qui m'a le plus choqué à propos de vi était l'édition modale : contrairement aux traitements de texte, vi ne me permettait pas simplement de cliquer dans la fenêtre et de commencer à taper.Au lieu de cela, il y avait une profusion d'options ( i, aet oparmi elles) pour passer en mode insertion , et il suffisait de quelques mauvaises frappes de touches pour que l'enfer se déchaîne.Bien que les années intermédiaires aient vu une prolifération d'éditeurs de texte plus modernes, dont la conception ressemble beaucoup plus à l'interface de type « cliquer-et-taper » que j'attendais de mon expérience avec les traitements de texte, la popularité durable de vi (via Vim) signifie qu'apprendre les bases de l'édition modale est une compétence précieuse, même si cela peut sembler ridiculement étranger au premier abord.</p>
                 <p class="lamda">Aller-retour entre ces deux modes peut entraîner beaucoup de confusion, d'autant plus que pratiquement tous les autres programmes d'édition de texte (y compris les traitements de texte, les clients de messagerie et la plupart des éditeurs de texte) n'ont qu'un mode d'insertion.Ce qui rend Vim particulièrement déroutant, c'est qu'il démarre en mode normal, ce qui signifie que si vous essayez de saisir du texte immédiatement après le démarrage de Vim (comme dans la liste  1.2 ), le résultat sera le chaos.</p>
                 <p class="lamda">Étant donné que la confusion est le résultat le plus probable si vous n'êtes pas habitué à l'édition modale de Vim, nous allons commencer notre étude de Vim avec la commande Vim la plus importante™ .Un de mes amis d'université, qui était un fervent partisan d'Emacs, le rival historique de vi (et donc de Vim) ( Encadré  1.5 ), prétendait que la commande la plus importante de Vim™ était la seule qu'il ait jamais voulu apprendre.C'est ici:</p>
                 <p class="cod">
                    <code><span></span><span class="go"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">ESC:q!&lt;retour&gt;</font></font></span>
                    </code>
                    </p>
                    <p class="lamda">Cette commande signifie « Appuyez sur la touche Échap, puis tapez « deux points q point d'exclamation », puis appuyez sur la touche Retour. »Nous apprendrons dans un instant ce que cela fait et pourquoi, mais pour l'instant nous allons commencer par le pratiquer plusieurs fois dans les exercices.</p>
                 <p class="comment">
                    Encadré 1.5. Guerres saintes : vi contre Emacs
                    Le Jargon File définit les guerres saintes comme suit :
                    
                    guerres saintes : n.
                    
                    [de Usenet , mais peut être antérieur ; courant] guerres de flammes sur des questions religieuses .L'article de Danny Cohen qui a popularisé les termes big-endian et little-endian en lien avec la controverse LSB-first/MSB-first s'intitulait On Holy Wars and a Plea for Peace .
                    
                    Les grandes guerres saintes du passé ont inclus ITS contre Unix , Unix contre VMS , BSD Unix contre System V, C contre Pascal , C contre FORTRAN, etc.En 2003, les favoris populaires du jour étaient KDE contre GNOME, vim contre elvis, Linux contre [Free|Net|Open]BSD.Les plantes vivaces robustes incluent EMACS contre vi , mon ordinateur personnel contre l'ordinateur personnel de tout le monde, ad nauseam.La caractéristique qui distingue les guerres saintes des conflits techniques normaux est que, dans une guerre sainte, la plupart des participants passent leur temps à essayer de faire passer des choix de valeurs personnelles et des attachements culturels pour des évaluations techniques objectives.Cela se produit précisément parce que dans une véritable guerre sainte, les différences substantielles entre les parties sont relativement mineures.Voir aussi théologie .
                    
                    Comme indiqué dans l'entrée du fichier Jargon, l'une des guerres saintes les plus longues est menée entre les partisans de vi et son rival Emacs (parfois écrit « EMACS »), qui ont tous deux joué un rôle important dans la tradition informatique d'Unix.Les deux bénéficient également d'un large soutien populaire, même si je suppose qu'avec la popularité de Vim, vi a pris une avance décisive ces dernières années.Bien sûr, c’est exactement le genre de déclaration qui sert à perpétuer une guerre sainte, incitant probablement les partisans d’Emacs à, par exemple, faire des déclarations sur la puissance supérieure et la personnalisation de leur éditeur préféré.
                    
                    Si vous vouliez lancer une nouvelle guerre sainte, vous pourriez essayer quelque chose comme : « Heureusement, la guerre sainte entre vi et Emacs est désormais principalement une curiosité historique, car quiconque est quelqu'un est passé à un éditeur moderne comme Atom ou Sublime. »Ce sera un spectacle formidable, mieux vaut apporter du pop-corn ( Figure  1.5 ).
                 </p>
                 <p class="cycle spec"><img src="/ressources/e4.jpg" width="60" alt=""></p>
                 <p class="fig">Figure 1.5 : Regarder une guerre sainte se dérouler peut être divertissant.</p>
                  
                 <h2 id="trois">1.2.1Exercices</h2>
                 <p class="exo">1-Démarrez Vim dans un terminal, puis exécutez la commande Vim la plus importante™.</p>
                 <p class="exo">2-Redémarrez Vim dans un terminal.Avant de taper quoi que ce soit d’autre, tapez la chaîne « Ceci est un document Vim ».Ce qui s'est passé?C'est déroutant, n'est-ce pas ?</p>
                 <p class="exo">3-Utilisez la commande Vim la plus importante™ pour récupérer de l’exercice précédent et revenir à l’invite de ligne de commande normale.</p>
                 <button class="btn">Commencer: le chapitre</button>
                
                </div>
             
         </div>
 
        
        </section>
        <!-- 4 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="quatre">1.3 Édition de petits fichiers</h2>
                 <p class="lamda">Maintenant que nous connaissons la commande la plus importante de Vim™, nous allons commencer à apprendre à utiliser Vim pour de vrai en ouvrant et en modifiant un petit fichier.Dans la section  1.2 , nous avons commencé par l'exécuter vimseul, mais il est plus courant d'utiliser un nom de fichier comme argument.Naviguons jusqu'au répertoire personnel de notre système, puis exécutons une telle commande, qui ouvrira le fichier correspondant (s'il existe) ou le créera (s'il n'existe pas) :</p>
                 <p class="cod">
                    $ cd <br>
                    $ vim .bashrc
                 </p>
                 <p class="lamda">Voici .bashrcun fichier de configuration standard pour Bash.</p>
                 <p class="lamda">Comme indiqué ci-dessus, la vim .bashrccommande créera automatiquement le .bashrcfichier correspondant s'il n'existe pas déjà sur votre système.Ce fichier important est utilisé pour configurer le shell , qui est le programme qui fournit une ligne de commande, dans ce cas, Bash , qui est un pseudo-acronyme signifiant Bourne Again SHell (également écrit « Bourne-again shell »). 12(Rappelez-vous de l'encadré  1.3 que la valeur par défaut sur macOS est désormais Zsh, donc si vous êtes sur un Mac, vous devez suivre les instructions pour passer à Bash si vous ne l'avez pas déjà fait.)</p>
                 <p class="lamda">Comme c'est courant sur les systèmes basés sur Unix, le fichier de configuration de Bash commence par un point, indiquant (comme indiqué dans Apprendre une ligne de commande suffisamment dangereuse ) que le fichier est caché .Autrement dit, il n'apparaît pas par défaut lors de la liste du contenu du répertoire avec ls, ou même lors de la visualisation du répertoire à l'aide d'un navigateur de fichiers graphique.</p>
                 <p class="lamda">Nous apprendrons dans la section  1.4 comment enregistrer les modifications apportées à ce fichier, mais pour l'instant, nous allons simplement ajouter du contenu factice afin de pouvoir nous entraîner à nous déplacer.Dans la section  1.2 , nous avons appris que Vim démarre en mode normal, ce qui signifie que nous pouvons changer d'emplacement, supprimer du texte, etc.Passons en mode insertion pour ajouter du contenu.La première étape consiste à appuyer sur la itouche pour insérer du texte.Ensuite, tapez quelques lignes (séparées par des retours), comme indiqué dans la liste  1.3.13(Il peut y avoir d’autres contenus existants, que vous devriez simplement ignorer.)</p>
                 <p class="cod">
                    Liste 1.3 : Ajout de texte après la saisie ipour insérer. <br>
                    ~/.bashrc <br>
                    1 lorem ipsum <br>
                     2 dolor sit amet <br>
                     3 foo bar baz <br>
                     4 J'ai fait celui-ci plus long que d'habitude parce que je n'ai pas eu le temps de le faire plus court.
                 </p>
             
                  <p class="lamda">Après avoir saisi le texte dans la liste  1.3 , appuyez sur ESC(la touche Échap) pour passer du mode insertion au mode normal.</p>
                  <p class="lamda">Maintenant que nous avons du texte sur quelques lignes, nous pouvons apprendre quelques commandes pour déplacer de petits fichiers.(Nous aborderons certaines commandes permettant de naviguer dans des fichiers volumineux dans la section  1.6 .)Le moyen le plus simple de se déplacer est d’utiliser les touches fléchées (haut, bas, gauche, droite), ce que je recommande .Vim dispose littéralement de milliards de façons de se déplacer, et si vous décidez d'utiliser Vim comme éditeur de texte principal, je vous recommande de les apprendre, mais pour nos besoins, les touches fléchées conviennent parfaitement.Les deux seules commandes supplémentaires que je considère comme essentielles sont celles qui permettent de se déplacer au début et à la fin de la ligne, qui sont respectivement 0et $.</p>
                  <h2 id="cinq">1.3.1 Exercices</h2>
                  <p class="exo">1-Utilisez les touches fléchées pour accéder à la ligne 4 du fichier de la liste  1.3</p>
                  <p class="exo">2-Utilisez les touches fléchées pour aller jusqu'à la fin puis au début de la ligne 4.Encombrant, hein ?
                </p>
                  <p class="exo">3-Allez au début de la ligne 4 en utilisant la commande mentionnée dans le texte</p>
                  <p class="exo">4-Allez à la fin de la ligne 4 en utilisant la commande mentionnée dans le texte.</p>
             
                  <button class="btn">Commencer: le chapitre</button>
             
                </div>
             
         </div>
 
        
        </section>
        <!-- 6 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="six">1.4Sauvegarde et fermeture des fichiers</h2>

                  <p class="lamda">Après avoir appris un peu comment se déplacer et insérer du texte, nous allons maintenant apprendre à enregistrer un fichier.Notre exemple spécifique impliquera la création d'une nouvelle commande Bash utile, mais nous devons d'abord gérer l'état actuel du fichier de profil Bash.Le texte que nous avons ajouté dans la liste  1.3 est du charabia (du moins du point de vue de Bash), donc ce que nous aimerions faire est de quitter le fichier sans enregistrer aucune modification.Pour des raisons historiques , certaines commandes Vim (en particulier celles liées à la manipulation de fichiers) commencent par deux points  :, et la manière normale de quitter un fichier est d'utiliser deux points :q<return>, mais cela ne fonctionne que lorsqu'il n'y a aucune modification à enregistrer.Dans le cas présent, nous obtenons le message d’erreur « Aucune écriture depuis la dernière modification (ajoutez ! pour remplacer) », comme illustré dans la Figure  1.6 .</p>
                  <p class="cycle spec"><img src="/ressources/e5.png" alt=""></p>
                  <p class="fig">Figure 1.6 : Tentative de fermeture d’un fichier avec des modifications non enregistrées.</p>
                  <p class="lamda">En suivant les conseils du message, nous pouvons taper :q!<return>pour forcer Vim à quitter sans enregistrer les modifications ( Figure  1.7 ), ce qui nous ramène à la ligne de commande.</p>
                  <p class="cycle spec"><img src="/ressources/e6.png" alt=""></p>
                  <p class="fig">Figure 1.7 : Forcer Vim à quitter.</p>
                  <p class="lamda">Vous avez peut-être remarqué que nous sommes maintenant en mesure de comprendre la commande Vim™ la plus importante introduite dans la section  1.2 : peu importe les choses terribles que vous avez pu faire à un fichier, tant que vous tapez ESC(pour sortir du mode insertion si nécessaire) 16 suivi de :q!<return>(pour forcer la fermeture), vous êtes assuré de ne faire aucun dommage.</p>
                  <p class="lamda">Bien sûr, Vim n'est vraiment utile que si nous pouvons enregistrer nos modifications, alors ajoutons du texte utile, puis écrivons le résultat.Comme dans la section  1.3 , nous travaillerons sur le .bashrcfichier, et la modification que nous effectuerons ajoutera un alias à notre shell.Dans un contexte informatique, un alias est simplement un synonyme d'une commande ou d'un ensemble de commandes.L'utilisation principale des alias Bash est de définir des commandes plus courtes pour les combinaisons couramment utilisées .</p>
                  <p class="lamda">Dans ce cas, nous définirons la commande lr(abréviation de « list reverse ») comme un alias pour ls -hartl, qui est la commande permettant de lister les fichiers et les répertoires en utilisant des valeurs lisibles par l' homme pour les tailles (par exemple, 29 Ko au lieu de 29 592 pour un fichier de 29 kilo-octets), y compris tous (même ceux cachés), classés par temps inverse , forme longue .Cette commande, que vous avez peut-être reconnue dans un exercice de Learn Enough Command Line to Be Dangerous , est utile pour voir quels fichiers et répertoires ont récemment changé (en plus d'être, pour des raisons évidentes, l'un de mes favoris personnels).Après avoir défini l'alias, nous pourrons remplacer le plus verbeux</p>
                  <p class="cod">$ ls -hartl</p>
                  <p class="lamda">avec le plus concis</p>
                  <p class="cod">$ lr</p>
                
                  <p class="lamda">
                    Les étapes se présentent comme suit : <br>

                    1-Appuyez ipour entrer en mode insertion. <br>
                    2-Saisissez le contenu indiqué dans la liste  1.4 .(Sur certains systèmes, le .bashrcfichier peut inclure du contenu préexistant, que vous pouvez simplement laisser en place.) <br>
                    3-Appuyez ESCpour quitter le mode d'insertion. <br>
                    4-Écrivez le fichier en utilisant :w<return>. <br>
                    5-Quittez Vim en tapant :q<return>.
                  </p>
                
                  <p class="lamda">Remarque : si vous faites des erreurs, vous pouvez taper ESCsuivi de upour annuler l'une des étapes précédentes.(La plupart des programmes utilisent Commande-Z ou Ctrl-Z pour annuler des choses, un autre exemple de raccourcis clavier non natifs utilisés par Vim.En revanche, les éditeurs évoqués à partir du chapitre  2 prennent tous en charge les raccourcis clavier natifs.)</p>
                  <p class="cod">
                    Liste 1.4 : Définition d’un alias Bash. <br>
                    ~/.bashrc <br>
                    alias  lr = 'ls -hartl'
                  </p>
                  <p class="lamda">Après avoir ajouté l' lralias à .bashrc, écrit le fichier et quitté, vous serez peut-être surpris de constater que la commande ne fonctionne pas encore :</p>
                  <p class="cod">
                    $ lr  <br>
                    -bash : lr : commande non trouvée
                  </p>
                  <p class="lamda">C'est parce que nous devons informer le shell du fichier de profil Bash mis à jour en le « sourçant » à l'aide de la sourcecommande, comme indiqué dans la liste  1.5</p>
                  <p class="cod">
                    Liste 1.5 : Activation de l’alias en sourçant le profil Bash. <br>
                    $ source .bashrc
                  </p>
                  <p class="lamda">Avec cela, la lrcommande devrait fonctionner comme annoncé :</p>
                  <p class="cod">
                    $ lr <br>
                    . <br>
                   . <br>
                   . <br>
                   drwx------+ 15 mhartl staff 510B 4 sept. 18:58 Bureau <br>
                   -rw------- 1 mhartl staff 13K 4 sept. 19:13 .viminfo <br>
                   -rw-r--r-- 1 mhartl staff 46B 4 sept. 19:14 .bashrc <br>
                   drwxr-xr-x+ 117 mhartl staff 3.9K 4 sept. 19:14 .

                  </p>
                  <p class="lamda">Au fait, le .bashrcfichier est sourcé automatiquement lorsque nous ouvrons un nouvel onglet ou une nouvelle fenêtre de terminal, donc un sourçage explicite n'est nécessaire que lorsque nous voulons qu'une modification soit reflétée dans le terminal actuel .</p>
                  <h2 id="sept">1.4.1 Exercices</h2>
                  <p class="exo">1-Définissez un alias gpour la fonction grep insensible à la casse grep -i couramment utilisée .Que se passe-t-il si, après avoir effectué vos modifications et appuyé sur ESC, vous émettez la commande :wqau lieu de :wet :qséparément ?</p>
                  <p class="exo">2-Vous vous souvenez peut-être de la curlcommande de Learn Enough Command Line to Be Dangerous , qui nous permet d'interagir avec les URL via la ligne de commande.Définir getcomme alias pour curl -OL, qui est la commande permettant de télécharger un fichier sur le disque local (tout en suivant les redirections rencontrées en cours de route).</p>
                  <p class="exo">3-Utilisez l'alias de l'exercice précédent pour exécuter la commande affichée dans la liste  1.6 , qui télécharge un fichier texte plus long à utiliser dans la section  1.6 .</p>
                  <p class="cod">
                    Liste 1.6 : Téléchargement d’un fichier texte plus long à utiliser dans une section ultérieure. <br>
                    $ obtenir cdn.learnenough.com/sonnets.txt
                  </p>
                  <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
        </section>
        <!-- 7 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="huit">1.5 Suppression de contenu</h2>
                 <p class="lamda">Comme pour chaque catégorie de manipulation de texte, Vim dispose d'un nombre énorme de commandes pour supprimer du contenu, mais dans cette section, nous allons simplement couvrir le strict minimum.Nous commencerons par supprimer des caractères individuels, ce que nous pouvons faire en mode normal à l'aide de la xcommande :</p>
                  <p class="lamda">
                    1-Ouvrez .bashrcet insérez le mot mal orthographié aliaes. <br>
                    2-Revenez au mode normal en appuyant sur ESC. <br>
                    3-Déplacez le curseur sur l' eentrée aliaes( Figure  1.8 ) et appuyez sur x.
                  </p>
                <p class="cycle spec"><img src="/ressources/e7.png" alt=""></p>
                <p class="fig">Figure 1.8 : Préparation de la suppression d’une lettre à l’aide de x.</p>
                <p class="lamda">Il existe de nombreuses façons sophistiquées de supprimer du texte, mais en appuyant plusieurs fois, xil est facile (même si c'est un peu fastidieux) de supprimer des mots entiers ou même des lignes entières.En revanche, la suppression de lignes est un cas suffisamment particulier pour mériter d’être inclus.Débarrassons-nous du supplément que aliasnous avons ajouté en appuyant sur ddpour supprimer la ligne.Voilà  !Il devrait avoir disparu ( Figure  1.9 ).Pour le récupérer, vous pouvez appuyer psur « mettre » la ligne, ce qui vous permet également de simuler le copier-coller d’une ligne à la fois.(Encore une fois, il s'agit d'un sous-ensemble minimal de Vim ; si vous décidez de vous y perfectionner, vous apprendrez de nombreuses meilleures façons de faire les choses.)</p>
                <p class="cycle spec"><img src="/ressources/e8.png" alt=""></p>
                <p class="fig">Figure 1.9 : Résultat de la suppression d'une ligne avec dd.</p>
                <h2 id="neuf">1.5.1 Exercices</h2>
                <p class="exo">1-À l’aide de Vim, ouvrez un nouveau fichier </p>
                <p class="exo">2-Insérez la chaîne « Un léopard ne peut pas changer ses taches. » ( Figure  1.10 ).</p>
                <p class="exo">3-A l'aide de la xtouche , supprimez le caractère nécessaire pour corriger l'erreur dans la ligne que vous venez de saisir.(Si vous ne trouvez pas l’erreur, reportez-vous au tableau  1.1 .)</p>
                <p class="exo">4-Utilisez ddpour supprimer la ligne, puis utilisez ppour la coller à plusieurs reprises dans le document.
                </p>
                <p class="exo">5-Enregistrez le document et quittez en utilisant une seule commande. Astuce : voir le premier exercice de la section  1.4.1 .</p>

                <p class="cycle spec"><img src="/ressources/e9.jpg" alt=""></p>
                <p class="fig">Figure 1.10 : Les capacités de cet animal à changer de tache sont fréquemment remises en question.</p>


                <button class="btn">Commencer: le chapitre</button>

             </div>
             
         </div>
 
         
        </section>
        <!-- 8 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="dix">1.6 Modification de fichiers volumineux</h2>
                 <p class="lamda">Les compétences finales nécessaires pour votre Vim minimum viable impliquent la navigation dans des fichiers volumineux.Si vous n'avez pas téléchargé sonnets.txtles exercices de la section  1.4 , vous devriez le faire maintenant ( liste  1.7 ).</p>
                   <p class="cod">
                    Liste 1.7 : Téléchargement des sonnets de Shakespeare . <br>
                    $ curl -OL https://cdn.learnenough.com/sonnets.txt
                   </p>

                  <p class="lamda">Le fichier résultant contient le texte intégral des Sonnets de Shakespeare , qui compte 2620 lignes, 17670 mots et 95635 caractères, ce que nous pouvons vérifier à l'aide de la commande de comptage de mots  wc décrite dans Apprendre une ligne de commande suffisamment dangereuse :</p>
                  <p class="cod">
                    $ wc sonnets.txt <br>
                    2620 17670 95635 sonnets.txt
                  </p>
                  <p class="lamda">Sur de nombreux systèmes, Vim affiche certaines des mêmes statistiques de base lors de l'ouverture du fichier :</p>
                  <p class="cod">
                    $ vim sonnets.txt
                  </p>
                  <p class="lamda">Le résultat sur mon système apparaît dans la Figure  1.11 .En raison de sa longueur, ce fichier est beaucoup trop long pour être parcouru facilement à la main.</p>
                  <p class="cycle spec"><img src="/ressources/e10.png" alt=""></p>
                  <p class="fig">Figure 1.11 : Quelques statistiques de fichiers affichées au démarrage de Vim.</p>
                  
                  <p class="cod"></p>
                  <p class="lamda">Comme auparavant, il existe de nombreuses commandes pour se déplacer, mais je trouve que les plus utiles impliquent de déplacer un écran à la fois, de se déplacer au début ou à la fin, ou d'effectuer une recherche.Les commandes pour déplacer un écran à la fois sont Ctrl-F (Avant) et Ctrl-B (Arrière).Pour aller à la fin du fichier, nous pouvons utiliser G, et pour aller au début, nous pouvons utiliser 1G.Enfin, la commande de navigation la plus puissante est peut-être la recherche , qui consiste à taper une barre oblique  /suivie de la chaîne que vous souhaitez rechercher.L'astuce consiste à taper /<string>suivi de retour, puis à appuyer npour passer à la correspondance suivante (le cas échéant).</p>
                  <p class="cod"></p>
                  <p class="lamda">Tout cela peut sembler un peu familier, car c'est la même que l'interface du lessprogramme abordé dans Apprendre suffisamment de ligne de commande pour être dangereux .C’est l’un des avantages de l’apprentissage des commandes Unix de base : de nombreux modèles se reproduisent dans de nombreux contextes différents.</p>
                  <p class="cod"></p>
                  
                  <h2 id="onze">1.6.1 Exercices</h2>
                  <p class="exo">1-Avec sonnets.txtouvert dans Vim, descendez de trois écrans, puis remontez de trois écrans.</p>
                  <p class="exo">2-Aller à la fin du fichier.Quelle est la dernière ligne du sonnet final ?</p>
                  <p class="exo">3-Revenez en haut pour changer l’ancien nom « Shakespeare » sur la ligne 1 en sonnets.txt« Shakespeare » plus moderne, et enregistrez le résultat.</p>
                  <p class="exo">4-Utilisez la fonction de recherche de Vim pour découvrir quel sonnet contient des références à Cupidon, le dieu romain de l'amour.</p>
                  <p class="exo">5-Confirmez que cela 18Gva à la dernière ligne du premier sonnet.Que pensez-vous que fait cette commande ? Astuce : rappelez-vous que cela 1Gva au début du fichier, c'est-à-dire à la ligne 1.</p>



                  <button class="btn">Commencer: le chapitre</button>

             </div>
             
         </div>
 
        </section>
        <!-- 9 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="douze">1.7 Résumé</h2>
                 <p class="lamda">Les commandes importantes de ce chapitre sont résumées dans le tableau  1.1 .Si vous souhaitez en savoir plus sur Vim, taper « learn vim » dans un moteur de recherche est une bonne idée.Le didacticiel interactif Vim est particulièrement recommandé.</p>
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Commande</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Description</font></font></strong></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ESC:q!&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">La commande Vim la plus importante™</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">i</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Quitter le mode normal, entrer en mode insertion</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ESC</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Quitter le mode insertion, entrer en mode normal</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Touches fléchées</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Se déplacer</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">0</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Aller au début de la ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">$</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Aller jusqu'au bout de la ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">:w&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Enregistrer (écrire) un fichier</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">:q&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Quitter un fichier (doit être enregistré)</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">:wq&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Écrire et quitter un fichier</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">:q!&lt;return&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Forcer la fermeture d'un fichier, en annulant toutes les modifications</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">u</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Défaire</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">x</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Supprimer le caractère sous le curseur</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">dd</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Supprimer une ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">p</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Coller le texte supprimé</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">it’s spots</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Non, tu veux dire</font></font><code class="tt">its spots</code>
                    </td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">Ctrl-F</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Avancer d'un écran</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">Ctrl-B</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Revenir à l'écran précédent</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">G</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Aller à la dernière ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">1G</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Aller à la première ligne</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">/&lt;string&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Rechercher</font></font><code class="tt">&lt;string&gt;</code>
                    </td>
                    </tr>
                    </tbody>
                    </table>

                    <h2 id="treize">1.7.1 Exercices</h2>
                    <p class="exo">1-Ouvrir sonnets.txt</p>
                    <p class="exo">2-Allez à la dernière ligne</p>
                    <p class="exo">3-Allez jusqu'à la fin de la dernière ligne</p>
                    <p class="exo">4-Créez une nouvelle ligne qui dit « C'est tout, les amis !Barde dehors.<laisse tomber le micro>”.Assurez-vous de déplacer le curseur d'un espace vers la droite afin de ne pas faire glisser le point final.</p>
                    <p class="exo">5-Écrivez le fichier.</p>
                    <p class="exo">6-Annulez vos modifications.</p>
                    <p class="exo">7-Écrivez et quittez le fichier</p>
                    <p class="exo">8-Rouvrez le fichier et tapez 2620dd</p>
                    <p class="exo">9-Sachez que vous venez de supprimer l'intégralité du contenu du fichier et appliquez la commande Vim la plus importante™ pour vous assurer qu'aucun dommage n'est causé.</p>
                    <button class="btn">Commencer: le chapitre</button>
             
                </div>
             
         </div>
 
        </section>
        <!-- 10 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3 id="chap2">Chapitre 2 </h3>
                 <h2 id="quatorze">Modern text editors</h2>
                <p class="lamda">Having learned the minimal basics of text editing with Vim, we’re now in a good position to appreciate the preferred “modern” text editors mentioned at the beginning of this tutorial. These editors include cross-platform native editors such as Sublime Text, Visual Studio Code, and Atom, and editors in the cloud like Cloud9. Modern editors are distinguished by their combination of power and ease of use: you can do fancy things like global search-and-replace, but (unlike Vim) they let you just click in a window and start typing. In addition, many of them (including Atom and Sublime) include an option to run in Vim compatibility mode, so even if you end up loving Vim you can still use a modern editor without having to give Vim up entirely.</p>
                <p class="lamda">Throughout the rest of this tutorial, we’ll explore the capabilities of modern text editors. We’ll end up covering all of the topics encountered in our discussion of Vim (Chapter 1), as well as many more advanced subjects, including opening files, moving around, selecting text, cut/copy/paste, deleting and undoing, saving, and finding/replacing—all of which are important for day-to-day editing. We’ll also discuss both menu items and keyboard shortcuts, which help make your text editing faster and more efficient.</p>
                <p class="lamda">For future reference, Table 2.1 shows the symbols for the various keys on a typical Macintosh keyboard. Apply your technical sophistication (Box 1.2) if your keyboard differs.</p>
                
                <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong>Key</strong></td>
                    <td class="align_left"><strong>Symbol</strong></td>
                    </tr>
                    <tr>
                    <td class="align_left">Command</td>
                    <td class="align_left">⌘</td>
                    </tr>
                    <tr>
                    <td class="align_left">Control</td>
                    <td class="align_left">⌃</td>
                    </tr>
                    <tr>
                    <td class="align_left">Shift</td>
                    <td class="align_left">⇧</td>
                    </tr>
                    <tr>
                    <td class="align_left">Option</td>
                    <td class="align_left">⌥</td>
                    </tr>
                    <tr>
                    <td class="align_left">Up, down, left, right</td>
                    <td class="align_left">↑ ↓ ← →</td>
                    </tr>
                    <tr>
                    <td class="align_left">Enter/Return</td>
                    <td class="align_left">↵</td>
                    </tr>
                    <tr>
                    <td class="align_left">Tab</td>
                    <td class="align_left">⇥</td>
                    </tr>
                    <tr>
                    <td class="align_left">Delete</td>
                    <td class="align_left">⌫</td>
                    </tr>
                    </tbody>
                    </table>
                
                    <p class="fig">Table 2.1: Miscellaneous keyboard symbols.</p>
            
            
            
                    <button class="btn">Commencer: le chapitre</button>
            </div>
             
         </div>
 
         
        </section>
        <!-- 11 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="quinze">2.1 Choosing a text editor</h2>
                 <p class="lamda">While cloud IDEs have many advantages, every aspiring computer magician should learn at least one native editor (i.e., an editor that runs on your desktop operating system). While there are many editors to choose from, probably the most promising modern text editors in use today are Sublime Text (sometimes just called “Sublime”), Visual Studio Code (VScode), and Atom.1 Each has its own advantages and disadvantages.</p>
                 <h2 id="seize">2.1.1 Sublime Text</h2>
                <p class="lamda">
                    <h3>Advantages</h3> <br>
                    1-Powerful, hackable, and easy to use <br>
                    2-Can be used for free in “evaluation mode” <br>
                    3-Fast and robust, even when editing huge files/projects <br>
                    4-Works cross-platform (Windows, macOS, Linux) <br>
                    5-Backed by a profitable company that has a good track record of support and development
                    Disadvantages
                    Free in neither the speech nor beer sense
                    Has a mildly annoying popup that goes away only if you buy a license
                    Costs $70 as of this writing
                    Setting up command-line tools takes some fiddling
                    2.1.2Visual Studio Code (VSCode)
                    Advantages
                    Powerful, with lots of packages
                    Free to use
                    Fast and robust, even when editing huge files/projects
                    Works cross-platform (Windows, macOS, Linux)
                    Backed by Microsoft
                    Disadvantages
                    Not open-source
                    Backed by Microsoft
                    2.1.3Atom
                    Advantages
                    Powerful, hackable, and easy to use
                    Free in both the speech and beer senses (i.e., it both costs nothing and is open-source software)
                    Works cross-platform (Windows, macOS, Linux)
                    Easy to set up command-line tools
                    Backed by collaboration powerhouse GitHub
                    Disadvantages
                    Reports of being slower in some cases than Sublime or VSCode
                    Since GitHub’s acquisition by Microsoft, backed by Microsoft
                    Archived by GitHub (see details below)
                    It’s hard to go wrong with any of these choices. Because of its simplicity and being 100% free, I used to recommend Atom as the best choice for new users. As discussed briefly in Chapter 1, though, in June 2022 GitHub announced plans to archive the Atom project in the blog post “Sunsetting Atom”. Because Atom is open-source, it’s likely that it will continue to be available in some form, but under the circumstances readers of this tutorial are especially encouraged to consider Visual Studio Code or Sublime Text as alternatives. Due to the difficulty of updating videos, the screencasts that accompany this tutorial still use Atom, but the screenshots and main examples in the written text now use Sublime Text, which is actually my main day-to-day editor. (Luckily, Sublime Text and Atom are nearly identical in many respects, even down to the exact keyboard shortcuts.)
                    
                    The good news is that the skills in the sections that follow are near-universal; if you learn Atom but decide to switch to Sublime Text or VSCode (or even a cloud IDE) for your daily editing, most of the core ideas will translate easily. It is precisely because of unpredictable events like the sunsetting of Atom that Learn Enough Text Editor to Be Dangerous focuses on such general principles rather than on specific editors. As a result, the examples in this tutorial that happen to use Atom are still relevant despite this development. It also underscores the critical importance of technical sophistication (Box 1.2), which allows you to adapt to such changes without significant difficulty.
                    
                    2.1.4Exercises
                    Install and configure a text editor on your system as follows:
                    
                    Download and install either Sublime Text, Visual Studio Code, or Atom.
                     View all  ( 91 ) Add Answer
                    If using Sublime Text, set up the subl command by Googling for “sublime text command line” and following the instructions for your system. Apply your technical sophistication (Box 1.2) if you get stuck. You might also find it helpful to skip ahead to Section 3.3 to learn about how to configure your system’s path.
                     View all  ( 71 ) Add Answer
                    If using VSCode, set up the code command by Googling for “visual studio code command line” and following the instructions for your system.
                     View all  ( 38 ) Add Answer
                    If using Atom, go to Atom > Install Shell Commands to enable the atom command at the command line (Figure 2.1).
                     View all  ( 76 ) Add Answer
                    images/figures/install_atom_shell_commands
                    Figure 2.1: Installing Atom’s shell commands.
                    NEXT: 2.2 Opening
                    Join the Mailing List
                    Get occasional notifications about things like product discounts, blog posts, and new or updated tutorials. Unsubscribe at any time.
                    
                    Email Address
                     Subscribe
                     LEARN ENOUGH
                    Your Courses
                    Downloads
                    For Teams
                    Account
                    Log Out
                    All Access
                    The Rails Tutorial
                    Our Philosophy
                    About
                    News
                    Why Use Ruby on Rails?
                    Why Use the Ruby Language?
                    Why Program?
                    Why Understand Devs?
                    For Beginners
                    Legal
                    Contact
                    Learn Enough
                     
                     Rails Tutorial
                    All Access Subscription
                    Get free access to all 10 Learn Enough courses (including the Ruby on Rails Tutorial) for 7 days!
                    
                    Free 7 Day trial details
                    We require a credit card for security purposes, but it will not be charged during the trial period. After 7 days, you will be enrolled automatically in the monthly All Access subscription.
                    
                    BUT you can cancel any time and still get the rest of the 7 days for free!
                    
                    All Learn Enough tutorials come with a 60-day 100% money-back guarantee.
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    Billed Yearly
                    Save up to 20%
                    Billed Monthly
                    Monthly Cost: $39
                    
                    Billed $ 468.0 Anually
                     Add to Cart : Free Trial
                    MORE INFO   
                    
                     <br>
                   <h3>Disadvantages</h3> <br>
                    1-Free in neither the speech nor beer sense <br>
                    2-Has a mildly annoying popup that goes away only if you buy a license <br>
                    3-Costs $70 as of this writing <br>
                    4-Setting up command-line tools takes some fiddling

               </p>
               <h2 id="dixsept">2.1.2 Visual Studio Code (VSCode)</h2>
               <p class="lamda">
                   <h3>Advantages</h3> <br>
                   1-Powerful, with lots of packages<br>
                   2-Free to use <br>
                   3-Fast and robust, even when editing huge files/projects <br>
                   4-Works cross-platform (Windows, macOS, Linux) <br>
                   5-Backed by Microsoft <br>
                  <h3>Disadvantages</h3> <br>
                   1-Not open-source <br>
                   2-Backed by Microsoftt <br>
                

              </p>
                
                
                
                 <h2 id="dixhuit">2.1.3 Atom</h2>
                <p class="lamda">
                    <h3>Advantages</h3> <br>
                    1-Powerful, hackable, and easy to use <br>
                    2-Free in both the speech and beer senses (i.e., it both costs nothing and is open-source software) <br>
                    3-Works cross-platform (Windows, macOS, Linux) <br>
                    4-Easy to set up command-line tools <br>
                    5-Backed by collaboration powerhouse GitHub <br>
                   <h3>Disadvantages</h3> <br>
                    1-Reports of being slower in some cases than Sublime or VSCode <br>
                    2-Since GitHub’s acquisition by Microsoft, backed by Microsoft <br>
                    3-Archived by GitHub (see details below)

               </p>
                   <p class="lamda">It’s hard to go wrong with any of these choices. Because of its simplicity and being 100% free, I used to recommend Atom as the best choice for new users. As discussed briefly in Chapter 1, though, in June 2022 GitHub announced plans to archive the Atom project in the blog post “Sunsetting Atom”. Because Atom is open-source, it’s likely that it will continue to be available in some form, but under the circumstances readers of this tutorial are especially encouraged to consider Visual Studio Code or Sublime Text as alternatives. Due to the difficulty of updating videos, the screencasts that accompany this tutorial still use Atom, but the screenshots and main examples in the written text now use Sublime Text, which is actually my main day-to-day editor. (Luckily, Sublime Text and Atom are nearly identical in many respects, even down to the exact keyboard shortcuts.)</p>
                 
                   <p class="lamda">The good news is that the skills in the sections that follow are near-universal; if you learn Atom but decide to switch to Sublime Text or VSCode (or even a cloud IDE) for your daily editing, most of the core ideas will translate easily. It is precisely because of unpredictable events like the sunsetting of Atom that Learn Enough Text Editor to Be Dangerous focuses on such general principles rather than on specific editors. As a result, the examples in this tutorial that happen to use Atom are still relevant despite this development. It also underscores the critical importance of technical sophistication (Box 1.2), which allows you to adapt to such changes without significant difficulty.</p>

                 <h2 id="dixneuf">2.1.4 Exercises</h2>
                 <p class="lamda">Install and configure a text editor on your system as follows:</p>
                <p class="exo">1-Install and configure a text editor on your system as follows:</p>
                <p class="exo">2-If using Sublime Text, set up the subl command by Googling for “sublime text command line” and following the instructions for your system. Apply your technical sophistication (Box 1.2) if you get stuck. You might also find it helpful to skip ahead to Section 3.3 to learn about how to configure your system’s path.</p>
                <p class="exo">3-If using VSCode, set up the code command by Googling for “visual studio code command line” and following the instructions for your system.</p>
                <p class="exo">4-If using Atom, go to Atom > Install Shell Commands to enable the atom command at the command line (Figure 2.1).</p>
               <p class="cycle spec"><img src="/ressources/e11.png" alt=""></p>
               <p class="fig">Figure 2.1: Installing Atom’s shell commands.</p>

               <button class="btn">Commencer: le chapitre</button>


             </div>
             
         </div>
 
         
        </section>
        <!-- 12 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="vin">2.2 Opening</h2>
                <p class="lamda">To open files, we’re going to use the command configured in Section 2.1.4 to launch the editor and open the file at the same time (a method we used with vim in Section 1.3). In Section 3.4, we’ll cover a second method (called “fuzzy opening”) that’s useful when editing a project with multiple files. I’ll assume you’re using the subl command, but if you’re using a different editor you should make the appropriate substitution (e.g., atom or code in place of subl).</p>
                <p class="lamda">Let’s get started by downloading a sample file, README.md, from the Web. As in Section 2.7.1 and Section 1.6, we’ll use the curl command to download the file at the command line:</p>
                <p class="cod">
                    Listing 2.1: Downloading the README with curl. <br>
                    $ curl -OL https://cdn.learnenough.com/README.md
                </p>
                
                <p class="lamda">As hinted at by the .md extension, the downloaded file is written in Markdown, a human-readable markup language designed to be easy to convert to HTML, the language of the World Wide Web.</p>
                <p class="lamda">After downloading README.md, we can open it at the command line as follows:</p>
                <p class="cod">$ subl README.md</p>
                <p class="lamda">(If this doesn’t work, be sure you’ve installed the Sublime Text shell commands as shown in Section 2.1.4.) The result of opening README.md in Sublime Text should look something like Figure 2.2 or Figure 2.3. (If this is your first time opening Sublime Text, it’s also possible you’ll see a one-time greeting screen. As usual, apply Box 1.2.) Figure 2.2 shows the usual default, which is for “word wrap” to be off; because Markdown files are typically written using a long line for each paragraph, this setting isn’t ideal in this case, so I recommend turning on word wrap using the menu item shown in Figure 2.4.</p>
                <p class="cycle spec"><img src="/ressources/e12.png" width="60"  alt=""></p>
                <p class="fig">Figure 2.2: The sample file with word wrap off.</p>
                <p class="cycle spec"><img src="/ressources/e13.png" alt=""></p>
                <p class="fig">Figure 2.3: The sample file with word wrap on.</p>
                <p class="cycle spec"><img src="/ressources/e14.png" alt=""></p>
                <p class="fig">Figure 2.4: The menu item to toggle word wrap.</p>
                <p class="lamda">In some editors, such as the cloud IDE at Cloud9, it’s more common to open files using the filesystem navigator (although in fact the c9 command can be used to open files at the Cloud9 command line).2 Double-clicking on README.md in the filesystem navigator (Figure 2.5) opens the file in Cloud9’s editor, as shown in Figure 2.6. (If your results don’t match, be sure you’ve run the curl command shown in Listing 2.1.) Figure 2.7 shows the file after clicking Navigate to close the filesystem navigator, and we see that, as in Figure 2.2, the line extends inconveniently off the screen. We can fix this using View > Wrap Lines as shown in Figure 2.8, with the word-wrapped result appearing as in Figure 2.9. (Figuring out that a menu item like View > Wrap Lines turns on word wrap is exactly the kind of thing you should be able to figure out using your technical sophistication (Box 1.2).)</p>
                <p class="cycle spec"><img src="/ressources/e15.png" alt=""></p>
                <p class="fig">Figure 2.5: The Cloud9 filesystem navigator.</p>
                <p class="cycle spec"><img src="/ressources/e16.png" alt=""></p>
                <p class="fig">Figure 2.6: Cloud9 after double-clicking on README.md.</p>
                <p class="cycle spec"><img src="/ressources/e17.png" alt=""></p>
                <p class="fig">Figure 2.7: Cloud9 with word wrap off.</p>
                <p class="cycle spec"><img src="/ressources/e18.png" alt=""></p>
                <p class="fig">Figure 2.8: Turning word wrap on in Cloud9.</p>
                <p class="cycle spec"><img src="/ressources/e19.png" alt=""></p>
                <p class="fig">Figure 2.9: Cloud9 with word wrap on.</p>
                <h2 id="vinun">2.2.1 Syntax highlighting</h2>
                <p class="lamda">One thing you may have noticed from inspecting Figure 2.3 and Figure 2.9 is that both Sublime Text and Cloud9 display different aspects of the file in different colors. For example, Sublime Text shows characters inside square brackets [] (which represent text for HTML links) in a lighter color than the rest of the text, while Cloud9 shows the same text in green. This is a practice known as syntax highlighting, which makes special text formatting much easier to identify visually. It’s essential to understand that this practice is strictly for our benefit; as far as the computer is concerned, the document in question is still plain text.</p>
                <p class="lamda">You might wonder how Sublime Text and Cloud9 knew which highlighting scheme to use. The answer is that they infer the document format from the file type extension (in this case, .md for Markdown). The highlighting in Cloud9’s case is quite high-contrast, but in Sublime Text’s case it isn’t particularly prominent; the most significant things are the different colors for the heading</p>
                 <p class="cod"># Sample document</p>
                 <p class="lamda">and for links like</p>
                 <p class="cod">[Michael Hartl](https://www.michaelhartl.com/)</p>
                 <p class="lamda">We’ll see more dramatic examples of syntax highlighting in Section 2.7 and especially in Section 3.2.

                 </p>
                 <h2 id="vindeux">2.2.2Previewing Markdown</h2>
                 <p class="lamda">As a final trick, I’d like to note that some editors can preview Markdown as HTML. This section uses Atom because its Markdown previewer is especially easy to use, but see Section 3.5 for information on how to configure Sublime Text to do the same thing.</p>
                 <p class="lamda">We can figure out how to preview Markdown with Atom using our technical sophistication (Box 1.2), in this case by clicking on the Help menu and searching for “Preview” (Figure 2.10). The result is a built-in package called Markdown Preview, which converts Markdown to HTML and shows the result, as seen in Figure 2.11. In this context, it’s convenient to work with an expanded width so that both the source and the preview are wide enough to view easily, as seen in Figure 2.12. This is accomplished by mousing over the side of the Atom window to get a double-arrow icon and then dragging to increase the size. We’ll see another example of this “double-paned” setup in a more general setting starting in Section 3.4.</p>
                 <p class="cycle spec"><img src="/ressources/e120.png" alt=""></p>
                 <p class="fig">Figure 2.10: Using the Help menu to learn how to preview Markdown.</p>
                 <p class="cycle spec"><img src="/ressources/e21.png" alt=""></p>
                 <p class="fig">Figure 2.11: A Markdown preview in Atom.</p>
                 <p class="cycle spec"><img src="/ressources/e22.png" alt=""></p>
                 <p class="fig">Figure 2.12: Using a wider window for the source and preview.</p>

               <h2 id="vintrois">2.2.3Exercises</h2>

                <p class="exo">1-By applying the methods in Box 1.2, find an online Markdown previewer (i.e., one that runs in a web browser), and use it to look at a preview of README.md. How do the results compare to Figure 2.11?</p>
                <p class="exo">2-Open a new document called lorem.txt and fill it with the text shown in Listing 2.2. Does the result have syntax highlighting?</p>
                <p class="exo">3-Open a new document called test.rb and fill it with the text shown in Listing 2.3. Does the result have syntax highlighting?</p>
                <p class="cod">
                    Listing 2.2: Some lorem ipsum text. <br>
                    ~/lorem.txt <br>
                    Lorem ipsum dolor sit amet
                </p>
                <p class="cod">
                    Listing 2.3: A test file. <br>
                    ~/test.rb <br>
                    puts "test"
                </p>

                <button class="btn">Commencer: le chapitre</button>

             </div>
             
         </div>
 
         
        </section>
        <!-- 13 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="vinquatre">2.3 Moving</h2>

                    <p class="lamda">Unlike the commands for moving around in Vim (Chapter 1, summarized in Table 1.1), the commands for moving around in modern editors generally match the techniques used in other programs such as word processors, email programs, and web browsers. As a result, it’s possible you may already know some or all of these techniques; if you don’t, by following the steps in this section you’ll get better at navigating other programs as a side effect.</p>

                     <p class="lamda">To get started, let’s open the large file from Section 1.6 consisting of the full text of Shakespeare’s Sonnets:</p>
                     <p class="cod">$ subl sonnets.txt</p>
                     <p class="lamda">(If this doesn’t work, you may need to run the command in Listing 1.7, and you should also verify that you’re in the right directory.) The result appears in Figure 2.13. Note that Figure 2.13 shows sonnets.txt in its own tab, with README.md from Section 2.2 occupying the other tab. Your result may vary; in any case, we’ll discuss tabs further in Section 3.4.</p>

                      <p class="cycle spec"><img src="/ressources/e23.png" alt=""></p>
                      <p class="fig">Figure 2.13: Opening Shakespeare’s Sonnets in a text editor.</p>
                      <p class="lamda">As with most other native programs such as word processors, web browsers, etc., you can move around a modern editor using the mouse or trackpad. You can click to place the cursor, scroll using a scroll wheel or multi-touch gestures, or click and drag the scrollbar. Figure 2.14 shows the scrollbar for Sublime Text. Figure 2.14 also shows the sort of two-pane view mentioned briefly in Figure 2.12, which we’ll discuss more in Section 3.4.</p>
                      <p class="cycle spec"><img src="/ressources/e24.png" alt=""></p>
                      <p class="fig">Figure 2.14: The Sublime Text scrollbar.</p>
                      <p class="lamda">In addition to using the mouse or trackpad, I also like using the arrow keys to move around, typically in concert with the Command key ⌘ (Table 2.1). (In Linux, Command is typically replaced with the Function key fn, and in Windows it’s usually Ctrl, but you’ll have to apply Box 1.2 to figure out the details.) My text editing typically involves lots of ⌘← and ⌘→ to move to the beginnings and ends of lines, and ⌘↑ and ⌘↓ to move to the top and bottom of the file. An example of moving to the end of the line in README.md appears in Figure 2.15, and an example of moving to the end of the file in sonnets.txt appears in Figure 2.16.</p>
                      <p class="cycle spec"><img src="/ressources/e25.png" alt=""></p>
                      <p class="fig">Figure 2.15: Moving to the end of a line with ⌘→.</p>
                      <p class="cycle spec"><img src="/ressources/e26.png" alt=""></p>
                      <p class="fig">Figure 2.16: Moving to the end of the file with ⌘↓.</p>
                      <h2 id="vincinq">2.3.1 Exercises</h2>
                      <p class="exo">1-In your text editor, how do you move left and right one word at a time? Hint: On some systems, the Option key ⌥ might prove helpful.</p>
                      <p class="exo">2-In README.md, move to the second-to-last nonblank line using whatever technique you wish. Then move to the third word from the beginning of that line.</p>
                      <p class="exo">3-What is the command to go to a particular line number? Use this command to go to line 293 of sonnets.txt. What do rough winds do?</p>
                      <p class="exo">4-By moving to the last nonblank line of sonnets.txt and pressing ⌘→ followed by ⌘←, show that ⌘← actually stops as soon as it reaches whitespace, with the result shown in Figure 2.17. How do you get to the true beginning of the line?</p>
                      <p class="cycle spec"><img src="/ressources/e27.png" alt=""></p>
                      <p class="fig">Figure 2.17: When using ⌘←, the cursor stops on whitespace.</p>


                      <button class="btn">Commencer: le chapitre</button>

                
             </div>
             
         </div>
 
        
        </section>
        <!-- 14 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="vinsix">2.4 Selecting text</h2>
                   <p class="lamda">Selecting text is an important skill that is particularly useful for deleting or replacing content, as well as for cutting, copying, and pasting (Section 2.5). Many of the techniques in this section make direct application of the commands to move around covered in Section 2.3. As in that section, the ideas here are quite general, applying to a wide variety of applications, not just to text editors.</p>
                    <p class="lamda">In much the same way that modern editors make it easy to use the mouse to move the cursor, they also make it easy to use the mouse to select text. Simply click and drag the mouse cursor, as shown in Figure 2.18. Another closely related technique is to click on one location, and then Shift-click on another location to select all the text in between.</p>                 
                 <p class="cycle spec"><img src="" alt=""></p>
                 <p class="fig">Figure 2.18: The result of clicking and dragging the mouse cursor.</p>
                 
                    <h2 id="vinsept">2.4.1Selecting a single word</h2>
                <p class="lamda">
                    <p>When selecting text, there are some special cases that are useful enough to consider individually. We’ll start with some techniques for selecting a single word:</p> <br>
                    1-Click and drag the mouse cursor over the word. <br>
                    2-Double-click the word with the mouse. <br>
                    3-Press ⌘D (system-dependent; see Box 1.2). <br>
                    
                    

               </p>
               <h2 id="vinhuit">2.4.2 Selecting a single line</h2>
               <p class="lamda">
                   <p>Another technique, especially important when editing line-based text like computer code (or sonnets), involves selecting a full line or collection of lines. We start with ways to highlight a single line:</p> <br>
                   1-Click the beginning of the line and drag the cursor to the end.<br>
                   2-Click the end of the line and drag the cursor to the beginning <br>
                   3-Press ⌘← (twice) to get to the beginning of line, then press ⇧⌘→ to select to the end of line. <br>
                   4-Press ⌘→ to get to the end of line, then press ⇧⌘← (twice) to select to the beginning of line. <br>
                 
              </p>
                
                
                
                 <h2 id="vinneuf">2.4.3 Selecting multiple lines</h2>
                <p class="lamda">
                    <p>A comparably important technique is selecting multiple lines:</p> <br>
                    1-Click and drag the mouse cursor over the words/lines. <br>
                    2-Hold down the Shift key and move the up- and down-arrow keys (⇧↑ and ⇧↓). <br>
                  
               </p>
                  <p class="lamda">This latter technique is one of my personal favorites, and one of my most common editing tasks involves hitting ⌘← to go to the beginning of the first line I want to select and then hitting ⇧↓ repeatedly until I’ve selected all the lines I want (Figure 2.19). (As noted in Section 2.3.1, in many editors ⌘← stops on whitespace, so moving to the beginning of the line actually requires two uses of ⌘← in succession. Being able to figure out details and edge cases like this is a hallmark of growing technical sophistication (Box 1.2).)</p>
                 
               <p class="cycle spec"><img src="/ressources/e29.png" alt=""></p>
               <p class="fig">Figure 2.19: Selecting a Shakespearean couplet using ⌘← and ⇧↓.</p>

              <h2 id="trente">2.4.4 Selecting the entire document</h2>
              <p class="lamda">
                <p>Finally, it’s sometimes useful to be able to select the entire document at once. For this, there are two main techniques:</p>
                1-Use a menu item called “Select All” or something similar. The specifics are editor-dependent; Figure 2.20 shows the use of the Selection menu in Sublime Text.
                2-Press ⌘A.
              </p>
               <p class="lamda">Note from Figure 2.20 that the menu actually shows the corresponding command (⌘A); bootstrapping your knowledge using the menu items is a great way to learn keyboard shortcuts, which over time will make your text editing significantly more efficient.</p>

               <p class="cycle spec"><img src="/ressources/e29.png" alt=""></p>
               <p class="fig">Figure 2.20: Selecting the entire document using the Selection menu (Sublime Text).</p>

               <h2 id="trenteun">2.4.5 Exercises</h2>
               <p class="exo">1-Select Shakespeare’s second sonnet by clicking at the beginning and then Shift-clicking at the end.</p>
               <p class="exo">2-Select the first line in the file by moving to the beginning with ⌘↑ and pressing ⇧⌘→ (or the equivalent for your system).</p>
               <p class="exo">3-Delete the selection in the previous exercise (using the Delete key).
            </p>
               <p class="exo">4-Select the word “document” in README.md and replace it with “README”.</p>



               <button class="btn">Commencer: le chapitre</button>



             </div>
             
         </div>
 
        
        </section>
        <!-- 15 -->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="trentedeux">2.5 Cut, copy, paste</h2>

                 <p class="lamda">The Cut/Copy/Paste triumvirate is one of the most useful sets of operations when editing text, especially when executed via the conveniently located keyboard shortcuts ⌘X/⌘C/⌘V. (Cut/Copy/Paste are available as menu items (Figure 2.21), but the operations are so common that I strongly recommend learning and using the keyboard shortcuts right away.) Although only ⌘C is mnemonic (“C” for “Copy”), the keys are conveniently located three in a row on the bottom row of a standard QWERTY keyboard, which makes it easy to use them in combination or in quick succession (Figure 2.22).</p>
                 <p class="cycle spec"><img src="/ressources/e31.png" alt=""></p>
                 <p class="fig">Figure 2.21: The Cut/Copy/Paste menu items (which you should never use).</p>
                 <p class="lamda"></p>
                 <p class="cycle spec"><img src="/ressources/e32.jpg" alt=""></p>
                 <p class="fig">Figure 2.22: The XCV keys on a standard QWERTY keyboard.</p>
                 <p class="lamda">Applying either Cut or Copy involves first selecting text (Section 2.4), and then hitting either ⌘X to Cut or ⌘C to Copy. When using ⌘C to Copy, the selected text is placed in a buffer (temporary memory area); moving to the desired location (Section 2.3) and hitting ⌘V lets you Paste the content into the document at the location of the cursor. ⌘X works the same way as ⌘C, except the text is removed from the document as well as being copied into the buffer.</p>
                 <p class="lamda">As a concrete example, let’s select a Markdown link from the sample README file, README.md, as shown in Figure 2.23. After copying with ⌘C, we can then paste the link several times (with returns in between) by repeatedly hitting ⌘V and the Enter key, as shown in Figure 2.24. Finally, Figure 2.25 shows the result of cutting README from the main text and pasting it in at the end of the file.</p>
                 <p class="cycle spec"><img src="/ressources/e33.png" alt=""></p>
                 <p class="fig">Figure 2.23: Selecting a Markdown link.</p>
                 <p class="lamda"></p>
                 <p class="cycle spec"><img src="/ressources/e34.png" alt=""></p>
                 <p class="fig">Figure 2.24: Pasting link text several times (with returns in between).</p>
                 <p class="lamda"></p>
                 <p class="cycle spec"><img src="/ressources/e35.png" alt=""></p>
                 <p class="fig">Figure 2.25: The result of cutting “README” and pasting at the end of the file.</p>
                 <h2 id="trentetrois">2.5.1 Jumpcut</h2>
                 <p class="lamda">Although Cut/Copy/Paste is all that’s strictly necessary for everyday editing, there is one big downside, which is that there is only room in the buffer for a single string. Among other things, this means that if you Cut something and then accidentally hit “copy” instead of “paste” (which is easy since the letters are adjacent on the keyboard), you overwrite the buffer, and the text you Cut is gone forever (unless you undo as described in Section 2.6). If you happen to be developing on a Mac, there’s a solution to this problem: a free program called Jumpcut. This remarkable little utility app expands the buffer by maintaining more than one entry in the history. You can navigate this expanded buffer using either the Jumpcut menu (Figure 2.26) or the keyboard shortcuts ⌃⌥V (cycle forward) and ⇧⌃⌥V (cycle backward). I use Jumpcut dozens or even hundreds of times a day, and I strongly suggest giving it a try.</p>
                 <p class="cycle spec"><img src="/ressources/e36.png" alt=""></p>
                 <p class="fig">Figure 2.26: Jumpcut expands the copy-and-paste buffer to include a longer history.</p>
                 <h2 id="trentequatre">2.5.2 Exercises</h2>
                 <p class="exo">1-Select the entire document, Copy it, and Paste several times. The result should look something like Figure 2.27.
                </p>
                 <p class="exo">2-Select the entire document and Cut it. Why might this be preferable to deleting it?
                </p>
                 <p class="exo">3-Select and copy the couplet at the end of Sonnet 1 and paste it into a new file called sonnet_1.txt. How do you create a new file directly in your editor?</p>

                 <p class="cycle spec"><img src="/ressources/e37.png" alt=""></p>
                 <p class="fig">Figure 2.27: The result of pasting the whole document several times..</p>










                 <button class="btn">Commencer: le chapitre</button>

                
             </div>
             
         </div>
 
         
        </section>
        <!-- 16-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="trentecinq">2.6Deleting and undoing</h2>
                <p class="lamda">We mentioned deleting before in Section 2.4.5 (the exercises for Section 2.4), which of course simply involves pressing the Delete key, sometimes written as ⌫ (Table 2.1). As with Cut/Copy/Paste (Section 2.5), deletion is especially useful when combined with the selection techniques from Section 2.4.</p>
                <p class="lamda">In addition to the obvious technique of selecting and deleting text, on a Mac I especially like using ⌥⌫ to delete one word at a time. I’ll frequently use this combination if I need to delete a medium number of words (say 2–5) to restart a phrase when writing. For shorter deletion tasks, such as one word, it’s usually faster to hit ⌫ repeatedly, as context-switching to use ⌥⌫ incurs some overhead that makes it faster to just delete directly. Don’t worry too much about these micro-optimizations, though; with experience, as a matter of course you’ll come up with your own set of favorite techniques.</p>
                <p class="lamda">Paired with deletion is one of the most important commands in the history of the Universe, Undo. In modern editors, Undo uses the native keybinding, typically ⌘Z or ⌃Z. Its inverse, Redo, is usually something like ⇧⌘Z or ⌘Y. You can also use the menu (typically Edit, as seen in Figure 2.28), but, as with Cut/Copy/Paste (Section 2.5), Undo is so useful that I recommend memorizing the shortcut as soon as possible. Without Undo, operations like deletion would be irreversible and hence potentially harmful, but with Undo it’s easy to reverse any mistakes you make while editing.</p>

                 <p class="cycle spec"><img src="/ressources/e38.png" alt=""></p>
                 <p class="fig">Figure 2.28: Undo and Redo in the editor menu.</p>
                 <p class="lamda">One practice I recommend is using Cut instead of Delete whenever you’re not 100% sure you’ll never want the content again. Although you can usually Undo your way to safety if you accidentally delete something important, putting the content into the buffer with Cut gives you an additional layer of redundancy. (Using Jumpcut (Section 2.5.1) gives you another layer still.)</p>
                 <p class="lamda">Finally, Undo provides us with a useful trick for finding the cursor, a common task when editing larger files. The issue is that you’ll be writing some text and then need to move (Section 2.3) or find (Section 2.8) elsewhere in the document. On these occasions, it can be hard to relocate the cursor. There are several ways around this problem—you can move the arrow keys, or just start typing—but my favorite technique is to Undo and then immediately Redo (⌘Z/⇧⌘Z or ⌘Z/⌘Y), which is guaranteed to find the cursor without making any undesired changes.</p>
              
                 <h2 id="trentesix">2.6.1 Exercises</h2>
                 <p class="exo">1-Use Undo repeatedly until all the changes you’ve made to README.md have been undone</p>
                 <p class="exo">2-Using any technique you want from Section 2.4, select the word “written” in README.md and delete it, then undo the change.</p>
                 <p class="exo">3-Redo the change from the previous exercise, then undo it again</p>
                 <p class="exo">4-Make an edit somewhere in sonnets.txt, then scroll around so you get lost. Use the Undo/Redo trick to find the cursor again. Then keep using Undo to undo all your changes.</p>

                 <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
         
        </section>
        <!-- 17-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="trentesept">2.7 Saving</h2>
                 <p class="lamda">Once we’ve made some edits to a file, we can save it using the menu or with ⌘S. I strongly recommend using the keyboard shortcut, which among other things makes it easier to save the file whenever you reach a temporary pause in your writing or coding—a valuable habit to cultivate. Basically, if you’re not doing something else, you should be hitting Save. This habit goes a long way toward preventing lost work (and, as discussed in Learn Enough Git to Be Dangerous, is especially powerful when combined with version control).</p>
                 <p class="lamda">As an example, we can add some source code to our README file and save the result. We start by pasting in the code from Listing 2.4, as shown in Figure 2.29 (which includes some nice high-contrast syntax highlighting). As you can see from the circled indicator in Figure 2.29, Sublime Text (as with most modern editors) includes a subtle indicator that the file is unsaved, in this case a small open circle. After running Save (via ⌘S, for example), the circle disappears, to be replaced with an X (Figure 2.30).</p>
                 <p class="cod">
                    Listing 2.4: A code snippet. <br>
                    ```ruby <br>
                    def hello <br>
                      puts "hello, world!" <br>
                    end
                 </p>
                 <p class="cycle spec"><img src="/ressources/e39.png" alt=""></p>
                 <p class="fig">Figure 2.29: An unsaved file.</p>
                 <p class="cycle spec"><img src="/ressources/e40.png" alt=""></p>
                 <p class="fig">Figure 2.30: The file from Figure 2.29 after saving.</p>
                 <h2 id="trentehuit">2.7.1 Exercises</h2>
                 <p class="exo">1-Undo the pasting in of source code to restore the file to its original state</p>
                 <p class="exo">2-Figure out how to “Save As”, then save README.md as code_example.md, paste in the code example, and save the file.</p>
                 <p class="exo">3-The default Bash prompt for my command-line terminal appears as in Listing 2.5, but I prefer the more compact prompt shown in Listing 2.6. In Learn Enough Command Line to Be Dangerous, I promised to show how to customize the prompt in Learn Enough Text Editor to Be Dangerous. Fulfill this promise by editing the .bashrc file to include the lines shown in Listing 2.7. Source the Bash profile as in Listing 1.5 and confirm that the prompt on your system matches the one shown in Listing 2.6. (To learn how to customize the prompt using Z shell, the current default shell on macOS, see the Learn Enough blog post “Using Z Shell on Macs with the Learn Enough Tutorials”.)
                </p>
                 <p class="cod">
                    Listing 2.5: The default terminal prompt on my system. <br>
                       MacBook-Air:~ mhartl$
                 </p>
                 <p class="cod">
                    Listing 2.6: My preferred, more compact prompt. <br>
                    [~]$
                 </p>
                 <p class="cod">
                    Listing 2.7: The Bash lines needed to customize the prompt as shown in Listing 2.6. <br>
                    ~/.bashrc <br>
                    alias lr='ls -hartl' <br>
                    # Customize prompt to show only working directory. <br>
                    PS1='[\W]\$ '
                 </p>











                 <button class="btn">Commencer: le chapitre</button>


                
             </div>
             
         </div>
 
        
        </section>
        <!-- 18-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="trenteneuf">2.8 Finding and replacing</h2>
                 <p class="lamda">One of the most powerful features of every good text editor is the ability to find and optionally replace text. In this section we’ll learn how to find and replace in a single file; in Section 3.4 we’ll discuss the more powerful (and much more dangerous) method of finding and replacing across multiple files.</p>
                 <p class="lamda">To find inside a file, you can use the Find menu, shown in Figure 2.31, which also shows that ⌘F is the corresponding keyboard shortcut. Either one brings up a modal window where you can type in the string you’re searching for (Figure 2.32).</p>
                 <p class="cycle spec"><img src="/ressources/e41.png" alt=""></p>
                 <p class="fig">Figure 2.31: Finding using the menu.</p>
                 <p class="cycle spec"><img src="/ressources/e42.png" alt=""></p>
                 <p class="fig">Figure 2.32: A modal window for finding and replacing.</p>
                 <p class="lamda">For example, suppose we search for the string “sample”. As seen in Figure 2.33, both “Sample” and “sample” are highlighted. The reason our search finds both is because we’ve opted to search case-insensitively (which is usually the default).</p>
                 <p class="cycle spec"><img src="/ressources/e43.png" alt=""></p>
                 <p class="lamda">Figure 2.34 shows how to use the modal window to find “sample” and replace with “example”. In order to avoid replacing “Sample”, we first click on Find to select the next match, and then click on Replace to replace the second match (Figure 2.35). (Changing to case-sensitive search would also work in this case; learning how to do this is left as an exercise (Section 2.8.1).)</p>
                 <p class="fig">Figure 2.33: Finding the string “sample”.</p>
                 <p class="cycle spec"><img src="/ressources/e44.png" alt=""></p>
                 <p class="fig">Figure 2.34: Finding and replacing.</p>
                 <p class="cycle spec"><img src="/ressources/e45.png" alt=""></p>
                 <p class="fig">Figure 2.35: The result of replacing “sample” with “example”.</p>
                 <p class="lamda">As seen in Figure 2.31, you can also type ⌘G to find the next match using a keyboard shortcut. This ⌘F/⌘G combination also works in many other applications, such as word processors and web browsers.</p>
                 <p class="lamda">Finally, note that we have now changed “a sample” to “a example”, so as a final step we’ll change this to “an example” (Figure 2.36).</p>
                 <p class="cycle spec"><img src="/ressources/e49.png" alt=""></p>
                 <p class="fig">Figure 2.36: Making “an example” of it.</p>
                 <h2 id="quarante">2.8.1 Exercises</h2>
                 <p class="exo">1-In Section 2.3.1, we found Sonnet 18 by going directly to line 293, but of course I didn’t search the file line by line to write the exercise. Instead, I searched for “shall I compare thee”. Use your text editor to search for this string in sonnets.txt. On what line does “rosy lips and cheeks” appear?
                </p>
                 <p class="exo">2-The example in this section shows one of the pitfalls of mechanically finding and replacing text: we’ve ended up with the ungrammatical result “a example” instead of “an example”. Rather than fix this by hand, use find and replace to replace “a example” with “an example” in your document. (Although in the present case there’s only one occurrence, this more general technique scales up to documents much longer than our toy example.)</p>
                 <p class="exo">3-What is the keyboard shortcut in your editor for finding the previous match?</p>
                 <p class="exo">4-What is the keyboard shortcut to replace in the current buffer (file)? How does this differ from the keyboard shortcut for simply finding?</p>
             
             
             
                 <button class="btn">Commencer: le chapitre</button>
             
                </div>
             
         </div>
 
         
        </section>
        <!-- 19-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="qun">2.9 Summary</h2>
                 <p class="lamda">
                    1-Atom, Sublime Text, and VSCode are all excellent choices for a primary modern text editor. <br>
                    2-One common way to open files is to use a command at the command line. <br>
                    3-For files containing things like prose with long lines, it’s a good idea to turn on word wrap. <br>
                    4-Moving around text files can be accomplished many different ways, including using the mouse and arrow keys (especially in combination with the Command/Control key). <br>
                    5-One convenient way to select text is to hold down Shift and move the cursor. <br>
                    6-The Cut/Copy/Paste triumvirate is incredibly useful. <br>
                   7-Undo can save your bacon (Figure 2.37).
                    
                 </p>
                 <p class="cycle spec"><img src="/ressources/e47.jpg" alt=""></p>
                 <p class="fig">Figure 2.37: Undo can save your bacon.</p>
                 <p class="lamda">Important commands from this chapter are summarized in Table 2.2.</p>
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong>Command</strong></td>
                    <td class="align_left"><strong>Description</strong></td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘←</td>
                    <td class="align_left">Move to beginning of line (stops on whitespace)</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘→</td>
                    <td class="align_left">Move to end of line</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘↑</td>
                    <td class="align_left">Move to beginning of file</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘↓</td>
                    <td class="align_left">Move to end of file</td>
                    </tr>
                    <tr>
                    <td class="align_left">⇧-move</td>
                    <td class="align_left">Select text</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘D</td>
                    <td class="align_left">Select current word</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘A</td>
                    <td class="align_left">Select All (entire document)</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘X/⌘C/⌘V</td>
                    <td class="align_left">Cut/Copy/Paste</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘Z</td>
                    <td class="align_left">Undo</td>
                    </tr>
                    <tr>
                    <td class="align_left">⇧⌘Z or ⌘Y</td>
                    <td class="align_left">Redo</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘S</td>
                    <td class="align_left">Save</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘F</td>
                    <td class="align_left">Find</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘G</td>
                    <td class="align_left">Find next</td>
                    </tr>
                    </tbody>
                    </table>
                    <p class="fig">Table 2.2: Important commands from Chapter 2.</p>
                    <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
         
        </section>
        <!-- 20-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="qdeux">Advanced text editing</h2>

                 <p class="lamda">Having covered the basic functions of modern text editors in Chapter 2, in this chapter we’ll learn about a few of the most common advanced topics. Even more than in Chapter 2, details will vary based on the exact editor you choose, so use your growing technical sophistication (Box 1.2) to figure out any necessary details. The most important lesson is that the advanced functions in this chapter are all things that any professional-grade editor can do, so you should be able to figure out how to do them no matter which editor you’re using.</p>
                 <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
         
        </section>
        <!-- 21-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="qtrois">3.1 Autocomplete and tab triggers</h2>
                <p class="lamda">Two of the most useful features of text editors are autocomplete and tab triggers, which you can think of as roughly command-line style tab completion for text files. (See Learn Enough Command Line to Be Dangerous for details on tab completion.) Both features allow us to type potentially large amounts of text with only a few keystrokes.</p>
                 <h2 id="qquatre">3.1.1 Autocomplete</h2>
                 <p class="lamda">The most common variant of autocomplete lets us type the first few letters of a word (followed by tab, depending on the editor) and then gives us the ability to complete it from a menu of options, typically by using the arrow keys and hitting tab to accept the completion. An example of autocompleting the word “Markdown” in README.md appears in Figure 3.1. (Note that Figure 3.1 restores the contents of the original README file, which you can replicate by rerunning the curl command in Listing 2.1.)</p>
                <p class="cycle spec"><img src="/ressources/e48.png" alt=""></p>
                <p class="fig">Figure 3.1: Autocomplete for “Markdown”.</p>
                <p class="lamda">The autocomplete menu itself is populated using the current document, so autocomplete is particularly useful in longer documents that contain a large number of possible completions. For instance, the source for Learn Enough Text Editor to Be Dangerous (which is written using the powerful markup language LATEX) makes use of a large number of labels for making cross-references, and these labels are often long enough that it’s much easier to autocomplete them than to type them out by hand. An example is the oft-cited Box 1.2, whose source looks like Listing 3.1.</p>
                <p class="cod">
                    Listing 3.1: A cross-reference with a label I usually autocomplete. <br>
                    Box~\ref{aside:technical_sophistication}
                </p>
                <p class="lamda">When writing a string like technical_sophistication in Listing 3.1, I nearly always use autocomplete instead of typing it out in full.1 (As mentioned below, the rest of the cross-reference is generated using a custom tab trigger.) Similar considerations frequently occur when writing source code, where (as we’ll learn in Learn Enough Ruby to Be Dangerous) we might encounter something like this:</p>
                 <p class="cod">ReallyLongClassName < ReallyLongBaseClassName</p>
                 <p class="lamda">In such cases, rather than typing out the long names by hand, it’s usually easier to type Rea and then select the relevant autocompletion.</p>


                  <h2 id="qcinq">3.1.2 Tab triggers</h2>
                  <p class="lamda">Tab triggers are similar to autocompletion in that they let us type a few letters and then hit tab to work some magic, but in this case many of them come pre-defined with the editor, with the exact triggers typically based on the particular type of document we’re editing. For example, in Markdown and other markup files (HTML, LATEX, etc.), typing lorem⇥ or lo⇥ yields so-called lorem ipsum text, a slightly corrupted Latin fragment from a book by Cicero that is often used as dummy text in programming and design. We saw lorem ipsum briefly before in Listing 2.2; a second example appears in Figure 3.2, which shows the result of typing lo in Sublime Text. A closeup appears in Figure 3.3. After hitting ⇥ to invoke the tab trigger, the full lorem ipsum text appears as in Figure 3.4.</p>
                  <p class="cycle spec"><img src="/ressources/e49.png" alt=""></p>
                <p class="fig">Figure 3.2: Typing “lo” in Sublime Text prepares to activate a tab trigger.</p>
                <p class="cycle spec"><img src="/ressources/e50.png" alt=""></p>
                <p class="fig">Figure 3.3: A more detailed view of the trigger in Figure 3.2.</p>
                <p class="cycle spec"><img src="/ressources/e51.png" alt=""></p>
                <p class="fig">Figure 3.4: The result of the tab trigger in Figure 3.2.</p>
                <p class="lamda">Tab triggers are especially useful when editing more syntax-heavy file types like HTML and source code. For instance, when writing HTML, many editors support the creation of an HTML skeleton using the trigger html⇥, together with HTML tags (covered in Learn Enough HTML to Be Dangerous) using the tag name with a tab, such as h1⇥ for an h1 or top-level heading tag. In Sublime Text, we can do something like this:</p>
                <p class="cod">$ subl index.html</p>
                <p class="lamda">The result of applying the various tab triggers then might look something like Figure 3.5.</p>
                <p class="cycle spec"><img src="/ressources/e52.png" alt=""></p>
                <p class="fig">Figure 3.5: The result of applying HTML tab triggers.</p>
                <p class="lamda">Because HTML, or HyperText Markup Language, is the language of the World Wide Web, navigating to the file in a browser then shows a simple but real web page (Figure 3.6).</p>
                <p class="cycle spec"><img src="/ressources/e53.png" alt=""></p>
                <p class="fig">Figure 3.6: The result of applying tab triggers to an HTML page.</p>
                <p class="lamda">Similarly, when writing Ruby code, typing def⇥ in Sublime Text creates a Ruby define statement to make a function, which looks like this:.</p>
                <p class="cod">
                    def method_name <br> <br>

                    end
                </p>
                <p class="lamda">After typing the name of the function (which replaces the placeholder text method_name), we can hit ⇥ again to place the cursor in the right location to start writing the main part of the function. These sorts of auto-expansions of content can speed up code production considerably, while also lowering the cognitive load of programming. We’ll see a concrete example of this technique in Section 3.2.</p>
                <p class="lamda">Finally, it’s possible to define tab triggers of your own. My own editing makes extensive use of tab triggers; for example, to make the text in Listing 3.1, instead of typing</p>
                <p class="cod">Box~\ref{aside:technical_sophistication}</p>
                <p class="lamda">by hand I used the custom tab trigger bref (for “box reference”) to generate</p>
               
                <p class="cod">Box~\ref{aside:}</p>
                <p class="lamda">and then filled in the label technical_sophistication using autocomplete (Section 3.1.1). Defining custom tab triggers is highly editor-dependent and is beyond the scope of this tutorial, but some hints about how to figure it out for yourself appear in Section 3.5.</p>
               <h2 id="qsix">3.1.3 Exercises</h2>
               <p class="exo">1-Add some more lorem ipsum text to README.md using a tab trigger.</p>
               <p class="exo">2-Add another occurrence of the word “consectetur” using autocomplete</p>
               <p class="exo">3-Write the sentence “As Cicero once said, ‘quis nostrud exercitation ullamco laboris’.” with the help of as many uses of autocomplete as you want.
            </p>
            <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
        
        </section>
        <!-- 22-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="qsept">Writing source code</h2>
                 <p class="lamda">As hinted at in Section 3.1.2, in addition to being good at editing markup like HTML and Markdown, text editors excel at writing computer programs. Any good programmer’s text editor supports many specialized functions for writing code; this section covers a few of the most useful. Even if you don’t know how to program (yet!), it’s still useful to know about some of the ways text editors support writing code.</p>
                 <p class="lamda">An example of computer code appears in Listing 3.2, which shows a variant of a “hello, world” program written in the Ruby programming language. (You are not expected to understand this program.)</p>
                 <p class="cod">
                    Listing 3.2: A variant of “hello, world” in Ruby. <br>
                    1# Prints a greeting. <br>
                    2def hello(location) <br>
                    3  puts "hello, #{location}!" <br>
                    4end <br>
                    5 <br>
                    6hello("world")
                 </p>
                 <p class="lamda">To see the contents from Listing 3.2 in a text editor, we can fire up Sublime Text as follows:</p>
                 <p class="cod">subl hello.rb</p>
                 <p class="lamda">Upon pasting in the content of Listing 3.2, we get the result shown in Figure 3.7. (For extra credit, type in Listing 3.2 by hand using the def tab trigger discussed in Section 3.1.)</p>
             
                  <p class="cycle spec"><img src="/ressources/e54.png" alt=""></p>
                  <p class="fig">Figure 3.7: A Ruby program in Sublime Text.</p>
                  <h2 id="qhuit">3.2.1 Syntax highlighting</h2>
                  <p class="lamda">As we saw in Section 2.2.1 with README.md, Sublime Text uses the filename extension to determine the proper syntax highlighting. In that case the (rather subtle) highlighting was for Markdown; in this case, Sublime Text infers from .rb that the file contains Ruby code, and highlights it accordingly. As before, it’s essential to understand that the highlighting isn’t inherent to the text, which is still plain. Syntax highlighting is purely for our benefit as readers of the code.</p>
                  <p class="lamda">In addition to making it easier to parse the source code visually (e.g., distinguishing keywords, strings, constants, etc.), syntax highlighting can also be useful for catching bugs. For example, at one point when editing Learn Enough Command Line to Be Dangerous I accidentally deleted a LATEX closing quote (which consists of the two single quotes ''), with the result shown in Figure 3.8. This changed the color of the main text from the default white to the color used for quoted strings (green), which made it apparent at a glance that something was wrong. Upon fixing the error, the highlighting changed back to the expected white text, as shown in Figure 3.9.</p>
             
             
                  <p class="cycle spec"><img src="/ressources/e55.png" alt=""></p>
                  <p class="fig">Figure 3.8: An error in LATEX source caught by syntax highlighting.</p>
                  <p class="cycle spec"><img src="/ressources/e56.png" alt=""></p>
                  <p class="fig">Figure 3.9: Error fixed, syntax highlighting as expected.</p>
                  <h2 id="qneuf">3.2.2 Commenting out</h2>
                  <p class="lamda">One of the most useful functions of a text editor is the ability to “comment out” blocks of code, a technique often used to temporarily prevent execution of certain lines without having to delete them entirely (which is often particularly helpful when debugging). Most programming and markup languages support comment lines that exist for the benefit of humans reading the code but are ignored by the programming language itself.2 An example of a Ruby comment appears in the first line of Listing 3.2:</p>
             
                  <p class="cod"># Prints a greeting.</p>
                  <p class="lamda">Here the leading hash symbol # is Ruby’s way of indicating a comment line.</p>
                  <p class="lamda">Suppose we wanted to comment out the next three lines (lines 2–4), to change</p>
                  <p class="cod"># Prints a greeting. <br>
                    def hello(location) <br>
                      puts "hello, #{location}!" <br>
                    end <br> <br>
                    
                    hello("world")</p>
                    <p class="lamda">to</p>
                    <p class="cod"># Prints a greeting. <br>
                        # def hello(location) <br>
                        #  puts "hello, #{location}!" <br>
                        # end <br>
                        
                        hello("world")</p>
                        <p class="lamda">It’s possible to do this by hand, of course, simply by inserting a # at the beginning of each line. This is inconvenient, though, and becomes increasingly so as the length of the commented-out text grows. Instead, we can select the desired text (Section 2.4) and use a menu item or keyboard shortcut to comment out the selection. In Sublime Text, we can comment out lines 2–3 by selecting those lines (Figure 3.10) and hitting ⌘/, as shown in Figure 3.11. (Note from Figure 3.11 that the subtle save indicator shown in Figure 2.30 has been filled in; this is because I habitually press ⌘S after making changes, as recommended in Section 2.7.)</p>
             
                        <p class="cycle spec"><img src="/ressources/e57.png" alt=""></p>
                        <p class="fig">Figure 3.10: Preparing to comment out some lines.</p>
                        <p class="cycle spec"><img src="/ressources/e58.png" alt=""></p>
                        <p class="fig">Figure 3.11: Commented-out lines.</p>
                         <p class="lamda">The commenting-out feature typically toggles back and forth, so by hitting ⌘/ a second time we can restore the file to its previous state (Figure 3.10). This is useful when restoring some commented-out text after, for example, doing some debugging.</p>
                        <h2 id="cun">3.2.3 Indenting and dedenting</h2>
                        <p class="lamda">Another element of code formatting made easier by text editors is indentation, which consists of the leading spaces at the beginning of certain lines. It used to be common to use tab characters for indentation, but unfortunately the number of spaces displayed for a tab is system-dependent, leading to unpredictable results: some people might see four “spaces” per tab, some might see eight, and some might see only two.</p>
                        <p class="lamda">In recent years, many programmers have switched to emulated tabs, where pressing the tab key inserts a standard number of ordinary spaces (typically two or four). True tabs still have some partisans, though, and tabs vs. spaces remains holy war territory (Box 1.5). (Luckily, there is one thing everyone agrees on, which is that mixing tabs and spaces is a bad idea.)</p>
                        <p class="lamda">To see how this works, we can take a look at some Ruby code, which typically uses two spaces for indentation:</p>
                        <p class="cod">def hello(location) <br>
                            puts "hello, #{location}!" <br>
                          end</p>
                        <p class="lamda">This would typically be achieved by hitting return after “(location)” and then pressing the tab key, although pressing the spacebar twice would also work. Assuming that the editor has been configured to use two spaces to emulate tabs, we’d get the result shown above. In most languages, this would be equivalent to the following:</p>
                        <p class="cod">
                            def hello(location) <br>
                            puts "hello, #{location}!" <br>
                            end
                        </p>
                        <p class="lamda">This second example is harder to read, though, and it’s important to indent properly for the sake of humans reading the code, even if the programming language doesn’t care.</p>
                        <p class="lamda">Text editors help maintain proper indentation in two main ways. First, new lines are typically inserted at the same level of indentation as the previous line, which you can verify by going to the end of line 3 in Listing 3.2 and typing in the following two lines:</p>
                        <p class="cod">puts "Uh, oh." <br>
                            puts "Goodbye, #{location}!"</p>
                            <p class="lamda">The result appears in Figure 3.12.</p>
                            <p class="cycle spec"><img src="/ressources/e59.png" alt=""></p>
                            <p class="fig">Figure 3.12: Adding two indented lines.</p>
                            <p class="lamda">The second main way text editors help maintain good code formatting is by supporting block indentation, which works in much the same way as commenting out code blocks. Suppose, for example, that (contrary to conventional Ruby practices) we decided to indent lines 3–5 in Figure 3.12 six extra spaces, making eight spaces total. As with commenting out, the first step is to select the text we want to indent (Figure 3.13). We can then type the tab key ⇥ to indent one “soft tab” (which is usually two spaces for Ruby) at a time. (If for any reason the default indentation in your editor doesn’t match the convention for the language you’re using, apply your technical sophistication (Box 1.2) to figure out how to change it.) The result of applying three tabs in succession is shown in Figure 3.14.</p>
                            <p class="cycle spec"><img src="/ressources/e60.png" alt=""></p>
                            <p class="fig">Figure 3.13: Preparing to indent some lines.</p>
                            <p class="cycle spec"><img src="/ressources/e61.png" alt=""></p>
                            <p class="fig">Figure 3.14: A block of Ruby code indented more than usual.</p>
                            <p class="lamda">Because each extra tab just indents the block more, we can’t use the same command to undo indentation the way we did when commenting out code. Instead, we need to use a separate “dedent” command, which in Sublime Text is ⇧⇥. Applying this command three times in succession returns us to our original state, as shown in Figure 3.15. (By the way, many editors, including Sublime Text, support the alternate keyboard shortcuts ⌘] and ⌘[ for indenting and dedenting, respectively.)</p>
                            
                            <p class="cycle spec"><img src="/ressources/e62.png" alt=""></p>
                            <p class="fig">Figure 3.15: Dedenting the code block in Figure 3.14.</p>
                            <h2 id="cdeux">3.2.4 Goto line number</h2>
                            <p class="lamda">It’s often important to be able to go to a particular line number, such as when debugging a program that has an error on (say) line 187. We saw this feature in Section 1.6, where we learned that the Vim command <n>G takes us to line <n>. In many other editors, the relevant shortcut is ⌃G. This opens a modal box where you can type in the line number, as shown in Figure 3.16. (Incidentally, the syntax :<number> shown in Figure 3.16, which is for Sublime Text, also works in Vim.)</p>
                                <p class="cycle spec"><img src="/ressources/e63.png" alt=""></p>
                                <p class="fig">Figure 3.16: The modal box for going to a particular line number.</p>


                                <h2 id="ctrois">3.2.5 80 columns</h2>
                                <p class="lamda">Finally, many text editors help programmers enforce a line limit of 80 characters across, usually called an “80-column limit”. Not all programmers observe this limit, but keeping our code to 80 columns makes it easier to read and display, for example in fixed-width terminals, blog posts, or tutorials such as this one.5 An 80-column limit also enforces good coding discipline, as exceeding 80 columns is often a sign that we would do well to introduce a new variable or function name.6 Because it’s difficult to tell at a glance if a particular line exceeds 80 characters, many editors (Sublime Text) include the option to display a subtle vertical line showing where the limit is, as shown in Figure 3.17.7 If the 80-column limit indicator isn’t shown by default in your editor, flex your technical sophistication to figure out how to enable it. (It’s often associated with a setting called “word wrap column”.)</p>
                                    <p class="cycle spec"><img src="/ressources/e64.png" alt=""></p>
                                    <p class="fig">Figure 3.17: Unsubtle arrows pointing at the subtle 80-column indicator in Sublime Text.</p>
                           
                                 <h2 id="cquatre">3.2.6 Exercises</h2>
                                 <p class="exo">1-Create the file foo.rb, then define the class FooBar (Listing 3.3) using a tab trigger. Hint: Chances are the trigger is something like cla⇥.</p>
                                 <p class="exo">2-Referring to Listing 3.4, add the definition of bazquux using the def⇥ trigger, then add the final line shown by using autocomplete to type FooBar and bazquux. (Type the interstitial .new. by hand.)</p>
                                 <p class="exo">3-Using tab triggers and autocomplete, make a file called greeter.rb with the contents shown in Listing 3.5.</p>
                                 <p class="exo">4-By cutting and pasting the text for the hello definition and indenting the block, transform Listing 3.5 into Listing 3.6.</p>
                                 <p class="cod">
                                    Listing 3.3: Creating a class using a tab trigger. <br>
                                    ~/foo.rb <br>
                                    class FooBar <br> <br>
                                    
                                    end
                                 </p>
                                 <p class="cod">
                                    Listing 3.4: Using autocomplete to make a class name. <br>
                                    ~/foo.rb <br>
                                    class FooBar <br>
                                      def bazquux <br>
                                        puts "Baz quux!" <br>
                                      end <br>
                                    end <br><br>
                                    
                                    FooBar.new.bazquux
                                 </p>
                                 <p class="cod">
                                    Listing 3.5: A proto-Greeter class in Ruby. <br>
                                    ~/greeter.rb <br>
                                    class Greeter <br>
                                    end <br> <br>
                                    
                                    def hello(location) <br>
                                      puts "hello, #{location}!" <br>
                                    end <br> <br>
                                    
                                    Greeter.new.hello("world")
                                 </p>
                                 <p class="cod">
                                    Listing 3.6: A completed Greeter class in Ruby. <br>
                                    class Greeter <br>
                                      def hello(location) <br>
                                        puts "hello, #{location}!" <br>
                                      end <br>
                                    end <br> <br>
                                    
                                    Greeter.new.hello("world")
                                 </p>
                                 <button class="btn">Commencer: le chapitre</button>
                        </div>
             
         </div>
 
         
        </section>
        <!-- 23-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="ccinq">3.3 Writing an executable script</h2>
                 <p class="lamda">As a practical application of the material in Section 3.2, in this section we’re going to write something that’s actually useful: a shell script designed to kill a program as safely as possible. (A script is a program that is typically used to automate common tasks, but the detailed definition isn’t important at this stage.) En route, we’ll cover the steps needed to add this script to our command-line shell.</p>
                 <p class="lamda">As discussed in Learn Enough Command Line to Be Dangerous, Unix user and system tasks take place within a well-defined container called a process. Sometimes, one of these processes will get stuck or otherwise misbehave, in which case we might need to terminate it with the kill command, which sends a terminate code to kill the process with a given id:</p>
                 <p class="cod">
                    $ kill -15 12241
                 </p>
                 <p class="lamda">(See the discussion in Learn Enough Command Line to Be Dangerous for more on how to find this id on your system.) Here we’ve used the terminate code 15, which attempts to kill the process as gently as possible (meaning it gives the process a chance to clean up any temporary files, complete any necessary operations, etc.). Sometimes terminate code 15 isn’t enough, though, and we need to escalate the level of urgency until the process is well and truly dead. It turns out that a good sequence of codes is 15, 2, 1, and 9. Our task is to write a command to implement this sequence, which we’ll call ekill (for “escalating kill”), so that we can kill a process as shown in Listing 3.7.</p>
                 <p class="lamda"></p>
                 <p class="cod">
                    Listing 3.7: An example of using ekill (to be defined). <br>
                    $ ekill 12241
                 </p>
                 <p class="lamda">As with the Ruby example in Section 3.2, don’t worry about the details of the code; focus instead on the mechanics of the text editing.</p>
                 <p class="lamda">As preparation for adding ekill to our system, we’ll first make a new directory in our home directory called bin (for “binary”):</p>
                 <p class="cod">
                    $ mkdir ~/bin
                 </p>
                 <p class="lamda">(It’s possible that this directory already exists on your system, in which case you’ll get a harmless warning message.) We’ll then change to the bin directory and open a new file called ekill:</p>
                 <p class="lamda"></p>
                 <p class="cod">
                    $ cd ~/bin <br>
                    $ subl ekill
                 </p>
                 <p class="lamda">The ekill script itself starts with a “shebang” line (pronounced “shuh-BANG”, from “shell” and “bang”, with the latter being the common pronunciation of the exclamation point !):</p>
                 <p class="lamda"></p>
                 <p class="cod">
                    #!/bin/bash
                 </p>
                 <p class="lamda">This line tells our system to use the shell program located in /bin/bash to execute the script. The bash program corresponds to the Bourne-again shell (Bash) mentioned in Section 1.3, and in this context a shell script is often called a Bash script.8 Despite appearances, here the hash symbol # is not a comment character, which is potentially confusing because (as in Ruby) # is the character ordinarily used for a Bash comment line. Indeed, the initial version of our script includes several comment lines, as shown in Listing 3.8.</p>
                 <p class="lamda"></p>
                 <p class="cod">
                    Listing 3.8: A custom escalating kill script. <br>
                    ~/bin/ekill <br>
                    1#!/bin/bash <br>
                    2 <br>
                    3# Kill a process as safely as possible. <br>
                    4# Tries to kill a process using a series of signals with escalating urgency. <br>
                    5# usage: ekill <pid><br>
                    6
                    7# Assign the process id to the first argument. <br>
                    8pid=$1 <br>
                    9kill -15 $pid || kill -2 $pid || kill -1 $pid || kill -9 $pid <br>
                 </p>
                 <p class="lamda">Apart from the shebang in line 1, all other uses of # introduce comments. Then, Line 8 assigns the process id pid to $1, which in a shell script is the first argument to the command, e.g., 12241 in Listing 3.7. Line 9 then uses the “or” operator || to execute the kill command using the code 15 or 2 or 1 or 9, stopping on the first successful kill. (Again, don’t worry if you find this confusing; I include the explanation for completeness, but at this stage there’s no need to understand the details.)</p>
                 <p class="lamda">After typing the contents of Listing 3.8 into the script file, one thing you might notice is that the result has no syntax highlighting, as seen in Figure 3.18. This is because, unlike README.md (Section 2.2) and hello.rb (Section 3.2), the name ekill has no filename extension. Although some people would use a name like ekill.sh for shell scripts like this one—which would in fact allow our editor to highlight the syntax automatically—using an explicit extension on a shell script is a bad practice because the script’s name is the user interface to the program. As users of the system, we don’t care if ekill is written in Bash or Ruby or C, so calling it ekill.sh unnecessarily exposes the implementation language to the end-user. Indeed, if we wrote the first implementation in Bash but then decided to rewrite it in Ruby and then in C, every program (and programmer) using the script would have to change the name from ekill.sh to ekill.rb to ekill.c—an annoying and avoidable complication.</p>
                 <p class="cycle spec"><img src="/ressources/e65.png" alt=""></p>
                 <p class="fig">Figure 3.18: The ekill script with no syntax highlighting.</p>
                 <p class="lamda">Even though we’ve elected not to use a filename extension for the ekill script, we’d still like to get syntax highlighting to work. One way is to click on “Plain Text” in the lower right-hand corner of the editor (Figure 3.18) and change the highlighting language to the one we’re using. This requires us to know the language, though, and it would be nicer if we could get the editor to figure it out automatically. Happily, we can arrange exactly that, simply by closing the file and opening it again. To do this, click on the X to close the ekill tab (or press ⌘W) and then re-open it from the command line:</p>
                             
                               
                 <p class="cod">$ subl ekill</p>
                 <p class="lamda">Because of the shebang line in Listing 3.8, Sublime Text infers that the file is a Bash script. As a result, the detected file type changes from “Plain Text” to “Shell Script”, and syntax highlighting is activated (Figure 3.19).</p>
                 <p class="cycle spec"><img src="/ressources/e66.png" alt=""></p>
                 <p class="fig">Figure 3.19: The ekill script with syntax highlighting and a new detected file type.
                </p>
                 
                 
                 
                 <p class="lamda">At this point, we have a complete shell script, but typing ekill <pid> at the command line still won’t work. To add ekill to our system, we need to do two things: <br>
                
                    1-Make sure the ~/bin directory is on the system path, which is the set of directories where the shell program searches for executable scripts. <br>
                    2-Make the script itself executable. <br>
                    3-The list of directories on the path can be accessed via the special $PATH variable at the command line:
                
                </p>
                 <p class="cod">
                    $ echo $PATH
                 </p>
                 <p class="lamda">If ~/bin is on the list, you can skip this step, but it does no harm to follow it.</p>
                 <p class="lamda">Note: The literal directory ~/bin won’t appear in the $PATH list; instead the tilde will be expanded to your particular home directory. For me, ~/bin is the same as /Users/mhartl/bin, so that’s what appears in my PATH, but it will be different for you.</p>
                 <p class="lamda">To make sure ~/bin is on the path, we’ll edit the Bash profile file, which is related to the .bashrc file we saw in Section 1.3. Open ~/.bash_profile as follows:</p>
                <p class="cod">$ subl ~/.bash_profile</p>
                <p class="lamda">Then add the export line shown in Listing 3.9. If the source line isn’t already present, you should add that as well—it ensures that any aliases defined in .bashrc are added when .bash_profile gets run.</p>

                 <p class="cod">
                    Listing 3.9: Adding ~/bin to the path. <br>
                    ~/.bash_profile <br>
                    export PATH="~/bin:$PATH" <br>
                    source ~/.bashrc</p>
                 <p class="lamda">This uses the Bash export command to add ~/bin to the current path. (It’s worth noting that some systems use the environment variable $HOME in place of ~, but the two are synonyms. If for any reason ~ doesn’t work for you, it’s worth trying $HOME instead, as in $HOME/bin:$PATH.)</p>
                 <p class="lamda">To use it, we need to use source as in Section 1.4:</p>
                 <p class="cod">$ source ~/.bash_profile</p>
                 <p class="lamda">To make the resulting script executable, we need to use the “change mode” command chmod to add the “execute bit” x as follows:</p>
                 <p class="lamda"></p>
                 <p class="cod">$ chmod +x ~/bin/ekill</p>
                 <p class="lamda">At this point, we can verify that the ekill script is ready to go using the which command:</p>
                 <p class="lamda"></p>
                 <p class="cod">$ which ekill</p>
                 <p class="lamda">(This command is covered in Learn Enough Command Line to Be Dangerous.) The result should be the full path to ekill, which on my system looks like this:</p>
                 <p class="cod">$ which ekill <br>
                    /Users/mhartl/bin/ekill</p>
                <p class="lamda">On some systems, running source on .bash_profile might not be sufficient to put ekill on the path, so if which ekill returns no result then you should try exiting and restarting the shell program to reload the settings.</p>
                <p class="lamda">As you can see by typing ekill by itself at the command line, the current behavior is confusing if we neglect to include a process id:</p>

                 <p class="cod">
                    $ ekill <br>
                    confusing error message>
                 </p>
                 <p class="lamda">To make ekill friendlier in this case, we’ll arrange to print a usage message to the screen if the user neglects to include a process id. We can do this with the code in Listing 3.10, which I recommend typing in rather than copying and pasting. When writing the if statement, I especially recommend trying if⇥ to see if your editor comes with a tab trigger for making Bash if statements.</p>

                 <p class="cod">
                    Listing 3.10: An enhanced version of the escalating kill script. <br>
                    ~/bin/ekill <br>
                    #!/bin/bash <br> <br>
                    
                    # Kill a process as safely as possible. <br>
                    # Tries to kill a process using a series of signals with escalating urgency. <br>
                    # usage: ekill <pid> <br>
                    
                    # If the number of arguments is less than 1, exit with a usage statement. <br>
                    if [[ $# -lt 1 ]]; then <br>
                      echo "usage: ekill <pid>" <br>
                      exit 1 <br>
                    fi <br>
                    
                    # Assign the process id to the first argument. <br>
                    pid=$1 <br>
                    kill -15 $pid || kill -2 $pid || kill -1 $pid || kill -9 $pid
                 </p>
                 <p class="lamda">After adding the code in Listing 3.10, running ekill without an argument should produce a helpful message:</p>
                 <p class="cod">$ ekill <br>
                    usage: ekill <pid></p>
                        <p class="lamda">All we have left to do is to verify that ekill can actually be used to kill a process. This is left as an exercise (Section 3.3.1.)</p>
                  <h2 id="csix">3.3.1 Exercises</h2>
                  <p class="exo">1-Let’s test the functionality of ekill by making a process that hangs and applying the lessons from grepping processes in Learn Enough Command Line to Be Dangerous. We’ll start by opening two terminal tabs. In one tab, type tail to get a process that just hangs. In the other tab, use ps aux | grep tail to find the process id, then run ekill <pid> (substituting the actual id for <pid>). In the tab running tail, you should get something like “Terminated: 15” (Figure 3.20).</p>
                  <p class="exo">2-Write an executable script called hello that takes in an argument and prints out “Hello” followed by the argument. Be sure to chmod the script so it can run properly. Hint: Use the echo command. Bigger hint: Bash scripts interpolate dollar-sign variables into strings, so the $1 variable from Listing 3.8 can be used in a string like this: "Hello, $1".</p>
                   <p class="cycle spec"><img src="/ressources/e67.png" alt=""></p>
                   <p class="fig">Figure 3.20: The result of using ekill to kill a tail process.</p>


                   <button class="btn">Commencer: le chapitre</button>

             </div>
             
         </div>
 
         
        </section>
        <!-- 24-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="csept">3.4 Editing projects</h2>
                 <p class="lamda">So far we’ve used our text editor to edit single files, but it can also be used to edit entire projects all at once. As an example of such a project, we’ll download the sample application from the 3rd edition of the Ruby on Rails Tutorial. We won’t be running this application, but it will give us a large project to work with. As in Section 1.6 and Section 2.2, we’ll use the curl command to download the file to our local disk:</p>
                 <p class="cod">
                    $ cd <br>
                    $ curl -OL https://source.railstutorial.org/sample_app.zip
                 </p>
                 <p class="lamda">As indicated by the .zip filename extension, this is a ZIP file, so we’ll unzip it (using the unzip command) and then cd into the sample app directory:</p>
                 <p class="cod">
                    $ unzip sample_app.zip <br>
                    creating: sample_app_3rd_edition-master/ <br>
                    . <br>
                    . <br>
                    . <br>
                 $ cd sample_app_3rd_edition-master/
                 </p>
                 <p class="lamda">The way to open a project is to use a text editor to open the entire directory. Recall (from, e.g., navigating directories in Learn Enough Command Line to Be Dangerous) that . (“dot”) is the current directory, which means that we can open it using “subl dot”:</p>
                 <p class="cod">$ subl .</p>
                 <p class="lamda">The resulting text editor window includes the directory structure for our project, called a “tree view”, as seen in Figure 3.21. We can toggle its display using the View menu or a keyboard shortcut (Figure 3.22).

                 </p>
                 <p class="cycle spec"><img src="/ressources/e68.png" alt=""></p>
                 <p class="fig">Figure 3.21: The Rails Tutorial sample app in Sublime Text.</p>
                 <p class="cycle spec"><img src="/ressources/e69.png" alt=""></p>
                 <p class="fig">Figure 3.22: Toggling the tree view.</p>
                 <h2 id="chuit">3.4.1 Fuzzy opening</h2>
                 <p class="lamda">It’s possible to open a file by double-clicking on it in the tree view, but in a project with a lot of files this is often cumbersome, especially when the file is buried several subdirectories deep. A convenient alternative is fuzzy opening, which lets us open files by hitting (in Sublime Text) ⌘P and then typing some of the letters in the filename we want. For example, we can open a file called users_controller_test.rb by typing, say, “userscon” and then selecting from the drop-down menu, as shown in Figure 3.23. The letters don’t have to be contiguous in the filename, though, so typing “uctt” (for users controller test) will also work, as seen in Figure 3.24.</p>

                 <p class="cycle spec"><img src="/ressources/e70.png" alt=""></p>
                 <p class="fig">Figure 3.23: One way to open a file with fuzzy opening.</p>
                 <p class="cycle spec"><img src="/ressources/e71.png" alt=""></p>
                 <p class="fig">Figure 3.24: A second way to open a file with fuzzy opening.</p>
                
                 <p class="lamda">As a result of opening multiple files in a project, you will generally have multiple tabs open in your editor (Figure 3.25). I recommend learning the keyboard shortcuts to switch between them, which are typically things like ⌘1, ⌘2, etc. (By the way, this trick also works in many browsers, such as Chrome and Firefox.)</p>
               
                 <p class="cycle spec"><img src="/ressources/e72.png" alt=""></p>
                 <p class="fig">Figure 3.25: Opening multiple tabs.</p>


                 <h2 id="cneuf"> 3.4.2 Multiple panes</h2>
                 <p class="lamda">The default editor view we’ve seen in most of the previous examples consists of a single pane (as in “window pane”), but it’s often convenient to split the editor into multiple panes so that we can see more than one file at a time (Figure 3.26). I especially like to use different panes for different types of files, such as using the left pane for test code and the right pane for application code. It’s also often useful to open the same file in two different panes (Figure 3.27); as I wrote in the meta-tutorial Learn Enough Tutorial Writing to Be Dangerous:
                    <br>
                    When searching through the document for whatever reason (to fix an error, look up a label for a cross-reference, find a particular string, etc.), it’s usually inconvenient to move the cursor and hence lose our place. In this context, it’s useful to have the same file open in two different text editor windows… This way, we can use one pane as the main writing area and the other pane as a sort of “random access” window for moving around in the document.
                 </p>
                  <p class="lamda">Note: “Panes” are sometimes called “Groups” (e.g., in Sublime Text).</p>

                  <p class="cycle spec"><img src="/ressources/e73.png" alt=""></p>
                 <p class="fig">Figure 3.26: Using multiple panes.</p>

                 <p class="cycle spec"><img src="/ressources/e74.png" alt=""></p>
                 <p class="fig">Figure 3.27: Opening the same file in two different panes.</p>

                 <h2 id="sun">3.4.3 Global find and replace</h2>
                 <p class="lamda">We saw in Section 2.8 how to find and optionally replace content in a single file. When editing projects, it’s often useful to be able to do a global find and replace across multiple files. As usual, most editors have both a menu item (Figure 3.28) and a keyboard shortcut (often ⇧⌘F).</p>
                  <p class="cycle spec"><img src="/ressources/e75.png" alt=""></p>
                  <p class="fig">Figure 3.28: A menu item for global find and replace.</p>
                  <p class="lamda">An example of global find appears in Figure 3.29, which searches for the string “@user” in all project files. The command to globally replace this with “@person” appears in Figure 3.30.</p>
                  <p class="cycle spec"><img src="/ressources/e76.png" alt=""></p>
                  <p class="fig">Figure 3.29: The result of finding in project.</p>
                  <p class="cycle spec"><img src="/ressources/e77.png" alt=""></p>
                  <p class="fig">Figure 3.30: The result of replacing in project.</p>
                  <p class="lamda">For really advanced replacing, we can use a mini-language for text pattern matching called regular expressions (or regexes for short). (Regexes were mentioned briefly in Learn Enough Command Line to Be Dangerous.) Let’s see how to use regexes to add an annotation to all function definitions in the project, changing</p>

                  <p class="cod">def foo</p>
                  <p class="lamda">to</p>
                  <p class="cod">def foo    # function definition</p>
                  <p class="lamda">and</p>
                  <p class="cod">def bar</p>
                  <p class="lamda">to</p>
                  <p class="cod">def bar    # function definition</p>
                  <p class="lamda">My favorite way to build up regular expressions is using a web application like regex101, which lets us create regexes interactively (Figure 3.31). Moreover, such resources typically include a quick reference to assist us in finding the code for matching particular patterns (Figure 3.32).</p>
                 
                  <p class="cycle spec"><img src="/ressources/e78.png" alt=""></p>
                  <p class="fig">Figure 3.31: An online regex tester.</p>
                  <p class="cycle spec"><img src="/ressources/e79.png" alt=""></p>
                  <p class="fig">Figure 3.32: A close-up of the regex reference.</p>
                  <p class="lamda">We can use the reference in Figure 3.32 to discover a regex for def followed by any sequence of characters, which looks like this:</p>
                  <p class="cod">def .*</p>
                  <p class="lamda">Here . represents “any character”, while * matches zero or more of them. Doing a global search using the regex def .* matches all the function definitions in the project, as seen in Figure 3.33. Note that in most editors you’ll have to enable regex matching by clicking the regex match icon (.* in Figure 3.33).</p>
                  <p class="cycle spec"><img src="/ressources/e80.png" alt=""></p>
                  <p class="fig">Figure 3.33: Matching a regular expression.</p>
                  <p class="lamda">We can do the replacement mentioned above using parentheses to create two match groups:</p>
                  <p class="cod">(def) (.*)</p>
                  <p class="lamda">The first match group here is just the constant string def, while the second is whatever the function definition happens to be. (These match groups also appear in Figure 3.31.) Inside the “Replace” field in the editor, we can reference these groups using special dollar-sign match numbers, so that we can replace</p>
                  <p class="cod">(def) (.*)</p>
                  <p class="lamda">with</p>

                  <p class="cod">$1 $2    # function definition</p>
                  <p class="lamda">For example, when matching def foo, $1 is def and $2 is foo; when matching def bar, $1 is still def, but $2 is bar. This means we can annotate all the function definitions at the same time using the commands shown in Figure 3.34. Actually completing this replacement is left as an exercise (Section 3.4.4).</p>
                   
                  <p class="cycle spec"><img src="/ressources/e81.png" alt=""></p>
                  <p class="fig">Figure 3.34: Using a match grouping.</p>
                  <p class="lamda">One thing to bear in mind when using global find and replace is that it can be hard to undo. In the case of a single file, it’s easy enough to undo a bad replacement with ⌘Z (Section 2.6), but when replacing across multiple files we have to run ⌘Z in every affected file, which could be dozens. As a result, I recommend using global find and replace with great caution, and preferably in combination with a version control system such as Git. My general practice is to make a commit before any global search and replace so that I can easily undo it if there turns out to be a mistake. (See Learn Enough Git to Be Dangerous for more information.)</p>

                   <h2 id="sdeux">3.4.4 Exercises</h2>
                   <p class="exo">1-What is the keyboard shortcut in your editor for toggling the tree view?</p>
                   <p class="exo">2-What is the keyboard shortcut in your editor for splitting panes horizontally?</p>
                   <p class="exo">3-In the Rails Tutorial sample app project, open the file static_pages_controller.rb using fuzzy opening.</p>
                   <p class="exo">4-Use global find to find all occurrences of the string @user</p>
                   <p class="exo">5-Use global replace to change all occurrences of @user to @person</p>
                   <p class="exo">6-Use a regex match to annotate all function definitions with # function definition as described in the text.</p>
                  

                   <button class="btn">Commencer: le chapitre</button>
                
             </div>
             
         </div>
 
         
        </section>
        <!-- 25-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="strois">3.5 Customization</h2>
                 <p class="lamda">All good text editors are highly customizable, but the options are highly editor-dependent. The most important things are (a) to know what kind of customization is possible and (b) to apply your technical sophistication (Box 1.2) to figure out how to make the desired changes.</p>
                 <p class="lamda">For example, one student of the Ruby on Rails Tutorial wrote in asking about the dark background in the Cloud9 editor (e.g., Figure 2.5), wondering if it was possible to use a light background instead. I responded that it was almost certainly possible to change to a light background, even though I didn’t know how to do it offhand. I knew that every good programmer’s editor has multiple highlighting color schemes, font sizes, tab sizes, etc., so I was confident I could figure out how to change the background color on the Cloud9 editor. And indeed, by clicking around and looking for promising menu items (a textbook application of Box 1.2), I was able to discover the answer (Preferences > Themes > Syntax Theme > Cloud9 Day), as shown in Figure 3.35.</p>
                  <p class="cycle spec"><img src="/ressources/e82.png" alt=""></p>
                  <p class="fig">Figure 3.35: The Cloud9 editor with a light background.</p>
                  <p class="lamda">Another feature common to good text editors is some sort of package system. For example, we saw in Section 2.2.2 that Atom comes with a built-in package to preview Markdown, but in Sublime Text we need to install a separate package called Package Control to do it. One way to find new packages is to Google around for more information, leading to a site like that shown in Figure 3.36. The result is a new option, Sublime Text > Preferences > Package Control, as shown in Figure 3.37 and Figure 3.38.</p>

                  <p class="cycle spec"><img src="/ressources/e83.png" alt=""></p>
                  <p class="fig">Figure 3.36: Searching for a Sublime Text package.</p>
                  <p class="cycle spec"><img src="/ressources/e84.png" alt=""></p>
                  <p class="fig">Figure 3.37: Sublime Text’s Package Control menu item.</p>
                  <p class="cycle spec"><img src="/ressources/e85.png" alt=""></p>
                  <p class="fig">Figure 3.38: Sublime Text’s Package Control.</p>
                  <p class="lamda">Most editors allow you to create your own packages of commands, as well as often supporting snippets that let you define your own tab triggers (Section 3.1). These are advanced topics, so I recommend deferring them for now. Once you start becoming annoyed by having to repeatedly type the same boilerplate (as in, e.g., Listing 3.11), Google around to figure out how to add custom commands to your editor. (The code in Listing 3.11 is generated using the custom Sublime Text tab trigger clist (for “code listing”), which I have also ported to Sublime Text.)</p>
                  <p class="cod">
                    Listing 3.11: The boilerplate for a code listing in this document. <br>
                    \begin{codelisting} <br>
                    \label{code:} <br>
                    \codecaption{} <br>
                    %= lang: <br>
                    \begin{code} <br>
                    
                    \end{code} <br>
                    \end{codelisting}
                  </p>
                  <h2>3.5.1 Exercises</h2>
                  <p class="exo">Figure out how to change the syntax highlighting theme in your editor. Use the file from Listing 3.6 to confirm the change.</p>
       




                  <button class="btn">Commencer: le chapitre</button>


             </div>
             
         </div>
 
         
        </section>
        <!-- 26-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="squatre">3.6 Summary</h2>
                 <p class="lamda">
                    1-Autocomplete and tab triggers make it easy to type lots of text quickly. <br>
                    2-All good text editors have special features to support writing computer source code, including syntax highlighting, commenting out, indenting & dedenting, and goto line number. <br>
                    3-Many programmers think it’s perfectly fine to have lines that are more than 80 columns across, but they are wrong. (Speaking of which, there’s nothing quite so entertaining as a holy war (Box 1.5)…) <br>
                    4-Once you know how to use the command line and a text editor, it’s easy to add custom shell scripts to your system. <br>
                    5-It’s common to open entire projects (such as Ruby on Rails applications) all at once using the command line. <br>
                    6-Fuzzy opening is useful when editing projects with large numbers of files. <br>
                    7-Using multiple panes allows the editor to display more than one file at a time. <br>
                    8-Global find and replace is dangerous but powerful. <br>
                    9-All good programmer’s editors are extensible and customizable.
                 </p>
                 <p class="lamda">Important commands from this chapter are summarized in Table 3.1.</p>
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong>Command</strong></td>
                    <td class="align_left"><strong>Description</strong></td>
                    </tr>
                    <tr>
                    <td class="align_left">Select + ⌘/</td>
                    <td class="align_left">Toggle commenting out</td>
                    </tr>
                    <tr>
                    <td class="align_left">Select + ⇥</td>
                    <td class="align_left">Indent</td>
                    </tr>
                    <tr>
                    <td class="align_left">Select + ⇧⇥</td>
                    <td class="align_left">Dedent</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌃G</td>
                    <td class="align_left">Goto line number</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘W</td>
                    <td class="align_left">Close a tab</td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">$ echo $PATH</code></td>
                    <td class="align_left">Show the current path variable</td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">$ chmod +x &lt;filename&gt;</code></td>
                    <td class="align_left">Make <code class="tt">filename</code> executable</td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">$ unzip &lt;filename&gt;.zip</code></td>
                    <td class="align_left">Unzip a ZIP archive</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘P</td>
                    <td class="align_left">Fuzzy opening</td>
                    </tr>
                    <tr>
                    <td class="align_left">⌘1</td>
                    <td class="align_left">Switch focus to tab #1</td>
                    </tr>
                    <tr>
                    <td class="align_left">⇧⌘F</td>
                    <td class="align_left">Global find and replace</td>
                    </tr>
                    </tbody>
                    </table>

                    <p class="fig">Table 3.1: Important commands from Chapter 3.</p>
                    <button class="btn">Commencer: le chapitre</button>
                
             </div>
             
         </div>
 
        
        </section>
        <!-- 27-->
        <section >
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="scinq">3.7 Conclusion</h2>
                 <p class="lamda">Congratulations! You now know enough text editor to be dangerous. If you continue down this technical path, you’ll keep getting better at using text editors for years to come, but with the material in this tutorial you’ve got a great start. For now, you’re probably best off working with what you’ve got, applying your technical sophistication (Box 1.2) when necessary. Once you’ve got a little more experience under your belt, I recommend seeking out resources specific to your editor of choice. To get you started, here are some links to documentation for the editors mentioned in this tutorial:</p>
                  <p class="lamda">
                    <ul>
                        <li>Sublime Text docs</li>
                        <li>Atom docs</li>
                        <li>Cloud9 editor docs</li>
                    </ul>
                  </p>
                  <p class="lamda">
                    As a reminder, Learn Enough Text Editor to Be Dangerous is just one in a series of tutorials designed to teach the fundamentals of software development. The next step in the series is Learn Enough Git to Be Dangerous, and the full sequence appears as follows:
                  </p>
                  <p class="lamda">Good Luck !</p>
                  <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
        
        </section>       

    </main>
   
    
        <a href="#home" id="home" class="scroll-up-btn">
                <i class="fas fa-arrow-up"></i>
        </a>
   
        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-migrate/3.0.0/jquery-migrate.min.js"></script>
    <script src="/js/app.js"></script>
</body>
</html>