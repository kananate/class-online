<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="/ressources/logo-1.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://kit.fontawesome.com/75303112de.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ekko-lightbox/5.3.0/ekko-lightbox.css" />
    <title>Terminal</title>    
    <link rel="stylesheet" href="/css/type.css">
</head>
<body>
    
    <header>        
        <nav>
        <ul
            class="logo">
            <li><a href="/index.html"><img src="/ressources/logo-1.png" width="50" alt=""></a></li>
        </ul>
        <ul
        class="logo">
        <li><a href="#chap0">Avant Propos</a></li>
        </ul>
         <ul>
            <li class="title-item"><a href="#chap1">Chapitre 1</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#un">1. Basics</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#deux">1.1 Introduction</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#trois">1.2 Running a terminal</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quatre">1.2.1 Exercises</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cinq">1.3 Our first command</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#six">1.3.1 Exercises</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#sept">1.4 Man pages</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#huit">1.4.1 Exercises</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dix">1.5 Édition de la ligne</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#onze">1.5.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#douze">1.6 Nettoyage</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#treize">1.6.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quatorze">1.7 Résumé</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#quinze">1.7.1 Exercices</a></li>
          

         </ul>
         <ul>
            <li class="title-item"><a href="#chap2">Chapitre 2</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#seize">2. Manipulation de fichiers</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dixsept">2.1 Redirection et ajout</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dixhuit">2.1.1 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#dixneuf">2.2 Liste</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vin">2.2.1 Fichiers cachés</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinun">2.2.2 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vindeux">2.3 Renommer, copier, supprimer</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vintrois">2.3.1 Concision Unix</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinquatre">2.3.2 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vincinq">2.4 Résumé</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinsix">2.4.1 Exercices</a></li>
         </ul>
        
         <ul>
            <li class="title-item"><a href="#chap3">Chapitre 3</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinsept">3. Inspection des fichiers</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinhuit">3.1 Téléchargement d'un fichier</a></li>               
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#vinneuf">3.1.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#tun">3.2 Making heads and tails of it</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#tdeux">3.2.1 Nombre de mots et pipes</a></li> 
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#ttrois">3.2.2 Exercices</a></li>                              
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#tquatre">3.3 Moins c'est plus</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#tcinq">3.3.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#tsix">3.4 Grepping</a></li> 
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#tsept">3.4.1 Exercices</a></li>  
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#thuit">3.5 Résumé</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#tneuf">3.5.1 Exercices</a></li> 
                     
         </ul>
         <ul>
            <li class="title-item"><a href="#chap4">Chapitre 4</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qun">4. Répertoires</a></li>
            <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qdeux">4.1 Structure du répertoire</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qtrois">4.1.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qquatre">4.2 Création de répertoires</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qcinq">4.2.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qsix">4.3 Navigation dans les répertoires</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qsept">4.3.1 Exercices</a></li>                
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qhuit">4.4 Renommer, copier et supprimer des répertoires</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#qneuf">4.4.1 Grep redux</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cun">4.4.2 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cdeux">4.5 Résumé</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#ctrois">4.5.1 Exercices</a></li>
                <li><i class="fa-solid fa-circle-chevron-right"></i><a href="#cquatre">4.6 Conclusion</a></li>              
         </ul>
        </nav>
    </header>
    <main>
        <!-- A propos -->     
        <section>
         <div class="container-video">
             <h1>Terminal</h1>
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 
                 <h2 id="chap0"> QUI SUIS-JE ?</h2>

                <p class="lamda">
                    ABDOULAYE DIALLO est un développeur de logiciels passionné par l'enseignement. <br> Il a travaillé avec de nombreuses start-ups sur des projets personnels et en tant que freelance très bien noté sur les places de marché. <br>

                    ABDOULAYE DIALLO a enseigné la programmation et le marketing à plus de 100 000 étudiants en ligne et hors ligne en tant que formateur. <br>
                    
                    ABDOULAYE DIALLO maîtrise l'art d'expliquer des sujets très complexes de la manière la plus simple possible, facile à comprendre et à suivre. Ses cours vidéo sont également utilisés par des entreprises pour former leurs employés et par des universités pour préparer leurs étudiants et améliorer leurs compétences en fonction des exigences du secteur.
                    
                    
                  
                </p>
                <button class="btn">Commencer: le chapitre</button>
                
             </div>
             
         </div>
 
        </section>
        <!-- 1 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3 id="chap1">Chapitre 1</h3>
                 <h2 id="trois">1.2 Exécution d'un terminal</h2>
                 <p class="lamda">Pour exécuter une commande en ligne de commande, nous devons d’abord démarrer un terminal , qui est le programme qui nous donne une ligne de commande.Les détails exacts dépendent du système d’exploitation particulier que vous utilisez.</p>
                 <h2>macOS</h2>
                 <p class="lamda">Sous macOS, vous pouvez ouvrir une fenêtre de terminal à l'aide de l'application macOS Spotlight , que vous pouvez lancer soit en tapant ⌘␣ (Commande-espace), soit en cliquant sur la loupe dans la partie supérieure droite de votre écran.Une fois que vous avez lancé Spotlight, vous pouvez démarrer un programme de terminal en tapant « terminal » dans la barre de recherche Spotlight.(Si vous souhaitez utiliser un programme de terminal plus avancé et personnalisable, je vous recommande d'installer iTerm , mais cette étape est facultative.)</p>

                 <p class="lamda">À ce stade, vous pourriez voir l’alerte affichée dans la liste  1.1 .</p>
                 <p class="cod">
                    Liste 1.1 : une alerte de terminal macOS. <br>
                    L'interpréteur de commandes interactif par défaut est désormais zsh. <br>
                    Pour mettre à jour votre compte et utiliser zsh, exécutez « chsh -s /bin/zsh ». <br>
                    Pour plus d'informations, consultez la page https://support.apple.com/kb/HT208050. <br>
                    
                    [~]$
                 </p>
                 <p class="lamda">Cette alerte est le résultat d'une modification apportée dans macOS Catalina .Vous n'avez rien à faire pour le moment ; nous aborderons ce problème la première fois qu'il fera une différence dans ce didacticiel ( Section  2.3 ).Pour plus d'informations, consultez l'article du blog 643-code « Utilisation de Z Shell sur Mac avec les didacticiels 643-code ».</p>

                 <h2>Linux</h2>
                 <p class="lamda">Sous Linux, vous pouvez cliquer sur l’icône du terminal comme indiqué dans la Figure  1.3 .Le résultat devrait ressembler à la Figure  1.4 , bien que les détails exacts de votre système soient probablement différents.</p>
                 <p class="cycle spec"><img src="/ressources/t1.png" alt=""></p>
                 <p class="fig">Figure 1.3 : L’icône du terminal Linux.</p>
                 <h2>Windows</h2>
                 <p class="lamda">Sous Windows, l'option recommandée est d'installer Linux (que, incroyablement, Microsoft a décidé de prendre en charge nativement) comme décrit dans la section Windows du tutoriel gratuit 643-code Dev Environment pour se perfectionner .Une fois Linux installé, vous devez rechercher une icône de terminal comme décrit dans la section  1.2.2 .Appliquez votre sophistication technique ( encadré  1.4 ) si vous êtes bloqué.</p>
                 <h2>Fenêtre du terminal</h2>
                 <p class="lamda">Quel que soit le système d'exploitation que vous utilisez, votre fenêtre de terminal devrait ressembler à la Figure  1.4 , bien que les détails puissent différer.</p>
                 <p class="cycle spec"><img src="/ressources/t2.png" alt=""></p>
                 <p class="fig">Figure 1.4 : Une fenêtre de terminal.</p>
                 <p class="lamda">L'exemple que nous avons vu dans la figure  1.2 comprend tous les éléments typiques d'une commande, comme illustré dans la figure  1.5 : l' invite (pour « inciter » l'utilisateur à faire quelque chose) suivie d'une commande (comme dans « donner une commande à l'ordinateur »), d'une option (comme dans « choisir une option différente »), 3 et d'un argument (comme dans « l' argument d'une fonction » en mathématiques).Il est essentiel de comprendre que l'invite est fournie automatiquement par le terminal et que vous n'avez pas besoin de la saisir.(En effet, si vous le saisissez, cela entraînera probablement une erreur.)De plus, les détails exacts de l’invite peuvent différer et ne sont pas importants pour les besoins de ce didacticiel ( Encadré  1.2 ).</p>
                 <p class="cycle spec"><img src="/ressources/t3.png" alt=""></p>
                 <p class="fig">Figure 1.5 : Anatomie d’une ligne de commande.(Votre invite peut être différente.)</p>
                 <div class="comment">Encadré 1.2. Quelle est l'invite ? <br>
                    Chaque ligne de commande commence par un ou plusieurs symboles conçus pour vous « inciter » à agir.L'invite se termine généralement par un signe dollar  $ou un signe de pourcentage  %et est précédée d'informations qui dépendent des détails de votre système.Par exemple, sur certains systèmes, l’invite peut ressembler à ceci :
                    <br>
                    <p class="cod"> Le MacBook Air de Michael :~ mhartl$ </p>   <br>
                    Dans la figure  1.4 , l’invite ressemble plutôt à ceci : <br>
                    <p class="cod"> 
                    [~]$ </p> <br>
                    et dans la figure  1.5, cela ressemble à ceci : <br>
                    <p class="cod"> 
                    [projets]$ </p>  <br>
                    Enfin, l’invite que je regarde en ce moment ressemble à ceci : <br>
                    <p class="cod"> 
                    [learn_enough_command_line (premier brouillon)]$  </p><br>
                    Pour les besoins de ce didacticiel, les détails de l'invite ne sont pas importants, mais nous discuterons des moyens utiles pour personnaliser l'invite à partir du prochain didacticiel après celui-ci (le tutorield'éditeur de texte  ).
                </div>
                <h2 id="quatre">1.2.1 Exercices</h2>
                <p class="lamda">Apprendre suffisamment de ligne de commande  comprend un grand nombre d'exercices.Je vous recommande fortement de prendre l'habitude de les essayer avant de passer à la section suivante, car ils renforcent le matériel que nous venons de couvrir et vous donneront une pratique essentielle dans l'utilisation des nombreuses commandes abordées.En général, il n'est pas nécessaire de procéder ainsi. Si vous êtes bloqué, c'est parfois une bonne idée de continuer et de revoir l'exercice plus tard.En effet, c’est également un bon conseil pour le texte principal : vous serez surpris de voir à quelle fréquence une idée apparemment impossible ou un problème insoluble paraîtra facile la deuxième fois.</p>
                  <p class="exo">1-En vous référant à la Figure  1.5 , identifiez l’invite, la commande, les options, les arguments et le curseur dans chaque ligne de la Figure  1.6 .</p>
                  <p class="exo">2-La plupart des programmes de terminaux modernes ont la capacité de créer plusieurs onglets ( Figure  1.7 ), qui sont utiles pour organiser un ensemble de fenêtres de terminaux associées .En examinant les éléments de menu de votre programme de terminal ( Figure  1.8 ), découvrez comment créer un nouvel onglet. Crédit supplémentaire : apprenez le raccourci clavier pour créer un nouvel onglet.(Apprendre les raccourcis clavier de votre système est une excellente habitude à cultiver.)</p>
                  <p class="cycle spec"><img src="/ressources/t4.png" alt=""></p>
                 <p class="fig">Figure 1.6 : Une série de commandes typiques.</p>
                 <p class="cycle spec"><img src="/ressources/t5.png" alt=""></p>
                 <p class="fig">Figure 1.7 : Une fenêtre de terminal avec trois onglets.</p>
                 <p class="cycle spec"><img src="/ressources/t6.png" alt=""></p>
                 <p class="fig">Figure 1.8 : Certains éléments de menu pour le terminal macOS par défaut.</p>


                 <button class="btn">Commencer: le chapitre</button>

             </div>
             
         </div>
 
        
        </section>
        <!-- 2 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 
<h2 id="cinq">1.3 Notre première commit</h2>
                <p class="lamda">Nous sommes maintenant prêts à exécuter notre première commande, qui affiche le mot « hello » à l'écran. (L'endroit où les caractères sont affichés est appelé « sortie standard », qui correspond généralement à l'écran et fait rarement référence à une imprimante physique.) La commande est echo, et l'argument est la chaîne de caractères (ou simplement chaîne) que nous voulons afficher. Pour exécuter la commande echo, tapez « echo hello » à l'invite, puis appuyez sur la touche Retour (également appelée Entrée) :</p>
                <p class="cod">
$ echo hello <br>
hello <br>
$
</p>
                <p class="lamda">(Je recommande de toujours taper les commandes vous-même, ce qui vous permettra d'apprendre davantage que si vous vous contentez de copier-coller.) Ici, nous voyons que echo hello affiche « hello », puis renvoie une autre invite. Notez que, par souci de concision, j'ai omis tous les caractères de l'invite à l'exception du signe dollar $.
                
<p class="lamba">Pour clarifier le schéma, essayons une deuxième commande echo :</p>
                <p class="cod">
$ echo « goodbye » <br>
goodbye <br>
$ echo “goodbye” <br>
goodbye <br>
$
</p>
                <p class="lamda">Notez ici que nous avons mis « goodbye » entre guillemets — et nous voyons également que nous pouvons utiliser soit des guillemets doubles, comme dans « goodbye », soit des guillemets simples, comme dans « goodbye ». Ces guillemets peuvent être utilisés pour regrouper visuellement des chaînes de caractères, bien que dans de nombreux contextes, ils ne soient pas requis par echo (listing 1.2).</p>
                
<p class="cod">
                    Listing 1.2 : Affichage de « hello, goodbye » de deux manières différentes. <br>
$ echo hello, goodbye <br>
hello, goodbye <br>
$ echo « hello, goodbye » <br>
hello, goodbye <br>
$
</p>
                
<p class="lamda">Une chose qui peut arriver lorsque vous utilisez des guillemets est de ne pas les faire correspondre accidentellement, comme suit :</p>
                <p class="cod">
$ echo « hello, goodbye <br>
>
</p>
                 
<p class="lamda">
                    À ce stade, nous semblons être bloqués. Il existe des moyens spécifiques pour sortir de cette impasse (en fait, dans ce cas, vous pouvez simplement ajouter une citation de fermeture et appuyer sur Entrée), mais il est bon d'avoir une stratégie générale pour se sortir d'une situation difficile (Figure 1.9).6 Cette stratégie s'appelle « Ctrl-C » (Encadré 1.3).
                 
</p>
                 <p class="cycle spec"><img src="/ressources/t7.png" alt=""></p>
                 <p class="fig">Figure 1.9 : Ce chat semble être bloqué et devrait probablement appuyer sur Ctrl-C.
                 
<div class="comment">
                    Encadré 1.3. Se sortir d'une situation difficile <br>
Lorsque vous utilisez la ligne de commande, de nombreux éléments peuvent vous causer des problèmes, c'est-à-dire que le terminal peut se bloquer ou se retrouver dans un état qui rend difficile, voire impossible, la saisie d'autres commandes. Voici quelques exemples de telles commandes :
<br>
                    
<p class="cod">
                     $ echo "hello </p> <br>
                     <p class="cod">$ grep foobar </p> <br>
                     <p class="cod">$ yes </p> <br>
                     <p class="cod">$ tail </p> <br>
                     <p class="cod">$ cat </p><br>
                     Dans tous les cas, la solution est la même : appuyez sur Ctrl-C (prononcé « contrôle-C »). Ici, Ctrl fait référence à la touche « contrôle » de votre clavier, et C fait référence à la touche marquée « C ». Ctrl-C signifie donc « Tout en maintenant la touche contrôle enfoncée, appuyez sur C ». En particulier, C ne fait pas référence à la lettre majuscule C, vous ne devez donc pas appuyer sur Maj en plus de Ctrl. (Ctrl-C envoie un code de contrôle au terminal et n'a rien à voir avec la production d'un C majuscule lors de la saisie de texte normal.) Le résultat de la saisie de Ctrl-C est parfois écrit sous la forme ⌃C, comme ceci :
                            <br>
                            <p class="cod">
                     $ tail <br>
                     ^C  </p>  <br>
                    
Les origines de Ctrl-C sont quelque peu obscures, mais comme aide-mémoire, j'aime à penser que cela signifie « annuler ». Quelle que soit la manière dont vous vous en souvenez, souvenez-vous-en : lorsque vous rencontrez des difficultés dans la ligne de commande, la meilleure solution est généralement d'appuyer sur Ctrl-C.
                         <br>
Remarque : lorsque Ctrl-C ne fonctionne pas, dans 90 % des cas, appuyer sur ESC (échap) fera l'affaire.
                 
</div>
                  <h2 id="six">1.3.1 Exercices</h2>
<p class="exo">
1-Écrivez une commande qui affiche la chaîne « hello, world ». Bonus : comme dans le listing 1.2, faites-le de deux manières différentes, avec et sans guillemets.
                  
</p>
                  <p class="exo">
2-Tapez la commande echo 'hello (avec un guillemet simple non apparié), puis sortez-vous de cette situation délicate en utilisant la technique de l'encadré 1.3.
</p>

                  <button class="btn">Commencer: le chapitre</button>


             </div>
             
         </div>
 
        
        </section>
        <!-- 3 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="sept">1.4 Pages de manuel
                </h2>
                <p class="lamda">Le programme que nous utilisons pour exécuter une ligne de commande, techniquement connu sous le nom de shell , 7 inclut un outil puissant (bien que souvent cryptique) pour en savoir plus sur les commandes disponibles.Cet outil est lui-même une commande en ligne de commande appelée man(abréviation de « manuel »), et nous l’utilisons en tapant manpuis le nom de la commande sur laquelle nous voulons en savoir plus :</p>
                <p class="cod">$ homme écho</p>
                <p class="lamda">Le résultat est d'imprimer une page de manuel pour la commande en question (dans ce cas, echo).Les détails dépendent du système, mais sur mon système, le résultat de l'exécution man echoapparaît comme dans la liste  1.3 .</p>
                <p class="cod">
                    Liste 1.3 : Le résultat de l'exécution de man echo. <br>
                    $ man echo <br> 
                    ECHO(1) Manuel des commandes générales BSD ECHO(1) <br>
                    
                    NAME  <br>
                       echo -- écrire les arguments sur la sortie standard <br>
                    
                    SYNOPSIS  <br>
                       echo [-n] [chaîne ...] <br> 
                    
                    DESCRIPTION  br 
                       L'utilitaire echo écrit tous les opérandes spécifiés, séparés par des caractères blancs simples <br>
                       (` ') et suivis d'un caractère de nouvelle ligne (`\n'), sur la <br>
                       sortie standard. <br>
                    
                       L'option suivante est disponible : <br>
                    
                       -n Ne pas afficher le caractère de retour à la ligne final. Ceci peut également être
                          obtenu en ajoutant « \c » à la fin de la chaîne, comme le font 
                          les systèmes compatibles iBCS2. Notez que cette option, ainsi que l' 
                          effet de « \c », sont définis par l'implémentation dans la norme IEEE 1003.1-2001 
                          (« POSIX.1 ») telle que modifiée par le Cor. 1-2002. Les applications visant 
                          une portabilité maximale sont fortement encouragées à utiliser printf(1) pour 
                          supprimer le caractère de retour à la ligne 
                </p>
                <p class="lamda">Sur la dernière ligne du listing  1.3 , notez la présence de deux points  :, ce qui indique qu'il y a plus d'informations ci-dessous.Les détails de cette dernière ligne dépendent également du système, mais sur n'importe quel système, vous devriez pouvoir accéder aux informations suivantes une ligne à la fois en appuyant sur la touche fléchée vers le bas, ou une page à la fois en appuyant sur la barre d'espace.Pour quitter la page de manuel, appuyez sur « q » (pour « quitter »).(Cette interface vers les pages de manuel est la même que pour le lessprogramme, que nous découvrirons dans la section  3.3 .)</p>
                
                <p class="cycle spec"><img src="/ressources/t8.jpg" alt=""></p>
                <p class="fig">Figure 1.10 : Application manà man.</p>
                <p class="lamda">Parce qu'il mans'agit en soi d'une commande, nous pouvons l'appliquer manà man( Figure  1.10 ), 8 comme indiqué dans la liste  1.4 .</p>
                <p class="cod">
                    Liste 1.4 : Le résultat de l'exécution de man man. <br>
                    $ homme homme <br>
                     homme(1) homme(1) <br>
                    
                    NAME  <br>
                        man - formater et afficher les pages du manuel en ligne <br>
                    
                    SYNOPSIS <br>
                        man [-acdfFhkKtwW] [--path] [-m system] [-p string] [-C config_file] <br>
                        [-M pathlist] [-P pager] [-B browser] [-H htmlpager] [-S section_list] <br>
                        [section] name ... <br>
                    
                    DESCRIPTION 
                        man formate et affiche les pages de manuel en ligne. Si vous spécifiez section 
                        , man ne consulte que cette section du manuel. name est normalement 
                        le nom de la page de manuel, qui est généralement le nom d'une commande, 
                        d'une fonction ou d'un fichier. Cependant, si name contient une barre oblique (/), man 
                        l'interprète comme une spécification de fichier, ce qui permet d'exécuter man ./foo.5 
                        ou même man /cd/foo/bar.1.gz. <br>
                    
                        Voir ci-dessous pour une description de l'endroit où man recherche les 
                        fichiers de page de manuel. <br>
                    
                    OPTIONS  <br>
                        -C fichier_config 
                </p>
                <p class="lamda">Nous pouvons voir à partir de la liste  1.4 que le synopsis de manressemble à ceci :</p>
                <p class="cod">homme [-acdfFhkKtwW] [--chemin] [-m système] [-p chaîne] ...</p>
                <p class="lamda">C’est ce que je voulais dire plus haut lorsque j’ai décrit les pages de manuel comme « souvent cryptiques ».En effet, dans de nombreux cas, je trouve les détails des pages de manuel presque impossibles à comprendre, mais être capable de parcourir la page de manuel pour obtenir un aperçu de haut niveau d'une commande est une compétence précieuse, qui vaut la peine d'être acquise.Pour vous habituer à lire les pages de manuel, je vous recommande de les exécuter man <command name>lorsque vous rencontrez une nouvelle commande.Même si les détails ne sont pas entièrement clairs, la lecture des pages de manuel aidera à développer la précieuse compétence de sophistication technique ( Encadré  1.4 ).</p>
               
                <p class="comment">
                    Encadré 1.4. Sophistication technique <br>
                    En mathématiques, de nombreux sujets peuvent être développés en appliquant la déduction pure à un petit nombre d'hypothèses ou d'axiomes ; les exemples incluent l'algèbre, la géométrie, la théorie des nombres et l'analyse.De ce fait, ces matières sont complètement autonomes et n’ont donc pas de prérequis formels : en principe, même un petit enfant pourrait les apprendre.En pratique, cependant, quelque chose d’autre est requis, et les mathématiciens recommandent souvent le prérequis informel de la maturité mathématique , qui consiste en l’expérience et la sophistication générale nécessaires pour comprendre et écrire des preuves mathématiques. <br> <br>
                    
                    Dans le domaine technologique, une compétence similaire (ou, plus précisément, un ensemble de compétences) existe sous la forme de sophistication technique .En plus des « compétences techniques » comme la familiarité avec les éditeurs de texte et la ligne de commande Unix, la sophistication technique comprend des « compétences générales » comme la recherche d'éléments de menu prometteurs et la connaissance des types de termes de recherche à insérer dans Google (comme illustré dans « Tech Support Cheat Sheet » de xkcd ), ainsi qu'une attitude consistant à faire ce qu'il faut pour que la machine fasse nos enchères ( encadré  1.1 ). <br> <br>
                    
                    Ces compétences générales et cette attitude sont difficiles à enseigner directement, donc à mesure que vous progressez dans ce tutoriel 643-code et les suivants , vous devez toujours être à la recherche d'opportunités pour augmenter votre sophistication technique (comme, par exemple, apprendre à obtenir l'essentiel d'un programme en parcourant sa page de manuel ( Section  1.4 )).Au fil du temps, l'effet cumulatif sera que, comme l'auteur de « Tech Support Cheat Sheet », vous aurez la capacité apparemment magique de tout faire dans chaque programme. <br>
                    
                    Au fait, il manque à « Tech Support Cheat Sheet » quelques techniques importantes pour résoudre les problèmes courants (énumérées ici par ordre croissant de gravité, qui est l'ordre dans lequel vous devriez les essayer) : <br> <br>
                    
                    1-« Avez-vous redémarré l’application ? » <br>
                    2-« Avez-vous redémarré l'appareil ? » ou (question étroitement liée) « L'avez-vous éteint, attendu 30 secondes, puis rallumé ? »(C'est ce qu'on appelle le cycle d'alimentation .) <br>
                    3-« Avez-vous essayé de désinstaller et de réinstaller l’application ? » <br> <br>
                    L’étape 2 à elle seule résout probablement 90 % des problèmes informatiques inexpliqués.
                </p>
                <h2 id="huit">1.4.1 Exercices</h2>
                <p class="exo">1-Selon la page de manuel, quelles sont les descriptions officielles courtes et longues de echovotre système ?</p>
                <p class="exo">2-Comme indiqué dans la liste  1.2 , par défaut, la echocommande imprime son argument à l'écran, puis place la nouvelle invite sur une nouvelle ligne.La façon dont il fait cela est en ajoutant un caractère spécial appelé nouvelle ligne qui place littéralement la chaîne sur une nouvelle ligne.(Le caractère de nouvelle ligne s'écrit généralement comme \n, prononcé « barre oblique inverse n ».)Parce qu'il echoest souvent utilisé dans les programmes pour imprimer une séquence de chaînes non séparées par des sauts de ligne, il existe une option de ligne de commande spéciale pour empêcher l'insertion du saut de ligne.
                    En lisant la page de manuel de echo, déterminez la commande nécessaire pour afficher « hello » sans la nouvelle ligne de fin et vérifiez à l’aide de votre terminal qu’elle fonctionne comme prévu. Conseils : Pour déterminer l'emplacement de l'option de ligne de commande, il peut être utile de se référer à la Figure  1.5 .En comparant votre résultat avec les listes  1.5 et 1.6  , vous devriez être en mesure de vérifier que vous avez utilisé l'option correctement.( Remarque : cet exercice peut échouer lors de l’utilisation du programme de terminal par défaut sur certaines anciennes versions de macOS.Dans ce cas, je recommande d'installer iTerm (ce qui n'est pas une mauvaise idée de toute façon).)</p>
                <p class="cod">
                    Liste 1.5 : Le résultat de l'exécution echoavec une nouvelle ligne (sans option). <br>
                    bonjour  <br>
                    [~]$
                </p>
                <p class="cod">
                    Liste 1.6 : Le résultat de l'exécution echosans nouvelle ligne ( avec option). <br>
                    bonjour[~]$
                </p>

                




                <button class="btn">Commencer: le chapitre</button>



             </div>
             
         </div>
 
        </section>
        <!--4--> 
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="dix">1.5 Modification de la ligne</h2>
                <p class="lamda">Les lignes de commande incluent plusieurs fonctionnalités pour faciliter la répétition des commandes précédentes, éventuellement sous forme modifiée.Ces fonctionnalités de ligne de commande et bien d'autres impliquent souvent des touches spéciales sur le clavier. Pour référence, le tableau  1.1 montre ces symboles pour les différentes touches d'un clavier Macintosh classique.Appliquez votre sophistication technique ( encadré  1.4 ) si votre clavier diffère.</p>
                <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Clé</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Symbole</font></font></strong></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Commande</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">⌘</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Contrôle</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">⌃</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Changement</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">⇧</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Option</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">⌥</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Haut, bas, gauche, droite</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">↑ ↓ ← →</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Entrée/Retour</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">↵</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Languette</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">⇥</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Supprimer</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">⌫</font></font></td>
                    </tr>
                    </tbody>
                    </table>
                    <p class="fig">Tableau 1.1 : Divers symboles du clavier.</p>
                
                
                
                
                <p class="lamda">L’une des manières les plus utiles de modifier la ligne est d’appuyer sur la « flèche vers le haut » ↑, ce qui récupère simplement la commande précédente.Appuyer à nouveau sur la flèche vers le haut permet de remonter dans la liste des commandes, tandis que la « flèche vers le bas » ↓ permet de revenir vers le bas.</p>
                <p class="lamda">D'autres méthodes courantes pour modifier la ligne utilisent la touche de contrôle, qui (comme nous l'avons vu dans l'encadré  1.3 ) est généralement écrite sous la forme Ctrlou  ⌃.Par exemple, lorsque vous saisissez une nouvelle commande ou que vous traitez une commande précédente, il est souvent pratique de pouvoir se déplacer rapidement dans la ligne.Supposons que nous tapions</p>
                <p class="cod">au revoir</p>
                <p class="lamda">seulement pour se rendre compte que nous voulions le mettre echodevant.Nous pourrions utiliser la touche flèche gauche ← pour arriver au début de la ligne, mais il est plus simple de taper ⌃A, ce qui nous y amène immédiatement.De même, ⌃Ese déplace jusqu'à la fin de la ligne .Enfin, ⌃Urevenons au début de la ligne et permettons-nous de recommencer.</p>
                <p class="lamda">La combinaison de ⌃A, ⌃E, et ⌃Ufonctionnera sur la plupart des systèmes, mais elle ne vous sera pas d'une grande utilité si vous éditez une ligne plus longue, comme celle-ci contenant la première ligne du Sonnet 1 de William Shakespeare ( Listing  1.7 ).</p>
                <p class="cod">
                    Liste 1.7 : Impression de la première ligne du premier sonnet de Shakespeare. <br>
                    $ echo  "Nous désirons l'augmentation des créatures les plus belles,"
                </p>
                <p class="lamda">Supposons que nous voulions changer « De » en « DE » pour correspondre plus étroitement au texte du sonnet original ( Figure  1.11 ) .Nous pourrions taper ⌃Asuivi de la touche fléchée droite plusieurs fois, mais sur certains systèmes, il est possible de se déplacer directement à l'endroit souhaité en combinant le clavier et la souris via Option-clic.C'est-à-dire que vous pouvez maintenir enfoncée la touche Option de votre clavier (si elle existe), 11 puis cliquer avec le pointeur de la souris à l'endroit de la commande où vous souhaitez placer le curseur.Cela nous permettrait d’aller directement au « o » dans « De », ce qui nous permettrait de supprimer le « r » et d’obtenir directement la liste  1.8 .</p>
                <p class="cycle spec"><img src="/ressources/t9.jpg" alt=""></p>
                <p class="fig">Figure 1.11 : L'apparence originale du premier sonnet de Shakespeare.</p>
                <p class="cod">Liste 1.8 : Le résultat de la modification d’une commande de ligne de commande plus longue. <br>
                    $ echo  "Des plus belles créatures nous désirons l'accroissement,"</p>
                <p class="lamda">Je me déplace généralement sur la ligne de commande avec une combinaison de touches ⌃A, ⌃E, et de flèches droite et gauche, mais pour les commandes plus longues, Option-clic peut être d'une grande aide.(Je change aussi fréquemment d'avis sur la commande exacte que je tape, auquel cas je trouve généralement que cliquer ⌃Uet recommencer est le moyen le plus rapide de procéder.)</p>
                <h2 id="onze">1.5.1 Exercices</h2>
                <p class="exo">1-À l’aide de la flèche vers le haut, imprimez à l’écran les chaînes « fee », « fie », « foe » et « fum » sans les retaper echoà chaque fois.</p>
                <p class="exo">2-En commençant par la ligne du listing  1.7 , utilisez n'importe quelle combinaison de ⌃A, ⌃E, touches fléchées ou Option-clic pour changer les occurrences du s court en s long archaïque « ſ » afin de correspondre à l'apparence de l'original ( Figure  1.11 ).En d’autres termes, l’argument echodevrait être le suivant : « Nous désirons l’augmentation des plus belles créatures ». Astuce : il est peu probable que votre clavier puisse produire « ſ » de manière native, alors copiez-le à partir du texte de ce didacticiel ou recherchez-le sur Google et copiez-le à partir d'Internet.(Si vous avez des difficultés à copier et coller dans votre terminal, je vous suggère d'appliquer les idées de l'encadré  1.4 pour savoir comment procéder sur votre système.)</p>






                <button class="btn">Commencer: le chapitre</button>

             </div>
             
         </div>
 
         
        </section>
        <!-- 5 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="douze">1.6 Nettoyage</h2>
                 <p class="lamda">Lors de l'utilisation de la ligne de commande, il est parfois pratique de pouvoir nettoyer en effaçant l'écran, ce que nous pouvons faire avec clear:</p>
                 <p class="cod">$ clair</p>
                 <p class="lamda">Un raccourci clavier pour cela est ⌃L.</p>
                 <p class="lamda">De même, lorsque nous avons terminé avec une fenêtre de terminal (ou un onglet) et que nous sommes prêts à quitter, nous pouvons utiliser la exitcommande :</p>
                 <p class="cod">$ sortie</p>
                 <p class="lamda">Un raccourci clavier pour cela est ⌃D.</p>
                 <h2 id="treize">1.6.1 Exercices</h2>
                 <p class="exo">Effacer le contenu de l'onglet actuel</p>
                 <p class="exo">Ouvrez un nouvel onglet, exécutez echo 'hello', puis quittez</p>
                 <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
        
        </section>
        <!-- 6 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 1</h3>
                 <h2 id="quatorze">1.7 Résumé</h2>
                 <p class="lamda">Les commandes importantes de ce chapitre sont résumées dans le tableau  1.2 .</p>
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Commande</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Description</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Exemple</font></font></strong></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">echo &lt;string&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Imprimer la chaîne à l'écran</font></font></td>
                    <td class="align_left"><code>$ echo hello</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">man &lt;command&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Afficher la page de manuel pour la commande</font></font></td>
                    <td class="align_left"><code>$ man echo</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">⌃C</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Sortez du pétrin</font></font></td>
                    <td class="align_left"><code>$ tail ⌃C</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">⌃A</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Déplacer au début de la ligne</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">⌃E</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Déplacer vers la fin de la ligne</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">⌃U</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Supprimer jusqu'au début de la ligne</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Option-clic</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Déplacer le curseur à l'emplacement cliqué</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Flèche haut et bas</font></font></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Faire défiler les commandes précédentes</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left">
                    <code class="tt">clear</code><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">ou</font></font><code class="tt">⌃L</code>
                    </td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Effacer l'écran</font></font></td>
                    <td class="align_left"><code>$ clear</code></td>
                    </tr>
                    <tr>
                    <td class="align_left">
                    <code class="tt">exit</code><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">ou</font></font><code class="tt">⌃D</code>
                    </td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Terminal de sortie</font></font></td>
                    <td class="align_left"><code>$ exit</code></td>
                    </tr>
                    </tbody>
                    </table>
                    <h2 id="quinze">1.7.1 Exercices</h2>
                    <p class="exo">1-Écrivez une commande pour imprimer la chaîne Use "man echo", y compris les guillemets ; c'est-à-dire, veillez à ne pas l'imprimer Use man echoà la place. Astuce : utilisez des guillemets doubles dans la chaîne interne et placez le tout entre guillemets simples.</p>
                    <p class="exo">2-En exécutant man sleep, découvrez comment faire « dormir » le terminal pendant 5 secondes et exécutez la commande pour ce faire.</p>
                    <p class="exo">3-Exécutez la commande pour dormir pendant 5 000 secondes, réalisez que cela représente bien plus d’une heure, puis utilisez les instructions de l’encadré  1.3 pour vous sortir du pétrin.</p>
                    
               
             </div>
             
         </div>
 
         <button class="btn">Commencer: le chapitre</button>
        </section>
        <!-- 7 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3 id="chap2">Chapitre 2</h3>
                 <h2 id="seize">Manipulation de fichiers</h2>
                 <p class="lamda">Après avoir expliqué comment exécuter une commande de base, nous sommes maintenant prêts à apprendre à manipuler des fichiers, l'une des tâches les plus importantes de la ligne de commande.Étant donné que ce tutoriel ne suppose aucun prérequis technique, nous n'exigerons aucune connaissance des programmes conçus pour éditer du texte.(De tels programmes, appelés éditeurs de texte , font l'objet du prochain tutoriel de la séquence,le tutorield'éditeur de texte  .)Cela signifie que nous devrons créer des fichiers à la main sur la ligne de commande.Mais il s’agit d’une fonctionnalité, pas d’un bug ( encadré  2.1 ), car apprendre à créer des fichiers en ligne de commande est une compétence précieuse en soi.</p>
                 <p class="comment">
                    Encadré 2.1. Apprendre à parler « geek » <br>
                    Une partie importante de l’apprentissage du développement logiciel consiste à se familiariser avec la culture des hackers , des nerds et des geeks dont une grande partie est issue.Par exemple, l’expression « Ce n’est pas un bug, c’est une fonctionnalité » est une façon courante de transformer un défaut apparent en vertu.Le Jargon File , qui comprend un lexique énorme et divertissant de termes de hackers, développe ce thème dans son entrée sur la fonctionnalité : <br>
                    
                    « Fonctionnalité non documentée » est un euphémisme courant, prétendument humoristique, pour désigner un bug .Il existe une blague similaire que l’on appelle parfois le « test de geek à une question ».Vous dites à quelqu’un : « J’ai vu une Volkswagen Coccinelle aujourd’hui avec une plaque d’immatriculation personnalisée sur laquelle était écrit « CARACTÉRISTIQUE ».S'il/elle rit, c'est un geek . <br> <br>
                    
                    La blague ici est que, parce que « bug » est un terme d'argot courant pour une Volkswagen Coccinelle, une Coccinelle avec la plaque d'immatriculation personnalisée FEATURE est une manifestation réelle de « Ce n'est pas un bug, c'est une fonctionnalité » ( Figure  2.1 ).NB Dans de nombreux cas, le « bug » est en fait une fonctionnalité, donc aucune connotation péjorative n’est nécessairement impliquée. <br>
                    
                    Même si vous n'êtes pas vous-même un geek ou un nerd, apprendre à « parler geek » vous aidera à naviguer à la fois dans le paysage technologique et dans le monde social qui l'entoure.
                    
                    
                 </p>
                 <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
        
        </section>
        <!-- 8 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="dixsept">2.1 Redirection et ajout</h2>
                 <p class="lamda">Reprenons (plus ou moins) là où nous nous sommes arrêtés au chapitre  1 , avec une echocommande pour imprimer la première ligne du premier sonnet de Shakespeare ( liste  1.7 )</p>
                 <p class="cod">
                    $ echo  "Nous désirons l'accroissement des plus belles créatures," <br>
                    Nous désirons l'accroissement des plus belles créatures,
                 </p>
                 <p class="lamda">Notre tâche est maintenant de créer un fichier contenant cette ligne.Même sans l'aide d'un éditeur de texte, il est possible de le faire en utilisant l' opérateur de redirection > :</p>
                 <p class="cod">$ echo  "Nous désirons l'accroissement des plus belles créatures," > sonnet_1.txt</p>
                 <p class="lamda">(Rappelez-vous que vous pouvez utiliser la flèche vers le haut pour récupérer la commande précédente plutôt que de la saisir à partir de zéro.)Ici, le crochet droit >prend la sortie de la chaîne echoet redirige son contenu vers un fichier appelé sonnet_1.txt.</p>
                 <p class="lamda">Comment pouvons-nous savoir si la redirection a fonctionné ?Nous apprendrons quelques outils de ligne de commande plus avancés pour inspecter les fichiers dans le chapitre  3 , mais pour l'instant nous utiliserons la catcommande, qui vide simplement le contenu du fichier à l'écran :</p>
                 <p class="cod">$ cat sonnet_1.txt <br>
                    Nous désirons augmenter notre espérance de vie auprès des plus belles créatures,</p>
                 <p class="lamda">Le nom catest l'abréviation de « concatenate », ce qui suggère qu'il peut être utilisé pour combiner le contenu de plusieurs fichiers, mais l'utilisation ci-dessus (pour vider le contenu d'un seul fichier sur l'écran) est extrêmement courante.Considérez-le commecat une manière « rapide et simple » de visualiser le contenu d’un fichier particulier ( Figure  2.2 ).</p>
                 <p class="cycle spec"><img src="/ressources/t10.jpg" alt=""></p>
                 <p class="fig">Figure 2.2 : Affichage d’un fichier avec cat.</p>
                 
                 
                 <p class="lamda">Afin d'ajouter la deuxième ligne du sonnet (en orthographe modernisée), nous pouvons utiliser l' opérateur append >> comme suit :</p>
                 <p class="cod">$ echo  "Afin que la belle Rose ne meure jamais," >> sonnet_1.txt</p>
                 <p class="lamda">Cela ajoute simplement la ligne à la fin du fichier donné.Comme précédemment, nous pouvons voir le résultat en utilisant cat:</p>
                 <p class="cod">
                    $ cat sonnet_1.txt <br>
                    Nous désirons que les plus belles créatures grandissent, <br>
                   afin que la rose de la beauté ne meure jamais,
                 </p>
                 <p class="lamda">(Pour accéder à cette commande, j'espère que vous aurez simplement appuyé deux fois sur la flèche vers le haut au lieu de la retaper.Si c'est le cas, vous commencez certainement à comprendre.)Le résultat ci-dessus montre que le double crochet droit >>a ajouté la chaîne de echoau fichier sonnet_1.txtcomme prévu.</p>
                 <p class="cod"></p>
                 <p class="lamda">Les traitements modernisés des Sonnets corrigent parfois Rose en rose (obscurcissant ainsi le sens probable ), et nous pouvons créer un deuxième fichier suivant cette convention en utilisant deux autres appels à echo:</p>
                 <p class="cod">
                    $ echo  "Des plus belles créatures nous désirons croître," > sonnet_1_lower_case.txt <br>
                    $ echo  "Afin que la rose de la beauté ne meure jamais," >> sonnet_1_lower_case.txt
                 </p>
                 <p class="lamda">Afin de faciliter la comparaison de fichiers similaires mais pas identiques, les systèmes Unix sont livrés avec la diffcommande utile :</p>
                 <p class="cod">$ diff sonnet_1.txt sonnet_1_lower_case.txt <br>
                    < Afin que la rose de la beauté ne meure jamais, --- <br>
                    > Afin que la rose de la beauté ne meure jamais,</p>
                 <p class="lamda">Lorsqu'on parle de fichiers informatiques, diff est fréquemment utilisé à la fois comme nom (« Quelle est la différence entre ces fichiers ? ») et comme verbe (« Vous devriez comparer les fichiers pour voir ce qui a changé. »)Comme pour de nombreux termes techniques, cela se retrouve parfois dans l’usage courant, comme par exemple : « Comparez les idées actuelles avec celles de diverses cultures passées et voyez ce que vous obtenez. »</p>
                <h2 id="dixhuit">2.1.1 Exercices</h2>
                <p class="lamda">À la fin de chacun des exercices ci-dessous, utilisez la catcommande pour vérifier votre réponse.</p>
                <p class="exo">1-En utilisant echo et >, créez des fichiers appelés line_1.txtet line_2.txtcontenant respectivement les première et deuxième lignes du Sonnet</p>
                <p class="exo">2-Reproduisez l'original sonnet_1.txt(contenant les deux premières lignes du sonnet) en redirigeant d'abord le contenu de line_1.txtpuis en ajoutant le contenu de line_2.txt.Appelez le nouveau fichier sonnet_1_copy.txtet confirmez en utilisant diffqu'il est identique à sonnet_1.txt. Astuce : lorsqu'il n'y a pas de différence entre deux fichiers, diffcela ne génère simplement rien.</p>
                <p class="exo">3-Utilisez catpour combiner le contenu de line_1.txtet line_2.txtdans l'ordre inverse à l'aide d'une seule commande, produisant ainsi le fichier sonnet_1_reversed.txt. Astuce : la catcommande peut prendre plusieurs arguments.
                </p>






                <button class="btn">Commencer: le chapitre</button>
                 
             </div>
             
         </div>
 
         
        </section>
        <!-- 9 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 
<h2 id="dixneuf">2.2 Listing</h2>
                <p class="lamda">La commande la plus fréquemment tapée sur la ligne de commande Unix est sans doute ls, abréviation de « list » (Listing 2.1).</p>
                
<p class="cod"> 
                    Liste 2.1 : Liste des fichiers et répertoires avec ls. (Le résultat peut varier.) <br>
                    
$ ls <br>
                    Bureau <br>
Téléchargements <br>
sonnet_1.txt <br>
sonnet_1_reversed.txt
</p>
                <p class="lamda">La commande ls liste simplement tous les fichiers et répertoires du répertoire actuel (à l'exception de ceux qui sont cachés, dont nous parlerons plus en détail dans un instant). En ce sens, il s'agit en fait d'une version en ligne de commande du navigateur graphique utilisé pour afficher les fichiers et les répertoires (également appelés « dossiers »), comme le montre la figure 2.3. (Nous approfondirons notre compréhension des répertoires et des dossiers au chapitre 4.) Comme pour un navigateur de fichiers graphique, la sortie du listing 2.1 n'est qu'un exemple, et les résultats varieront en fonction des caractéristiques de votre système. (Cela vaut pour tous les exemples ls, ne vous inquiétez donc pas s'il y a des différences mineures dans la sortie.)</p>
                <p class="cycle spec"><img src="/ressources/t11.png" alt=""></p>
                <p class="fig">Figure 2.3 : L'équivalent graphique de ls.</p>
                                                                                
<p class="lamda">La commande ls peut être utilisée pour vérifier si un fichier (ou un répertoire) existe, car essayer d'utiliser ls sur un fichier inexistant entraîne un message d'erreur, comme le montre le listing 2.2. </p>
                <p class="cod">
Listing 2.2 : Exécution de ls sur un fichier inexistant.
                    
$ ls foo
                    ls : foo : Aucun fichier ou répertoire de ce type
$ touch foo
$ ls foo
foo
</p>
<p class="lamda">Le listing 2.2 utilise la commande touch pour créer un fichier vide nommé foo (encadré 2.2), de sorte que la deuxième fois que nous exécutons ls, le message d'erreur a disparu. (L'objectif déclaré de touch est de modifier la date de modification des fichiers ou des répertoires, mais l'utilisation (abusive) de touch pour créer des fichiers vides comme dans le listing 2.2 est une pratique courante sous Unix.)</p>
                
<div class="comment">
                    Encadré 2.2. Foo, bar, baz, etc. <br>
                   <br>  Lorsque vous lisez des articles sur les ordinateurs, vous rencontrez fréquemment certains mots étranges, tels que foo, bar et baz. En effet, outre ls foo et touch foo, nous avons déjà vu trois références de ce type dans ce tutoriel : dans une commande en ligne de commande classique (Figure 1.2), pour sortir d'une situation difficile (grep foobar dans l'encadré 1.3), et encore une fois dans une page de manuel (listing 1.4). Les deux premières étaient mes propres utilisations, mais je n'avais rien à voir avec la dernière :
                    <p class="cod">
...
 si le nom contient une barre oblique (/), man l'interprète
comme une spécification de fichier,  ce qui vous permet de faire man <br>
./foo.5 ou même man /cd/foo/bar.1.gz. <br></p>
                    
Nous voyons ici foo et bar apparaître dans la page de manuel de man lui-même, ce qui témoigne sans ambiguïté de leur omniprésence dans l'informatique.
                  <br>
Quelle est l'origine de ces termes étranges ? Comme d'habitude, le Jargon File (via son entrée sur foo) nous éclaire : <br> <br>
                                        
foo : /foo/ <br>
                    
1. interj. Terme exprimant le dégoût. <br>
2. [très courant] Utilisé de manière très générale comme nom d'exemple pour absolument tout, en particulier les programmes et les fichiers (notamment les fichiers temporaires). <br>
3. Premier élément de la liste standard des variables métasyntaxiques utilisées dans les exemples de syntaxe. Voir aussi bar, baz, qux, quux, etc. <br>
                    Lorsque « foo » est utilisé en relation avec « bar », il remonte généralement à l'acronyme argotique de l'armée de la Seconde Guerre mondiale FUBAR [voir la signification originale], modifié par la suite en foobar. Les premières versions du Jargon File ont interprété ce changement comme une censure d'après-guerre, mais il semble désormais plus probable que FUBAR soit lui-même un dérivé de « foo », peut-être influencé par le mot allemand furchtbar (terrible) — « foobar » pourrait en fait être la forme originale. <br><br>
En suivant le lien vers les variables métasyntaxiques, nous trouvons ensuite ce qui suit : <br> <br>
                                        
variable métasyntaxique : n. <br>
                    Nom utilisé dans des exemples et compris comme représentant tout ce qui fait l'objet de la discussion, ou tout membre aléatoire d'une classe de choses faisant l'objet de la discussion. Le mot foo en est l'exemple canonique. Pour éviter toute confusion, les hackers n'utilisent jamais (ou presque jamais) « foo » ou d'autres mots similaires comme noms permanents pour quoi que ce soit. Dans les noms de fichiers, une convention courante veut que tout nom de fichier commençant par un nom de variable métasyntaxique soit un fichier temporaire pouvant être supprimé à tout moment.
                    
                   Les variables métasyntaxiques sont ainsi nommées parce que (1) ce sont des variables du métalangage utilisé pour parler des programmes, etc. ; (2) ce sont des variables dont les valeurs sont souvent des variables (comme dans des utilisations telles que « la valeur de f(foo,bar) est la somme de foo et bar »). Cependant, il a été suggéré de manière plausible que la véritable raison du terme « variable métasyntaxique » est qu'il sonne bien. <br><br>
En d'autres termes, si vous souhaitez créer un fichier et que le nom n'a pas d'importance, le nom est généralement « foo ». Une fois que vous avez utilisé « foo », le fichier suivant s'appelle « bar », puis « baz ». Les suites varient (« quux » est un choix courant), mais dans de nombreux cas, trois suffisent.
                
</div>
                <p class="lamda">Une pratique courante lors de l'utilisation de la ligne de commande consiste à changer de répertoire à l'aide de la commande cd (abordée au chapitre 4), puis à taper immédiatement ls pour afficher le contenu du répertoire. Cela nous permet de nous orienter et constitue une bonne première étape vers notre prochaine action, quelle qu'elle soit. </p>
                <p class="lamda">Une fonctionnalité utile de ls est la prise en charge du caractère générique * (prononcé « étoile »). Par exemple, pour lister tous les fichiers se terminant par « .txt », nous taperions ceci :</p>
                
<p class="cod">
                    $ ls *.txt <br>
                    sonnet_1.txt <br>
                    sonnet_1_reversed.txt
                </p>
                <p class="lamda">Ici, *.txt (prononcé « étoile point tee-ex-tee ») se développe automatiquement en tous les noms de fichiers qui correspondent au modèle « n'importe quelle chaîne suivie de .txt ». </p>
                <p class="lamba">Il existe trois formes optionnelles particulièrement importantes de ls, à commencer par la « forme longue », qui utilise l'option -l (lire « tiret-ell ») :</p>
                
                
<p class="cod">
$ ls -l *.txt <br>
total 16 <br>
                    
-rw-r--r-- 1 mhartl staff  87 20 juillet 18:05 sonnet_1.txt <br>
                    -rw-r--r-- 1 mhartl staff 294 21 juillet 12:09 sonnet_1_reversed.txt
</p>
                <p class="lamda">Pour l'instant, vous pouvez ignorer la plupart des informations affichées par ls -l, mais notez que le format long indique la date et l'heure de la dernière modification du fichier. Le nombre avant la date correspond à la taille du fichier, en octets.3</p>
                <p class="lamda">Une deuxième variante puissante de ls est « list by reversed time of modification (long format) », ou ls -rtl, qui affiche la forme longue de chaque fichier ou répertoire par ordre de modification récente (inversé afin que les entrées les plus récemment modifiées apparaissent en bas de l'écran pour faciliter l'inspection). Cela est particulièrement utile lorsque le répertoire contient beaucoup de fichiers, mais que vous ne souhaitez voir que ceux qui ont été modifiés récemment, par exemple pour vérifier le téléchargement d'un fichier. Nous verrons un exemple de cela dans la section 3.1, mais vous pouvez l'essayer dès maintenant :</p>
                <p class="cod">
$ ls -rtl <br>
<résultats dépendant du système>
</p>
                
<p class="lamda">À propos, -rtl est la forme compacte couramment utilisée, mais vous pouvez également passer les options individuellement, comme ceci :</p>
                <p class="cod">$ ls -r -t -l</p>
                <p class="lamda">De plus, leur ordre n'a pas d'importance, donc taper ls -trl donne le même résultat.
                
<h2 id="vin">2.2.1 Fichiers cachés</h2>
                <p class="lamda">Enfin, Unix a le concept de « fichiers (et répertoires) cachés », qui n'apparaissent pas par défaut lors du listage des fichiers. Les fichiers et répertoires cachés sont identifiés par un point . au début de leur nom et sont couramment utilisés pour stocker les préférences des utilisateurs, par exemple. Par exemple, dans 643-code Git pour se perfectionner, nous allons créer un fichier appelé .gitignore qui indique à un programme particulier (Git) d'ignorer les fichiers correspondant à certains modèles. Concrètement, pour ignorer tous les fichiers se terminant par « .txt », nous pourrions faire ceci :</p>
                <p class="cod">
$ echo « *.txt » > .gitignore <br>
                    
$ cat .gitignore <br>
                    *.txt
</p>
<p class="lamda">Si nous exécutons ensuite ls, le fichier n'apparaîtra pas, car il est caché :</p>
<p class="cod">$ ls <br>
sonnet_1.txt <br>
sonnet_1_reversed.txt
</p>
                
<p class="lamda">Pour que ls affiche les fichiers et répertoires cachés, nous devons lui passer l'option -a (pour « all ») :</p>
                <p class="cod">
$ ls -a <br>.
           .gitignore      sonnet_1_reversed.txt <br>
                    
..          sonnet_1.txt
                </p>
                <p class="lamda">Maintenant, .gitignore s'affiche, comme prévu. (Nous apprendrons ce que signifient . et .. dans la section 4.3.)</p>
                <h2 id="vinun">2.2.2 Exercices</h2>
                
<p class="exo">1-Quelle est la commande permettant de lister tous les fichiers et répertoires non cachés qui commencent par la lettre « s » ?</p>
                <p class="exo">2-Quelle est la commande permettant de lister tous les fichiers non cachés qui contiennent la chaîne « onnet », sous forme longue et par ordre décroissant de date de modification ?
 Indice : utilisez l'opérateur générique au début et à la fin. 
3-Quelle est la commande permettant de lister tous les fichiers (y compris les fichiers cachés) par ordre décroissant de date de modification, en format long ?
                








                <button class="btn">Commencer: le chapitre</button>
                 
             </div>
             
         </div>
 
         
        </section>
        <!-- 10 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="vindeux">2.3 Renommer, copier, supprimer</h2>
               <p class="lamda">Outre le listage des fichiers, les opérations de fichiers les plus courantes impliquent probablement de les renommer, de les copier et de les supprimer.Comme pour le listage des fichiers, la plupart des systèmes d'exploitation modernes fournissent une interface utilisateur graphique pour ces tâches, mais dans de nombreux contextes, il est plus pratique de les exécuter sur la ligne de commande. Remarque : si vous utilisez macOS, vous devez suivre les instructions de l’encadré  2.3 pour le moment.</p>

                <div class="comment">
                    Encadré 2.3. Passer de macOS à Bash
                    Si vous utilisez macOS, à ce stade, vous devez vous assurer que vous utilisez le bon programme shell pour ce didacticiel.Le shell par défaut de macOS Catalina est Z shell (Zsh), mais pour obtenir des résultats cohérents avec ce tutoriel, vous devez passer au shell appelé Bash .
                    
                    La première étape consiste à déterminer quel shell votre système exécute, ce que vous pouvez faire à l'aide de la echocommande ( Section  1.3 ) :
                    
                      $ écho $SHELL
                      /bin/bash
                    Ceci imprime la $SHELL variable d'environnement .Si vous voyez le résultat affiché ci-dessus, indiquant que vous utilisez déjà Bash, vous avez terminé et pouvez continuer le reste du didacticiel.(Dans de rares cas, $SHELLcela peut différer du shell actuel, mais la procédure ci-dessous passera toujours correctement d'un shell à un autre.)L’alerte affichée dans la liste  1.1 peut être ignorée en toute sécurité.Pour plus d'informations, notamment sur la manière de passer à Z Shell et de l'utiliser avec ce didacticiel, consultez l'article de blog 643-code « Utilisation de Z Shell sur Mac avec les didacticiels 643-code ».
                    
                    L’autre résultat possible echoest le suivant :
                    
                      $ écho $SHELL
                      /bin/zsh
                    Si c'est le résultat que vous obtenez, vous devez utiliser la chshcommande (« change shell ») comme suit :
                    
                      $ chsh -s /bin/bash
                    Vous serez presque certainement invité à saisir votre mot de passe système à ce stade, ce que vous devriez faire.Quittez ensuite complètement votre programme shell en utilisant Commande-Q et relancez-le.
                    
                    Vous pouvez confirmer que le changement a réussi en utilisant echo:
                    
                      $ écho $SHELL
                      /bin/bash
                    À ce stade, vous commencerez probablement à voir l’alerte affichée dans la liste  1.1 , que vous devez ignorer.
                    
                    Notez que la procédure ci-dessus est entièrement réversible, vous n’avez donc pas à craindre d’endommager votre système.Consultez « Utilisation de Z Shell sur Mac avec les didacticiels 643-code » pour plus d’informations.
                </div>

                   <p class="lamda">La façon de renommer un fichier est d’utiliser la mvcommande, abréviation de « move » :</p>
                   <p class="cod">
                    $ echo  "texte de test" > test 
                    $ mv test test_file.txt
                     $ ls
                     test_file.txt
                   </p>
                   <p class="lamda">Cela renomme le fichier appelé testen test_file.txt.L'étape finale de l'exemple s'exécute lspour confirmer que le changement de nom du fichier a réussi, mais les fichiers spécifiques au système autres que le fichier de test sont omis de la sortie affichée.(Le nom « déplacer » vient de l’utilisation générale de mvpour déplacer un fichier vers un répertoire différent ( Chapitre  4 ), en le renommant éventuellement en cours de route.Lorsque les répertoires d’origine et de destination coïncident, un tel « déplacement » se réduit à un simple renommage.)</p>
                   <p class="lamda">La façon de copier un fichier est d'utiliser cp, abréviation de « copier » :</p>
                   <p class="cod">
                    $ cp fichier_test.txt second_test.txt
                    $ ls
                    second_test.txt 
                   fichier_test.txt
                   </p>
                   <p class="lamda">Enfin, la commande pour supprimer un fichier est rm, pour « supprimer » :</p>
                   <p class="cod"> 
                    $ rm second_test.txt
                    supprimer second_test.txt ? y 
                   $ ls second_test.txt
                    ls : second_test.txt : Aucun fichier ou répertoire de ce type
                   </p>
                   <p class="lamda">Notez que, sur de nombreux systèmes, par défaut, vous serez invité à confirmer la suppression du fichier.Toute réponse commençant par la lettre « y » ou « Y » entraînera la suppression du fichier, et toute autre réponse empêchera la suppression.</p>
                   <p class="lamda">Au fait, dans les appels à cpet rmau-dessus, je ne taperais presque certainement pas test_file.txtou second_test.txt.Au lieu de cela, je taperais quelque chose comme test⇥ou sec⇥(où ⇥ représente la touche de tabulation ( Tableau  1.1 )), utilisant ainsi la complétion par tabulation ( Encadré  2.4 ).</p>
                   <div class="comment">
                    Encadré 2.4. Complétion par tabulation
                    La plupart des programmes de ligne de commande modernes (shells) prennent en charge la saisie semi-automatique par tabulation , qui consiste à compléter automatiquement un mot s'il n'y a qu'une seule correspondance valide sur le système.Par exemple, si le seul fichier commençant par les lettres « tes » est test_file, nous pourrions créer la commande pour le supprimer comme suit :
                    
                    $ rm tes⇥
                    où ⇥ est la touche de tabulation ( Tableau  1.1 ).Le shell complèterait alors le nom du fichier, donnant rm test_file.Surtout avec des noms de fichiers (ou de répertoires) plus longs, la saisie semi-automatique par tabulation peut économiser une quantité considérable de saisie.Cela réduit également la charge cognitive , car cela signifie que vous n'avez pas à vous souvenir du nom complet du fichier, mais uniquement de ses premières lettres.
                    
                    Si la correspondance est ambiguë, comme cela se produirait si nous avions des fichiers appelés foobarquuxet foobazquux, le mot sera complété uniquement dans la mesure du possible, donc
                    
                    $ ls foo⇥
                    serait complété à
                    
                    $ ls fooba
                    Si nous appuyons à nouveau sur la touche Tab , nous verrons une liste de correspondances :
                    
                    $ ls fooba⇥
                     foobarquux foobazquux
                    Nous pourrions alors taper plus de lettres pour résoudre l'ambiguïté, donc taper raprès foobaet appuyer ⇥donnerait
                    
                    $ ls foobar⇥
                    qui serait complété à foobarquux.Cette situation est suffisamment courante pour que les utilisateurs expérimentés de la ligne de commande appuient souvent simplement sur quelque chose comme f⇥⇥pour que le shell affiche toutes les possibilités :
                    
                    $ ls f⇥⇥
                     figure_1.png foobarquux foobazquux
                    Des lettres supplémentaires seraient ensuite tapées comme d’habitude pour résoudre l’ambiguïté.
                   </div>
                   <p class="lamda">
                    Le comportement par défaut rmsur un système Unix non configuré est en fait de supprimer le fichier sans confirmation, mais (parce que la suppression est irréversible) de nombreux systèmes utilisent un alias pour la rmcommande afin d'utiliser une option permettant d'activer la confirmation.(Comme vous pouvez le vérifier en exécutant man rm, cette option est -i, donc en fait rmest vraiment rm -i.)Il existe de nombreuses situations dans lesquelles la confirmation n'est pas pratique, par exemple lorsque vous supprimez une liste de fichiers et que vous ne souhaitez pas avoir à confirmer chacun d'eux.Ceci est particulièrement courant lors de l’utilisation du caractère générique  *introduit dans la section  2.2 .Par exemple, pour supprimer tous les fichiers se terminant par « .txt » à l’aide d’une seule commande, sans avoir à confirmer chacun d’eux, vous pouvez taper ceci :
                   </p>
                   <p class="cod">$ rm -f *.txt</p>
                   <p class="lamda">Ici -f(pour « forcer ») remplace l’ -ioption implicite et supprime immédiatement tous les fichiers.( NB Vous êtes maintenant en mesure de comprendre la commande de la figure  1.2 .)</p>
                   <h2 id="vintrois">2.3.1 Concision Unix</h2>
                   <p class="lamda">Une chose que vous remarquerez peut-être est que les commandes de cette section et de la section  2.2 sont courtes : au lieu de list, move, copy, et remove, nous avons ls, mv, cp, et rm.Étant donné que les anciens noms de commandes sont plus faciles à comprendre et à mémoriser, vous pouvez vous demander pourquoi les commandes réelles ne sont pas plus longues ( Figure  2.4 ).</p>
                   <p class="cycle spec"><img src="/ressources/t12.jpg" alt=""></p>
                   <p class="fig">Figure 2.4 : La concision des commandes Unix peut être une source de confusion.</p>
                   
                   
                   
                   <p class="lamda">La réponse est qu'Unix date d'une époque où la plupart des utilisateurs d'ordinateurs se connectaient à des serveurs centralisés via des connexions lentes, et il pouvait y avoir un délai notable entre le moment où les utilisateurs appuyaient sur une touche et le moment où elle apparaissait sur le terminal.Pour les commandes fréquemment utilisées comme la liste des fichiers, la différence entre listet lsou removeet rmpeut être significative.Par conséquent, les commandes Unix les plus couramment utilisées ont tendance à n'avoir que deux ou trois lettres de longueur.Parce que cela les rend plus difficiles à mémoriser, cela peut être un inconvénient mineur lors de leur apprentissage, mais au fil d'une vie d'utilisation de la ligne de commande, les économies que cela représente, par exemple, mvs'additionnent vraiment.</p>

                     <h2 id="vinquatre">2.3.2 Exercices</h2>
                     <p class="exo">1-Utilisez la echocommande et l’opérateur de redirection  >pour créer un fichier appelé foo.txtcontenant le texte « hello, world ».Ensuite, en utilisant la cpcommande, faites une copie de ce foo.txtqui est appelé bar.txt.À l’aide de la diffcommande, confirmez que le contenu des deux fichiers est le même.</p>
                     <p class="exo">2-En combinant la catcommande et l'opérateur de redirection  >, créez une copie de foo.txtappelé baz.txt sans utiliser la cpcommande.</p>
                     <p class="exo">3-Créez un fichier appelé quux.txtcontenant le contenu de foo.txtsuivi du contenu de bar.txt. Astuce : comme indiqué dans la section  2.1.1 , catpeut prendre plusieurs arguments.</p>
                     <p class="exo">4-Comment faire rm nonexistentet rm -f nonexistentdifférencier pour un fichier inexistant ?
                    </p>


                    <button class="btn">Commencer: le chapitre</button>
                 
             </div>
             
         </div>
 
         
        </section>
        <!-- 11 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 2</h3>
                 <h2 id="vincinq">2.4 Résumé</h2>

                 <p class="lamda">Les commandes importantes de ce chapitre sont résumées dans le tableau  2.1 .</p>
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Commande</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Description</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Exemple</font></font></strong></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Rediriger la sortie vers le nom de fichier</font></font></td>
                    <td class="align_left"><code>$ echo foo &gt; foo.txt</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">&gt;&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Ajouter la sortie au nom de fichier</font></font></td>
                    <td class="align_left"><code>$ echo bar &gt;&gt; foo.txt</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">cat &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Imprimer le contenu du fichier à l'écran</font></font></td>
                    <td class="align_left"><code>$ cat hello.txt</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">diff &lt;f1&gt; &lt;f2&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Fichiers Diff 1 et 2</font></font></td>
                    <td class="align_left"><code>$ diff foo.txt bar.txt</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ls</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Liste des répertoires ou des fichiers</font></font></td>
                    <td class="align_left"><code>$ ls hello.txt</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ls -l</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Liste longue</font></font></td>
                    <td class="align_left"><code>$ ls -l hello.txt</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ls -rtl</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Long par temps de modification inverse</font></font></td>
                    <td class="align_left"><code>$ ls -rtl</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ls -a</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Listez tout (y compris caché)</font></font></td>
                    <td class="align_left"><code>$ ls -a</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">touch &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Créer un fichier vide</font></font></td>
                    <td class="align_left"><code>$ touch foo</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">mv &lt;old&gt; &lt;new&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Renommer (déplacer) de l'ancien vers le nouveau</font></font></td>
                    <td class="align_left"><code>$ mv foo bar</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">cp &lt;old&gt; &lt;new&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Copier l'ancien vers le nouveau</font></font></td>
                    <td class="align_left"><code>$ cp foo bar</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">rm &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Supprimer (supprimer) le fichier</font></font></td>
                    <td class="align_left"><code>$ rm foo</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">rm -f &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Forcer la suppression du fichier</font></font></td>
                    <td class="align_left"><code>$ rm -f bar</code></td>
                    </tr>
                    </tbody>
                    </table>

                <p class="fig">Tableau 2.1 : Commandes importantes du chapitre  2 .</p>
                <h2 id="vinsix">2.4.1 Exercices</h2>
                <p class="fig">
                    Nous désirons l'augmentation des plus belles créatures, <br>
                    Afin que les beautés de Rose ne meurent jamais, <br>
                    Mais comme les plus mûrs devraient mourir avec le temps, <br>
                    Son tendre héritier pourrait porter sa mémoire : <br>
                    Mais tu as contracté tes propres yeux brillants, <br>
                    Nourris tes lumières de flammes avec toi-même, substantiellement peu, <br>
                    Créer une famine là où se trouve l’abondance, <br>
                    Toi-même, ton ennemi, trop cruel envers ton doux moi : <br>
                    Toi qui es maintenant le nouvel ornement du monde, <br>
                    Et seulement annonciateur du printemps éclatant, <br>
                    Dans ton propre bourgeon enterre ton contenu, <br>
                    Et la tendresse résidait dans la méchanceté : <br>
                       Ayez pitié du monde, sinon ce glouton sera <br>
                       Pour manger ce qui est dû au monde, par la tombe et par toi.
                </p>
                <p class="fig">Figure 2.5 : Une version copier-coller du premier sonnet de Shakespeare ( cf. Figure  1.11 ).</p>

                <p class="exo">1-En copiant et collant le texte de la version HTML de la figure  2.5 , utilisez echopour créer un fichier appelé sonnet_1_complete.txtcontenant le texte complet (original) du premier sonnet de Shakespeare. Astuce : Vous vous souvenez peut-être avoir été bloqué lorsque echoétait suivi d'un guillemet double non apparié ( Section  1.3 et Encadré  1.3 ), comme dans echo ", mais en fait, cette construction vous permet d'imprimer un bloc de texte sur plusieurs lignes.N'oubliez pas de mettre une citation de fermeture à la fin, puis de rediriger vers un fichier portant le nom approprié.Vérifiez que le contenu est correct à l’aide de cat( Figure  2.2 ).</p>
                <p class="exo">2-Tapez la séquence de commandes nécessaires pour créer un fichier vide appelé foo, renommez-le en bar, et copiez-le dans baz.</p>
                <p class="exo">3-Quelle est la commande pour lister uniquement les fichiers commençant par la lettre « b » ? Astuce : utilisez un caractère générique.</p>
                <p class="exo">4-Supprimez les deux baret bazutilisez un seul appel à rm. Astuce : si ce sont les deux seuls fichiers du répertoire actuel qui commencent par la lettre « b », vous pouvez utiliser le modèle générique de l’exercice précédent.</p>





                <button class="btn">Commencer: le chapitre</button>

                 
             </div>
             
         </div>
 
        
        </section>
        <!-- 12-->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3 id="chap3">Chapitre 3</h3>
                 <h2 id="vinsept">Inspection des fichiers</h2>
                 <p class="lamda">
                    Après avoir vu comment créer et manipuler des fichiers, il est maintenant temps d'apprendre à examiner leur contenu.Ceci est particulièrement important pour les fichiers trop longs pour tenir sur un seul écran.En particulier, nous avons vu à partir de la section  2.1 comment utiliser la catcommande pour vider le contenu du fichier à l'écran, mais cela ne fonctionne pas très bien pour les fichiers plus longs.


                 </p>
                 <button class="btn">Commencer: le chapitre</button>
                 
             </div>
             
         </div>
 
         
        </section>
        <!-- 13 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="vinhuit">3.1 Téléchargement d'un fichier
                </h2>
                <p class="lamda">Pour nous donner un point de départ, plutôt que de créer un long fichier à la main (ce qui est fastidieux), nous allons télécharger un fichier depuis Internet à l'aide du puissant curlutilitaire.Parfois écrit « cURL », le curlprogramme nous permet d’interagir avec une URL 1 en ligne de commande.Bien qu'elle ne fasse pas partie de l'ensemble de commandes Unix de base, la curlcommande est largement disponible pour l'installation sur les systèmes Unix.Pour nous assurer qu'il est disponible sur votre système, nous pouvons utiliser la whichcommande, qui vérifie si le programme donné est disponible sur la ligne de commande .La façon de l'utiliser est de taper whichsuivi du nom du programme, dans ce cas curl:</p>
                <p class="cod"> 
                    $ qui curl <br>
                    /usr/bin/curl
                </p>
                <p class="lamda">J'ai montré la sortie sur mon système ( /usr/bin/curl, généralement lu comme « user bin curl »), mais le résultat sur votre système peut différer.En particulier, si le résultat n'est qu'une ligne vide, vous devrez installer curl, ce que vous pouvez faire en recherchant sur Google « installer curl » suivi du nom de votre système d'exploitation (par exemple, « installer curl macos »).(Ce type d’étape d’installation « Google for it » est une sophistication technique classique ( Encadré  1.4 ).)</p>
                <p class="lamda">Une fois curlinstallé, nous pouvons utiliser la commande du listing  3.1 pour télécharger un fichier appelé sonnets.txt, qui contient un grand corpus de texte .</p>
                
                <p class="cod">
                    Liste 3.1 : Utilisation curlpour télécharger un fichier plus long. <br>
                    $ curl -OL https://cdn.learnenough.com/sonnets.txt <br>
                     $ ls -rtl
                </p>
                <p class="lamda">Assurez-vous de copier la commande exactement ; en particulier, notez que l'option -OLcontient une lettre majuscule « O » ( O) et non un zéro ( 0).(Déterminer ce que font ces options est laissé comme exercice ( Section  3.5.1 ).)De plus, sur certains systèmes (pour des raisons mystérieuses), vous devrez peut-être exécuter la commande deux fois pour la faire fonctionner ; en inspectant les résultats de ls -rtl, vous devriez être en mesure de savoir si l'appel initial à a curlcréé le fichier sonnets.txtcomme prévu.(Si vous devez répéter la curlcommande, vous pouvez appuyer deux fois sur la flèche vers le haut pour la récupérer, mais consultez l'encadré  3.1 pour les alternatives.)</p>
                <p class="cod"></p>
                <p class="lamda">Le résultat de l'exécution de la liste  3.1 est sonnets.txtun fichier contenant les 154 sonnets de Shakespeare.Ce fichier contient 2620 lignes, beaucoup trop pour tenir sur un seul écran.Apprendre à inspecter son contenu est l’objectif du reste de ce chapitre.(Entre autres choses, nous apprendrons à déterminer qu'il comporte 2620 lignes sans les compter toutes à la main.)</p>
                <div class="comment">
                    Encadré 3.1. Répéter les commandes précédentes <br>
                    La répétition des commandes précédentes est une tâche fréquente lors de l'utilisation de la ligne de commande.Jusqu'à présent dans ce didacticiel, nous avons utilisé la touche flèche vers le haut pour récupérer (et éventuellement modifier) ​​les commandes précédentes, mais ce n'est pas la seule possibilité.Un moyen encore plus rapide de trouver et d’exécuter immédiatement une commande précédente consiste à utiliser le point d’exclamation  !, qui dans le contexte du développement logiciel est généralement prononcé « bang ».Pour exécuter la commande précédente exactement comme elle est écrite, nous pouvons utiliser « bang bang » :
                    <p class="cod">
                    $ echo "foo" 
                     foo 
                     $ !! 
                     echo "foo" 
                     foo
                    </p> <br>
                    Une utilisation étroitement liée est « bang » suivi d’un certain nombre de caractères, qui exécute la dernière commande qui a commencé par ces caractères.Par exemple, pour exécuter la dernière curlcommande, nous pourrions taper ceci :
                    <p class="cod">
                    $ !curl
                    </p> <br>
                    Cela nous éviterait d'avoir à saisir les options, l'URL, etc.En fonction de notre historique de commandes, le plus concis !cuou !cfonctionnerait tout aussi bien.Cette technique est particulièrement utile lorsque la commande souhaitée s'est produite il y a de nombreuses commandes, ce qui peut rendre l'utilisation de la flèche vers le haut fastidieuse. <br> <br>
                    
                    Une deuxième technique incroyablement puissante est ⌃R, qui vous permet de rechercher de manière interactive dans vos commandes précédentes, puis éventuellement de modifier le résultat avant de l'exécuter.Par exemple, nous pourrions essayer ceci pour afficher la dernière curlcommande :
                    <p class="cod">
                    $ ^R  <br>
                     (recherche-i-inverse)`': curl
                    </p> <br>
                    Sur la plupart des systèmes, appuyer sur Entrée placerait alors la dernière curlcommande après notre invite et nous permettrait de la modifier (si vous le souhaitez) avant d'appuyer sur Entrée pour l'exécuter.Lorsque votre flux de travail implique l’exécution répétée d’une variété de commandes similaires, il peut parfois sembler que « toutes les commandes commencent par ⌃R».
                </div>
                    <h2 id="vinneuf">3.1.1 Exercices</h2>
                   <p class="exo">1-Utilisez la commande curl -I https://www.learnenough.com/pour récupérer l' en-tête HTTP du site Web 643-code.Quel est le code d’état HTTP de l’adresse ?En quoi cela diffère-t-il du code d’état pour learnenough.com(sans le https://) ?</p>
                   <p class="exo">2-En utilisant ls, confirmez que sonnets.txtexiste sur votre système.Quelle est sa taille en octets ? Astuce : rappelez-vous de la section  2.2 que la « forme longue » de lsaffiche un nombre d’octets.</p>
                   <p class="exo">3-Le nombre d'octets dans l'exercice précédent est suffisamment élevé pour qu'il soit plus naturellement considéré en kilo-octets (souvent traités comme 1 000 octets, mais en réalité égaux à210= 1024
                    octets).En ajoutant l’ -hoption (« lisible par l’homme ») à ls, répertoriez la forme longue du fichier de sonnets avec un nombre d’octets lisible par l’homme.</p>
                   <p class="exo">4-Supposons que vous souhaitiez répertorier les fichiers et les répertoires en utilisant des nombres d'octets lisibles par l' homme, tous , par forme longue triée dans le temps inverse .Quelle commande utiliseriez-vous ?Pourquoi cette commande pourrait-elle être la préférée de l'auteur de ce tutoriel ?</p>
              
               
                   <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
         
        </section>
        <!-- 14 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="tun">3.2 Comprendre tout ça</h2>
                 <p class="lamda">Deux commandes complémentaires pour inspecter les fichiers sont headet tail, qui nous permettent respectivement de visualiser le début (tête) et la fin (queue) du fichier.La headcommande affiche les 10 premières lignes du fichier ( Listing  3.2 ).</p>
                 <p class="cod">
                    Liste 3.2 : Regard sur l’en-tête de l’exemple de fichier texte. <br>
                    $ head sonnets.txt <br>
                     Sonnets de Shakespeare <br> <br>
                    
                    I <br> <br>
                    
                    Nous désirons que les plus belles créatures s'accroissent,  <br>
                    afin que la rose de beauté ne meure jamais, <br>
                    mais que, comme les plus mûres devraient décéder avec le temps, <br>
                    son tendre héritier puisse porter sa mémoire :  <br>
                    mais toi, contracté à tes propres yeux brillants, tu  <br>
                    nourris la flamme de ta lumière d'un combustible auto-substantiel
                 </p>
                 <p class="lamda">De même, tailaffiche les 10 dernières lignes du fichier ( Listing  3.3 ).</p>
                 <p class="cod">
                    Liste 3.3 : Regard sur la fin de l’exemple de fichier texte. <br>
                    $ tail sonnets.txt <br>
                     La plus belle des dévotes prit ce feu <br>
                    Que de nombreuses légions de cœurs sincères avaient réchauffé ; <br>
                    Et ainsi le général du désir ardent <br>
                    Fut, endormi, par une main vierge désarmé. <br>
                    Ce tison, elle l'éteignit dans un puits frais, <br>
                    Qui du feu de l'Amour prit une chaleur perpétuelle, <br>
                    Devenant un bain et un remède salutaire, <br>
                    Pour les hommes malades ; mais moi, l'esclave de ma maîtresse, Je <br>
                    suis venu là pour la guérison et par cela je prouve que <br>
                    le feu de l'Amour chauffe l'eau, l'eau ne refroidit pas l'amour.
                 </p>
                 <p class="lamda">Ces deux commandes sont utiles lorsque (comme c'est souvent le cas) vous savez avec certitude que vous n'avez besoin d'inspecter que le début ou la fin d'un fichier.</p>
                  <h2 id="tdeux">3.2.1Nombre de mots et pipes</h2>
                 
                 
                 <p class="lamda">Au fait, je ne me souvenais pas du nombre de lignes headaffichées tailpar défaut.Comme il n’y a que 10 lignes dans la sortie, j’aurais pu les compter à la main, mais en fait, j’ai pu le déterminer en utilisant la wccommande (abréviation de « wordcount » ; rappelez-vous la figure  2.4 ).</p>
                 <p class="lamda">L'utilisation la plus courante de wcest sur des fichiers complets.Par exemple, nous pouvons sonnets.txtparcourir wc:</p>
                 <p class="cod">
                    $ wc sonnets.txt <br>
                    2620 17670 95635 sonnets.txt
                 </p>
                 <p class="lamda">Ici, les trois nombres indiquent combien de lignes, de mots et d'octets il y a dans le fichier, il y a donc 2620 lignes (remplissant ainsi la promesse faite à la fin de la section  3.1 ), 17670 mots et 95635 octets.</p>
                 <p class="lamda">Vous êtes maintenant en mesure de deviner une méthode permettant de déterminer le nombre de lignes contenues dans head sonnets.txt.En particulier, nous pouvons combiner headl'opérateur de redirection ( Section  2.1 ) pour créer un fichier avec le contenu pertinent, puis wcl'exécuter, comme indiqué dans la liste  3.4 .</p>
                 <p class="lamda"></p>
                 <p class="cod">
                    Liste 3.4 : Redirection headet exécution wcsur le résultat. <br>
                    $ tête sonnets.txt > sonnets_head.txt <br>
                     $ wc sonnets_head.txt <br>
                        10 46 294 sonnets_head.txt
                 </p>
                 <p class="lamda">Nous voyons dans la liste  3.4 qu'il y a 10 lignes head wc(avec 46 mots et 294 octets).La même méthode fonctionnerait bien sûr pour tail.</p>
                 <p class="lamda">D'un autre côté, vous pourriez avoir l'impression qu'il est un peu impur de créer un fichier intermédiaire juste pour wcl'exécuter, et il existe en effet un moyen d'éviter cela en utilisant une technique appelée pipes . La liste  3.5 montre comment procéder.</p>
                 <p class="cod">
                    Liste 3.5 : Acheminer le résultat de headvia wc. <br>
                    $ head sonnets.txt | wc <br>
                        10 46 294
                 </p>
                 <p class="lamda">La commande de la liste  3.5 s'exécute head sonnets.txtpuis transmet le résultat à l' wcaide du symbole de tuyau  |(Maj-barre oblique inverse sur la plupart des claviers QWERTY).La raison pour laquelle cela fonctionne est que la wccommande, en plus de prendre un nom de fichier comme argument, peut (comme de nombreux programmes Unix) prendre une entrée de « standard in » (comparer à « standard out » mentionné dans la section  1.3 ), qui dans ce cas est la sortie head sonnets.txtmontrée dans le listing  3.2 .Le wcprogramme prend cette entrée et la compte de la même manière qu'il compte un fichier, produisant les mêmes nombres de lignes, de mots et d'octets que la liste  3.4 .</p>
                 <h2 id="ttrois">3.2.2 Exercices</h2>
                 <p class="exo">1-En canalisant les résultats de tail sonnets.txtvia wc, confirmez que (comme head) la tailcommande génère 10 lignes par défaut.</p>
                 <p class="exo">2-En exécutant man head, apprenez à regarder les premières nlignes du fichier.En expérimentant différentes valeurs de n, trouvez une headcommande pour imprimer juste assez de lignes pour afficher le premier sonnet dans son intégralité ( Figure  1.11 ).</p>
                 <p class="exo">3-Transférez les résultats de l'exercice précédent tail(avec les options appropriées) pour imprimer uniquement les 14 lignes composant le Sonnet 1. Astuce : la commande ressemblera à head -n <i> sonnets.txt | tail -n <j>, où <i>et <j>représentent les arguments numériques de l' -noption.</p>
                 <p class="exo">4-L’une des applications les plus utiles de tailest de courir tail -fpour afficher un fichier qui change activement.Cela est particulièrement courant lors de la surveillance des fichiers utilisés pour enregistrer l'activité, par exemple, des serveurs Web, une pratique connue sous le nom de « suivi du fichier journal ».Pour simuler la création d'un fichier journal, exécutez ping learnenough.com > learnenough.logdans un onglet de terminal.(La pingcommande « ping » un serveur pour voir s'il fonctionne.)Dans un deuxième onglet, tapez la commande pour terminer le fichier journal.(À ce stade, les deux onglets seront bloqués, donc une fois que vous avez compris l'essentiel, tail -fvous devriez utiliser la technique de l'encadré  1.3 pour vous sortir du pétrin.)</p>






                 <button class="btn">Commencer: le chapitre</button>

             </div>
             
         </div>
 
        
        </section>
        <!-- 15-->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro"> 
                <h3>Chapitre 3</h3>                
                 <h2 id="tquatre">3.3 Moins c'est plus</h2>
                 <p class="lamda">Unix fournit deux utilitaires pour la tâche courante consistant à vouloir examiner plus que simplement la tête ou la queue d'un fichier.Le plus ancien de ces programmes s'appelle more, mais (je suppose que c'était initialement une blague ironique) il existe une variante plus puissante appelée less. 5Le lessprogramme est interactif, il est donc difficile de le capturer sur papier, mais voici à peu près à quoi il ressemble :</p>
                 <p class="cod">
                    $ less sonnets.txt <br>
                    Les sonnets de Shakespeare <br> <br>
                   
                   je <br> <br>
                   
                   Nous désirons l'accroissement des plus belles créatures, <br>
                   afin que la rose de beauté ne meure jamais, <br>
                   mais que, comme les plus mûres devraient mourir avec le temps, <br>
                   son tendre héritier puisse porter sa mémoire. <br>
                   Mais toi, contracté à tes propres yeux brillants, <br>
                   tu nourris la flamme de ta lumière d'un combustible auto-substantiel, <br>
                   créant une famine là où se trouve l'abondance, <br>
                   toi-même ton ennemi, trop cruel pour ton doux moi. <br>
                   Toi qui es maintenant le nouvel ornement du monde, <br>
                   et seul annonciateur du printemps éclatant, <br>
                   tu enfouis ton contenu dans ton propre bourgeon, <br>
                   et tu gaspilles, tendre rustre, en avarices. <br>
                   Aie pitié du monde, ou bien ce glouton sera, <br>
                   pour manger le dû du monde, par la tombe et par toi. <br><br>
                   
                   II <br><br>
                   
                   Quand quarante hivers assiégeront ton front, <br>
                   Et creuseront de profondes tranchées dans le champ de ta beauté, <br>
                   sonnets.txt
                 </p>
                 <p class="lamda">L'intérêt de lesscette fonction est qu'elle vous permet de naviguer dans le fichier de plusieurs manières utiles, comme déplacer une ligne vers le haut ou vers le bas avec les touches fléchées, appuyer sur la barre d'espace pour déplacer une page vers le bas et appuyer ⌃Fpour avancer d'une page (c'est-à-dire la même chose que la barre d'espace) ou ⌃Bpour reculer d'une page.Pour quitter less, tapez q(pour « quitter »).</p>
                 <p class="cycle spec"><img src="/ressources/t13.png" alt=""></p>
                 <p class="fig">Figure 3.1 : Une rose célèbre de l’époque de Shakespeare.</p>
                 
                 <p class="lamda">L'aspect le plus puissant de lessest peut-être la touche barre oblique  /, qui vous permet de rechercher dans le fichier du début à la fin.Par exemple , supposons que nous voulions rechercher sonnets.txt« rose » ( Figure  3.1 ), 6 l’une des images les plus fréquemment utilisées dans les Sonnets .La façon de procéder lessest de taper /rose(lire « slash rose »), comme indiqué dans la liste  3.6 .</p>
                 <p class="cod">
                    Liste 3.6 : Recherche de la chaîne « rose » à l’aide de less. <br>
                    Les sonnets de Shakespeare <br> <br>
                    
                    je <br> <br>
                    
                    Nous désirons l'accroissement des plus belles créatures, <br>
                    afin que la rose de beauté ne meure jamais, <br>
                    mais que, comme les plus mûres devraient mourir avec le temps, <br>
                    son tendre héritier puisse porter sa mémoire. <br>
                    Mais toi, contracté à tes propres yeux brillants, <br>
                    tu nourris la flamme de ta lumière d'un combustible auto-substantiel, <br>
                    créant une famine là où se trouve l'abondance, <br>
                    toi-même ton ennemi, trop cruel pour ton doux moi. <br>
                    Toi qui es maintenant le nouvel ornement du monde, <br>
                    et seul annonciateur du printemps éclatant, <br>
                    tu enfouis ton contenu dans ton propre bourgeon, <br>
                    et tu gaspilles, tendre rustre, en avarices. <br>
                    Aie pitié du monde, ou bien ce glouton sera, <br>
                    pour manger le dû du monde, par la tombe et par toi. <br><br>
                    
                    II <br><br>
                    
                    Quand quarante hivers assiégeront ton front, <br>
                    et creuseront de profondes tranchées dans le champ de ta beauté, <br>
                    /rose
                 </p>
                 <p class="lamda">Le résultat d’appuyer sur Entrée après avoir tapé /rosedans la liste  3.6 est de mettre en évidence la première occurrence de « rose » dans le fichier.Vous pouvez ensuite appuyer sur npour accéder au match suivant ou Nsur pour accéder au match précédent.</p>
                 <p class="lamda">Les deux dernières lesscommandes essentielles permettent Gde se déplacer à la fin du fichier et 1G( 1suivi de G) de revenir au début. Le tableau  3.1 résume ce qui sont à mon avis les combinaisons de touches les plus importantes (c'est-à-dire celles dont je pense qu'elles sont nécessaires pour être dangereuses ), mais si vous êtes curieux, vous pouvez trouver une liste plus longue de commandes sur la page Wikipédia surless .</p>
                 <p class="lamda">Je vous encourage à prendre l’habitude d’utiliser lesscomme utilitaire de référence pour consulter le contenu d’un fichier.Les compétences que vous développez ont également d'autres applications ; par exemple, les pages de manuel ( Section  1.4 ) utilisent la même interface que less, donc en apprenant à connaître , lessvous vous améliorerez également dans la navigation dans les pages de manuel.</p>
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Commande</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Description</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Exemple</font></font></strong></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">up &amp; down arrow keys</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Monter ou descendre d'une ligne</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">spacebar</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Avancer d'une page</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">⌃F</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Avancer d'une page</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">⌃B</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Reculer d'une page</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">G</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Déplacer vers la fin du fichier</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">1G</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Déplacer au début du fichier</font></font></td>
                    <td class="align_left"></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">/&lt;string&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Rechercher une chaîne dans un fichier</font></font></td>
                    <td class="align_left"><code>/rose</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">n</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Passer au résultat de recherche suivant</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">N</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Accéder au résultat de recherche précédent</font></font></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">q</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Quitter</font></font><code>less</code>
                    </td>
                    </tr>
                    </tbody>
                    </table>
                    <p class="fig">Tableau 3.1 : Les commandes les plus importantes .less</p>
                 
                 <h2 id="tcinq">3.3.1 Exercices</h2>
                 <p class="exo">1-Continuez lessà courir sonnets.txt.Descendez de trois pages, puis remontez de trois pages.Allez à la fin du fichier, puis au début, puis quittez.</p>
                 <p class="exo">2-Recherchez la chaîne « All » (sensible à la casse).Avancez de quelques occurrences, puis reculez de quelques occurrences.Allez ensuite au début du fichier et comptez les occurrences en recherchant vers l'avant jusqu'à atteindre la fin.Comparez votre compte au résultat de l'exécution grep All sonnets.txt | wc.(Nous en apprendrons davantage à ce sujet grepdans la section  3.4 .)</p>
                 <p class="exo">3-En utilisant lesset /(« slash »), trouvez le sonnet qui commence par la ligne « Let me not ».Y a-t-il d'autres occurrences de cette chaîne dans les Sonnets ? Astuce : Appuyez npour trouver l'occurrence suivante (le cas échéant). Crédit supplémentaire : écoutez le sonnet dans la prononciation moderne et originale .Quelle version a le meilleur schéma de rimes ?</p>
                 <p class="exo">4-Grâce à manl'utilisation de less, nous sommes désormais en mesure de rechercher des pages de manuel de manière interactive.En recherchant la chaîne « sort » dans la page de manuel de ls, découvrez l’option permettant de trier les fichiers par taille.Quelle est la commande pour afficher la forme longue des fichiers triés afin que les fichiers les plus volumineux apparaissent en bas ? Astuce : utiliser ls -rtlcomme modèle.</p>
                 <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
        
        </section>
        <!-- 16 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="tsix">3.4 Grepping</h2>

                 <p class="lamda">L'un des outils les plus puissants pour inspecter le contenu des fichiers est grep, qui signifie probablement quelque chose, mais ce n'est pas important.(Nous en parlerons dans un instant.)En effet, grep est fréquemment utilisé comme verbe, comme dans « Vous devriez absolument utiliser grep pour ce fichier ».</p>
                 <p class="lamda">L’utilisation la plus courante de grepest simplement de rechercher une sous-chaîne dans un fichier.Par exemple, nous avons vu dans la section  3.3 comment utiliser lesspour rechercher la chaîne « rose » dans les sonnets de Shakespeare.En utilisant grep, nous pouvons trouver les références directement, comme indiqué dans la liste  3.7 .</p>
                 <p class="cod">
                    Liste 3.7 : Trouver les occurrences de « rose » dans les sonnets de Shakespeare. <br>
                    $ grep rose sonnets.txt <br>
                     La rose paraît belle, mais nous la jugeons plus belle <br>
                    Que la teinture parfumée des roses. <br>
                    Mourir à elles-mêmes. Les douces roses ne font pas ainsi ; <br>
                    Roses d'ombre, puisque sa rose est vraie ? <br>
                    Qui, comme un chancre dans la rose parfumée, <br>
                    Ne louent pas le vermillon profond de la rose ;  <br>
                    Les roses se tenaient craintivement sur les épines, <br>
                    Sauf toi, ma rose, en elle tu es tout pour moi. <br>
                    J'ai vu des roses damassées, rouges et blanches, <br>
                    Mais je ne vois pas de telles roses sur ses joues ;
                 </p>
                 <p class="lamda">Avec la commande du Listing  3.7 , il semble que nous soyons en mesure de compter le nombre de lignes contenant des références au mot « rose » en utilisant un canal vers wc(comme dans la section  3.3 ), comme indiqué dans le Listing  3.8 .</p>
             <p class="lamda"></p>
             <p class="cod">
                Liste 3.8 : Transmission des résultats de grepvers wc. <br>
                $ grep rose sonnets.txt | wc <br>
                    10 82 419
             </p>
             <p class="lamda">Le listing  3.8 nous indique que 10 lignes contiennent « rose » (ou « roses », puisque « rose » est une sous-chaîne de « roses »).Mais vous vous souviendrez peut-être, d’après la figure  1.11 , que le premier sonnet de Shakespeare contient « Rose » avec un « R » majuscule .En se référant à la liste  3.7 , nous constatons que cette ligne a en fait été manquée.C'est parce qu'il grepest sensible à la casse par défaut et que « rose » ne correspond pas à « Rose ».</p>
             <p class="lamda">Comme vous pouvez vous en douter, grepil dispose également d'une option permettant d'effectuer une correspondance insensible à la casse.Une façon de le savoir est de rechercher dans la manpagegrep :</p>
             <p class="lamda">
                1-Taper man grep. <br>
                2-Tapez /casepuis revenez. <br>
                3-Lisez le résultat ( Figure  3.2 ).
             </p>
             <p class="lamda">(Comme indiqué brièvement dans la section  1.4 , les pages de manuel utilisent la même interface que la lesscommande que nous avons rencontrée dans la section  3.3 , nous pouvons donc les parcourir en utilisant  /.)</p>
             <p class="cycle spec"><img src="/ressources/t14.png" alt=""></p>
             <p class="fig">Figure 3.2 : Résultat de la recherche man grepde « case ».</p>
             
             
             <p class="lamda">L’application du résultat de la procédure ci-dessus donne la liste  3.9 .En comparant les résultats du Listing  3.9 avec le Listing  3.8 , nous voyons que nous avons maintenant 12 lignes correspondantes au lieu de seulement 10, il doit donc y avoir un total de12 − 10 = 2
                vers contenant « Rose » (mais pas « rose ») dans les Sonnets</p>
             <p class="cod">
                Liste 3.9 : Exécution d'un grep insensible à la casse. <br>
                $ grep -i rose sonnets.txt | wc <br>
                    12 96 508
             </p>
             <p class="lamda">L' greputilitaire tire son nom d'un système de recherche de motifs appelé expressions régulières (également appelé regexes en abrégé) : grep signifie « rechercher globalement une expression régulière et l' imprimer » .Un traitement complet des expressions régulières dépasse largement le cadre de ce tutoriel, mais avant de continuer, nous allons en échantillonner un petit aperçu.</p>
             <p class="lamda">À titre d’exemple simple, faisons correspondre chaque ligne sonnets.txtqui contient un mot commençant par les lettres « ro », suivi d’un nombre quelconque de lettres (minuscules) et se terminant par « s ».La façon de représenter « n’importe quelle lettre » avec une expression régulière est [a-z], et suivre un modèle avec un astérisque  *correspond à « zéro ou plus » de cette chose.Ainsi, ro[a-z]*scorrespond à « ro » et « s » avec zéro ou plusieurs lettres entre les deux.Nous pouvons ajouter des espaces au début et à la fin pour garantir que la correspondance se compose de mots entiers, comme ceci :</p>
             <p class="cod">
                $ grep ' ro[az]*s ' sonnets.txt  <br>
                À ce doux voleur qui me vole amèrement. <br>
             Mourez à eux-mêmes. Les douces roses ne font pas ainsi ; <br>
             Quand les rochers imprenables ne sont pas si robustes, <br>
             Il te vole, et te le rend. <br>
             Les roses se tenaient effrayantes sur des épines, <br>
             J'ai vu des roses damassées, rouges et blanches, <br>
             Mais je ne vois pas de telles roses sur ses joues ;
             </p>
             <p class="lamda">Nous pouvons voir que l’expression régulière correspond à des chaînes telles que « robs » et « rocks » en plus de « roses ».</p>
             <p class="lamda">En général, l’un des meilleurs outils pour apprendre à utiliser les expressions régulières est un générateur d’expressions régulières en ligne , tel que regex101 , qui vous permet de créer des expressions régulières de manière interactive ( Figure  3.3 ).Malheureusement, grepil ne prend souvent pas en charge le format précis utilisé par les générateurs d'expressions régulières (y compris les exigences difficiles à deviner pour « échapper » les caractères spéciaux), et la précision dans les expressions régulières est primordiale.Par conséquent, malgré l’origine de son nom, la vérité est que j’utilise rarement les capacités d’expression régulière de grep.Au moment où la situation nécessite des expressions régulières, je suis beaucoup plus susceptible d'utiliser un éditeur de texte ( 643-code Text Editor pour se perfectionner ) ou un langage de programmation complet ( 643-code JavaScript pour se perfectionner , 643-code ruby pour se perfectionner ).</p>
            
             <p class="cycle spec"><img src="/ressources/t15.png" alt=""></p>
             <p class="fig">Figure 3.3 : Un générateur d’expressions régulières en ligne .</p>
             <p class="lamda">Néanmoins, les aspects grepabordés dans cette section sont presque suffisants  , couvrant un grand nombre de cas courants (y compris l'application importante des processus de grepping ( encadré  3.2 )).Nous verrons une dernière grepvariante au chapitre  4 dans le cadre de notre discussion sur les répertoires Unix.</p>
             <div class="comment">
                Encadré 3.2. Processus de grepping
                L’une des nombreuses utilisations de est le filtrage de la liste des processusgrep Unix pour exécuter des programmes correspondant à une chaîne particulière.(Sur les systèmes de type Unix tels que Linux et macOS, les tâches utilisateur et système se déroulent chacune dans un conteneur bien défini appelé processus .)Ceci est particulièrement utile lorsqu'un processus malveillant sur votre système doit être supprimé.(Une bonne façon de trouver de tels processus est d’exécuter la topcommande, qui affiche les processus consommant le plus de /ressources.)
                
                Par exemple, à un moment donné dans le livre ruby Tutorial , il est important d'éliminer un programme appelé springde la liste des processus.Pour ce faire, il faut d'abord trouver les processus, et la façon de voir tous les processus de votre système est d'utiliser la pscommande avec les auxoptions :
                <p class="cod">
                $ ps aux
               </p>
                Selon la pratique habituelle de concision d'Unix ( Figure  2.4 ), psest l'abréviation de « état du processus ».Et pour des raisons confuses et obscures , les options à psne sont pas écrites avec un tiret (c'est donc ps auxà la place de ps -aux).(Comment diable es-tu censé savoir cela ?C'est à cela que sert ce tutoriel.)
                
                Pour filtrer les processus par nom de programme, vous canalisez les résultats psviagrep :
                <p class="cod">
                $ ps aux | grep spring <br>
                 ubuntu 12241 0.3 0.5 589960 178416 ? Ssl 20 sept. 1:46  <br>
                 spring app | sample_app | démarré il y a 7 heures </p>
                Le résultat affiché donne quelques détails sur le processus, mais le plus important est le premier numéro, qui est l' identifiant du processus , ou pid (souvent prononcé pour rimer avec « kid »).Pour éliminer un processus indésirable, nous utilisons la killcommande pour émettre le code de terminaison Unix (qui se trouve être 15 ) au PID :
                <p class="cod">
                $ tuer -15 12241 </p>
                C'est la technique que je recommande pour tuer des processus individuels, comme un serveur Web malveillant (avec le PID trouvé via ps aux | grep server), mais il est parfois pratique de tuer tous les processus correspondant à un nom de processus particulier, comme lorsque vous souhaitez tuer tous les springprocessus qui encombrent votre système.Dans ce cas, vous pouvez tuer tous les processus portant le nom springen utilisant la pkillcommande suivante :
                <p class="cod">
                $ pkill -15 -f printemps </p>
                Chaque fois que quelque chose ne se comporte pas comme prévu ou qu'un processus semble gelé, c'est une bonne idée d'exécuter topou ps auxpour voir ce qui se passe, ps auxde grepsélectionner les processus suspects, puis d'exécuter kill -15 <pid>ou pkill -15 -f <name>pour clarifier les choses.

                </div>

             <h2 id="tsept">3.4.1 Exercices</h2>
             <p class="exo">1-En recherchant man grep« numéro de ligne », construisez une commande pour trouver les numéros de ligne sonnets.txtoù la chaîne « rose » apparaît.</p>
             <p class="exo">2-Vous devriez constater que la dernière occurrence de « rose » est (via « roses ») à la ligne 2203.Découvrez comment accéder directement à cette ligne lors de l'exécution less sonnets.txt. Astuce : rappelez-vous du tableau  3.1 qui 1Gva jusqu'au début du fichier, c'est-à-dire la ligne 1.De même, 17Gpasse à la ligne 17.Etc.</p>
             <p class="exo">3-En canalisant la sortie de grepvers head, imprimez la première (et seulement la première) ligne sonnets.txtcontenant « rose ». Astuce : utilisez le résultat du deuxième exercice de la section  3.2.2 .</p>
             <p class="exo">4-Dans la liste  3.9 , nous avons vu deux lignes supplémentaires qui correspondaient sans distinction de casse à « rose ».Exécutez une commande confirmant que les deux lignes contiennent la chaîne « Rose » (et non, par exemple, « rOSe »). Astuce : utilisez une casse greppour « Rose ».</p>
             <p class="exo">5-Vous devriez constater dans l’exercice précédent qu’il y a trois lignes correspondant à « Rose » au lieu des deux que vous auriez pu attendre de la liste  3.9 .C'est parce qu'il y a une ligne qui contient à la fois « Rose » et « rose », et qui apparaît donc à la fois dans grep roseet grep -i rose.Écrivez une commande confirmant que le nombre de lignes correspondant à « Rose » mais ne correspondant pas à « rose » est égal aux 2 attendus. Astuce : dirigez le résultat de grepvers grep -v, puis dirigez ce résultat vers  wc.(Que fait- -vil ?Lisez la page de manuel de grep( Encadré  1.4 ).)</p>
             










             <button class="btn">Commencer: le chapitre</button>
                 
             </div>
             
             
         </div>
 
        
        </section>
        <!-- 17-->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 3</h3>
                 <h2 id="thuit">3.5 Résumé</h2>
                 <p class="lamda">Les commandes importantes de ce chapitre sont résumées dans le tableau  3.2 .</p>

                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Commande</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Description</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Exemple</font></font></strong></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">curl</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Interagir avec les URL</font></font></td>
                    <td class="align_left"><code>$ curl -O https://ex.co</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">which</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Localiser un programme sur le chemin</font></font></td>
                    <td class="align_left"><code>$ which curl</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">head &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Afficher la première partie du fichier</font></font></td>
                    <td class="align_left"><code>$ head foo</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">tail &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Afficher la dernière partie du fichier</font></font></td>
                    <td class="align_left"><code>$ tail bar</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">wc &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Compter les lignes, les mots, les octets</font></font></td>
                    <td class="align_left"><code>$ wc foo</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">cmd1 | cmd2</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Tuyau </font></font><code class="tt">cmd1</code><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">à</font></font><code class="tt">cmd2</code>
                    </td>
                    <td class="align_left"><code>$ head foo | wc</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ping &lt;url&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Envoyer une requête ping à l'URL d'un serveur</font></font></td>
                    <td class="align_left"><code>$ ping google.com</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">less &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Afficher le contenu du fichier de manière interactive</font></font></td>
                    <td class="align_left"><code>$ less foo</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">grep &lt;string&gt; &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Rechercher une chaîne dans un fichier</font></font></td>
                    <td class="align_left"><code>$ grep foo bar.txt</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">grep -i &lt;string&gt; &lt;file&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Rechercher sans tenir compte de la casse</font></font></td>
                    <td class="align_left"><code>$ grep -i foo bar.txt</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">ps</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Afficher les processus</font></font></td>
                    <td class="align_left"><code>$ ps aux</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">top</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Afficher les processus (triés)</font></font></td>
                    <td class="align_left"><code>$ top</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">kill -&lt;level&gt; &lt;pid&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Tuer un processus</font></font></td>
                    <td class="align_left"><code>$ kill -15 24601</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">pkill -&lt;level&gt; -f &lt;name&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Tuer les processus correspondants</font></font></td>
                    <td class="align_left"><code>$ pkill -15 -f spring</code></td>
                    </tr>
                    </tbody>
                    </table>


                    <h2 id="tneuf">3.5.1 Exercices</h2>
                    <p class="exo">1-La historycommande imprime l'historique des commandes dans un shell de terminal particulier (sous réserve d'une certaine limite, qui est généralement grande).Accédez historyà lesspour examiner votre historique de commandes.Quel était votre 17ème commandement ?</p>
                    <p class="exo">2-En canalisant la sortie de historyvers wc, comptez le nombre de commandes que vous avez exécutées jusqu'à présent.
                    </p>
                    <p class="exo">3-L'une des utilisations de historyest de rechercher vos commandes pour trouver celles utiles que vous avez déjà utilisées, chaque commande étant précédée du numéro correspondant dans l'historique des commandes.En canalisant la sortie de historyvers grep, déterminez le numéro de la dernière occurrence de curl.</p>
                    <p class="exo">4-Dans l’encadré  3.1 , nous avons appris à utiliser !!(« bang bang ») pour exécuter la commande précédente.De même, !nexécute la commande numéro n, de sorte que, par exemple, !17exécute la 17e commande dans l'historique des commandes.Utilisez le résultat de l’exercice précédent pour réexécuter la dernière occurrence de curl.</p>

                    <p class="exo">5-Que signifient les options Oet dans la liste  3.1 ?L Astuce : dirigez la sortie de curl -hvers lesset recherchez d'abord la chaîne -O, puis la chaîne -L.</p>

                    <button class="btn">Commencer: le chapitre</button>
                 
             </div>
             
         </div>
 
         
        </section>
        <!-- 18-->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3 id="chap4">Chapitre 4</h3>
                 <h2 id="qun">Répertoires</h2>
                 <p class="lamda">Après avoir examiné de nombreux utilitaires Unix pour gérer les fichiers, le moment est venu d'en apprendre davantage sur les répertoires , parfois connus sous le nom de dossiers synonymes ( Figure  4.1 ).Comme nous le verrons, de nombreuses idées développées dans le contexte des fichiers s’appliquent également aux répertoires, mais il existe également de nombreuses différences.</p>
                 <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
         
        </section>
        <!-- 19 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 4</h3>
                 <h2 id="qdeux">4.1 Structure du répertoire</h2>

                <p class="lamda">La structure des répertoires de style Unix est généralement indiquée à l'aide d'une liste de noms de répertoires séparés par des barres obliques, que nous pouvons combiner avec la lscommande ( Section  2.2 ) comme ceci :</p>
                <p class="cod">$ ls /Utilisateurs/mhartl/ruby</p>
                <p class="lamda">ou comme ça :</p>
                <p class="cod">$ ls /usr/local/bin</p>
                <p class="lamda">Comme le montre la figure  4.1 , ces représentations correspondent à des répertoires dans un système de fichiers hiérarchique, avec (par exemple) mhartlun sous-répertoire de Userset rubyun sous-répertoire de mhartl.</p>

                <p class="cycle spec"><img src="/ressources/t16.png" alt=""></p>
                <p class="fig">Figure 4.1 : La correspondance entre les dossiers et les répertoires.</p>
                <p class="lamda">Les conventions varient lorsqu'on parle de répertoires : un répertoire utilisateur comme /Users/mhartlserait probablement lu comme « slash users slash mhartl » ou « slash users mhartl », alors que l'omission de la barre oblique initiale dans le langage parlé est courante pour les répertoires système tels que /usr/local/bin, qui seraient probablement prononcés « user local bin ». 1Étant donné que tous les répertoires Unix sont en fin de compte des sous-répertoires du répertoire racine / (prononcé « slash »), les barres obliques de début et de fin sont implicites. Remarque : désigner les barres obliques par erreur comme des « barres obliques inverses » est une source de souffrance intense et doit être strictement évité.</p>
                <p class="lamda">Le répertoire le plus important pour un utilisateur particulier est le répertoire personnel , qui sur mon système macOS est /Users/mhartl, correspondant à mon nom d'utilisateur ( mhartl).Le répertoire personnel peut être spécifié sous la forme d'un chemin absolu , comme dans /Users/mhartl, ou en utilisant le raccourci pour le répertoire personnel, le caractère tilde  ~(qui est tapé à l'aide de Maj-backtick, situé juste à gauche du chiffre 1 sur la plupart des claviers).Par conséquent, les deux chemins représentés dans la figure  4.1 sont identiques : /Users/mhartl/ruby/projectsest identique à ~/ruby/projects.(Il est amusant de constater que la raison pour laquelle le caractère tilde est utilisé pour le répertoire personnel est simplement que la touche « Accueil » était la même que la touche permettant de produire « ~ » sur certains des premiers claviers .)</p>
                <p class="lamda">En plus des répertoires utilisateurs, chaque système Unix dispose de répertoires système pour les programmes essentiels au fonctionnement normal de l'ordinateur.La modification des fichiers ou des répertoires système nécessite des pouvoirs spéciaux accordés uniquement au superutilisateur , appelé root.(Cette utilisation de « root » n’est pas liée au « répertoire racine » mentionné ci-dessus.)Le superutilisateur est si puissant qu'il est considéré comme une mauvaise pratique de se connecter en tant que root; à la place, les tâches exécutées en tant rootque devraient généralement utiliser la sudocommande ( Encadré  4.1 ).</p>
                <div class="comment">
                    Encadré 4.1. « sudoFais-moi un sandwich. » <br>
                    sudodonne aux utilisateurs ordinaires le pouvoir d'exécuter des commandes en tant que superutilisateur.Par exemple, essayons touchd’écrire un fichier dans le répertoire système /optcomme suit :
                    <p class="cod">
                    $ touch /opt/foo  <br>
                     touch : /opt/foo : Permission refusée </p>
                    Étant donné que les utilisateurs normaux n'ont pas l'autorisation de modifier /opt, la commande échoue, mais elle réussit avecsudo :
                    <p class="cod">
                    $ sudo touch /opt/foo  <br>
                     Mot de passe : </p>
                    Comme indiqué, après l'entrée, sudonous sommes invités à entrer notre mot de passe utilisateur ; s'il est entré correctement et si l'utilisateur a été configuré pour avoir sudodes privilèges (ce qui est la valeur par défaut sur la plupart des systèmes Unix de bureau), alors la commande réussira.Comme le montre la bande dessinée xkcd « Sandwich », ce modèle de refus initial, suivi d'un succès en utilisant sudo, est un modèle courant lors de l'utilisation de la ligne de commande.
                    
                    Pour vérifier que le fichier a bien été créé, on peut lsle faire :
                    <p class="cod">
                    $ ls -l /opt/foo  <br>
                     -rw-r--r-- 1 roue racine 0 23 juil. 19:13 /opt/foo </p>
                    Notez que (1) un utilisateur normal peut accéder lsà un fichier dans un répertoire système (sans sudo) et (2) le nom rootapparaît dans la liste, indiquant que le superutilisateur est propriétaire du fichier.(La signification du deuxième terme, wheel, est un peu obscure, mais vous pouvez en apprendre davantage sur un site appelé, à juste titre, superuser .)
                    
                    Pour supprimer le fichier que nous venons de créer, nous avons à nouveau besoin du statut de superutilisateur :
                    <p class="cod">
                    $ rm -f /opt/foo <br>
                     rm: /opt/foo: Permission refusée <br>
                     $ sudo !! <br>
                     $ !ls  <br>
                     ls: /opt/foo: Aucun fichier ou répertoire de ce type </p>
                    Ici, le premier rméchoue, nous avons donc exécuté sudo !!, qui exécute sudopuis la commande précédente , et nous avons suivi avec !ls, qui exécute la commande précédente ls( Encadré  3.1 ). <br>
                    
                    Il convient également de noter la prononciation anglaise de quelque chose comme sudo !!, ce qui est important lors de la communication par le biais du langage parlé.Comme indiqué dans l’encadré  3.1 , !!se prononce « bang bang ». sudo, quant à lui, se prononce soit « SOO-doo » soit « SOO-doh ».Les deux prononciations sont courantes, même si je préfère la première car le doin sudoest en fait simplement le mot anglais « do ».Ainsi, ma prononciation préférée pour sudo !!est « SOO-doo bang bang ». <br>
                    
                    À propos, à l'originesu , le « in » signifiait « super-utilisateur », mais au fil du temps, son utilisation s'est étendue et il est désormais généralement considéré comme « utilisateur de substitution ».sudo sudoest donc une contraction de « substitute user do », l'utilisateur remplaçant étant le superutilisateur par défaut.Étant donné que le superutilisateur peut tout faire, la commande « sudo fais-moi un sandwich » dans « Sandwich » réussit alors qu’un simple « fais-moi un sandwich » échoue.
                </div>


                  <h2 id="qtrois">4.1.1 Exercices</h2>
                  <p class="exo">1-Écrivez avec les mots avec lesquels vous pourriez parler du répertoire ~/foo/bar</p>
                  <p class="exo">2-Dans /Users/bill/sonnets, quel est le répertoire personnel ?Quel est le nom d'utilisateur ?Quel répertoire est le plus profond dans la hiérarchie ?
                </p>
                  <p class="exo">3-Pour un utilisateur avec un nom d'utilisateur bill, en quoi /Users/bill/sonnetset ~/sonnetsdiffèrent-ils (le cas échéant) ?</p>



                  <button class="btn">Commencer: le chapitre</button>

                 
             </div>
             
         </div>
 
         
        </section>
        <!-- 20 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 4</h3>
                 <h2 id="qquatre">4.2 Créer des répertoires</h2>
                 <p class="lamda">Jusqu'à présent dans ce didacticiel, nous avons créé (et supprimé) un grand nombre de fichiers texte.Le temps est enfin venu de créer un répertoire pour les contenir.Bien que la plupart des systèmes d'exploitation modernes incluent une interface graphique pour cette tâche, la méthode Unix pour le faire est d'utiliser mkdir(abréviation de « make directory », selon la figure  2.4 ) :</p>
                 <p class="cod">$ mkdir fichiers_texte</p>
                 <p class="lamda">Après avoir créé le répertoire, nous pouvons y déplacer les fichiers texte à l'aide d'un caractère générique :</p>
                 <p class="cod">$ mv *.txt fichiers_texte/</p>
                 <p class="lamda">Nous pouvons confirmer que le déplacement a fonctionné en listant le répertoire :</p>
                 <p class="cod">$ ls text_files/ <br>
                    sonnet_1.txt sonnet_1_reversed.txt sonnets.txt</p>
                 <p class="lamda">
                    (Selon la mesure dans laquelle vous avez suivi ce tutoriel, vos résultats peuvent varier.) <br>

                    Par défaut, l'exécution lssur un répertoire affiche son contenu , mais nous pouvons afficher uniquement le répertoire en utilisant l' -doption :
                 </p>
                 <p class="cod">$ ls -d fichiers_texte/ <br>
                    fichiers_texte/</p>
                 <p class="lamda">Cette utilisation est particulièrement courante avec l' -loption ( Section  2.2 ) :</p>
                 <p class="cod">
                    $ ls -ld text_files/ <br>
                    drwxr-xr-x 7 mhartl staff 238 24 juil. 18:07 text_files
                 </p>
                 <p class="lamda">Enfin, nous pouvons changer de répertoire en utilisant cd:</p>
                 <p class="cod">$ cd fichiers_texte/</p>
                 <p class="lamda">
                    Notez que cdprend généralement en charge la saisie semi-automatique par tabulation, donc (comme décrit dans l'encadré  2.4 ) nous pouvons réellement taper cd tex⇥. <br><br>

                    Après avoir exécuté cd, nous pouvons confirmer que nous sommes dans le bon répertoire en utilisant la commande « imprimer le répertoire de travail », pwdainsi qu'un autre appel àls :
                 </p>
                 <p class="cod">
                    $ pwd <br>
                    /Users/mhartl/text_files <br>
                    $ ls <br>
                     sonnet_1.txt sonnet_1_reversed.txt sonnets.txt
                 </p>
                 <p class="lamda">Ces dernières étapes de saisie pwdpour vérifier le répertoire, et surtout d'exécution lspour inspecter le contenu du répertoire, sont une question d'habitude pour de nombreux vétérans grisonnants de la ligne de commande.(Votre résultat pwdsera bien sûr différent, à moins que vous n'utilisiez le nom d'utilisateur « mhartl » sur macOS.)

                 </p>
                 <h2 id="qcinq">4.2.1 Exercices</h2>
                 <p class="exo">1-Quelle est l'option permettant de créer des répertoires intermédiaires selon les besoins, afin de pouvoir les créer, par exemple, ~/fooavec ~/foo/barune seule commande ? Astuce : reportez-vous à la page de manuel pour mkdir.</p>
                 <p class="exo">2-Utilisez l'option de l'exercice précédent pour créer le répertoire fooet, à l'intérieur de celui-ci, le répertoire bar(c'est-à-dire ~/foo/bar) avec une seule commande.</p>
                 <p class="exo">3-En redirigeant la sortie de lsvers grep, répertoriez tout ce qui se trouve dans le répertoire personnel et qui contient la lettre « o ».</p>
                








                 <button class="btn">Commencer: le chapitre</button>

                 
             </div>
             
         </div>
 
         
        </section>
        <!-- 21 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 4</h3>
                 <h2 id="qsix">4.3 Navigation dans les répertoires</h2>
                 <p class="lamda">Nous avons vu dans la section  4.2 comment utiliser cdpour changer de répertoire avec un nom donné.C'est l'une des manières de naviguer les plus courantes, mais il existe quelques formes spéciales qui méritent d'être connues.La première consiste à passer au répertoire situé un niveau plus haut dans la hiérarchie en utilisant cd ..(lire « see-dee dot-dot ») :</p>
                 
                 <p class="cod">
                    $ pwd <br>
                    /Utilisateurs/mhartl/fichiers_texte <br>
                    $ cd .. <br>
                     $ pwd  <br>
                    /Utilisateurs/mhartl
                 </p>
                 <p class="lamda">Dans ce cas, comme /Users/mhartlc'est mon répertoire personnel , nous aurions pu réaliser la même chose en utilisant cdlui-même :</p>
                 <p class="cod">
                    $ cd fichiers_texte/ <br>
                    $ pwd <br>
                   /Utilisateurs/mhartl/fichiers_texte <br>
                   $ cd <br>
                   $ pwd  <br>
                   /Utilisateurs/mhartl
                 </p>
                 <p class="lamda">La raison pour laquelle cela fonctionne est que cdcela change automatiquement le répertoire personnel de l'utilisateur, où qu'il se trouve.Cela signifie que</p>
                 <p class="cod">$ cd</p>
                 <p class="lamda">et</p>
                 <p class="cod">$ cd ~</p>
                 <p class="lamda">
                    sont équivalents. <br>

                    Lors du changement de répertoire, il est souvent utile de pouvoir spécifier le répertoire personnel d'une manière ou d'une autre.Par exemple, supposons que nous créions un deuxième répertoire et cdque nous y mettions :
                 </p>
                 <p class="cod">
                    $ pwd <br>
                    /Users/mhartl  <br>
                    $ mkdir second_directory <br>
                     $ cd second_directory/
                 </p>
                 <p class="lamda">Maintenant, si nous voulons changer de text_filesrépertoire, nous pouvons cdle faire text_filesvia le répertoire personnel  ~:</p>
                 <p class="cod">
                    $ pwd <br>
                    /Users/mhartl/second_répertoire <br>
                    $ cd ~/fichiers_texte <br>
                     $ pwd <br>
                    /Users/mhartl/fichiers_texte
                 </p>
                 <p class="lamda">D'ailleurs, nous sommes maintenant en mesure de comprendre les invites affichées dans la Figure  1.6 : J'ai configuré mon invite pour afficher le répertoire actuel, qui pourrait être quelque chose comme [~], [ruby], ou [projects].(Nous discuterons de la façon de personnaliser l'invite dans 643-code Text Editor pour se perfectionner .Les lecteurs particulièrement avides peuvent exercer leur sophistication technique ( encadré  1.4 ) en cherchant sur Google comment procéder .)</p>
                 <p class="lamda">Étroitement lié à ..« un répertoire vers le haut » est .(lire « point ») qui signifie « le répertoire actuel ».L'utilisation la plus courante de .est lors du déplacement ou de la copie de fichiers vers le répertoire actuel :</p>
                 <p class="cod">
                    $ pwd <br>
                    /Utilisateurs/mhartl/fichiers_texte <br>
                    $ cd ~/second_répertoire <br>
                     $ ls <br>
                     $ cp ~/fichiers_texte/sonnets.txt . <br>
                     $ ls <br>
                     sonnets.txt
                 </p>
                 <p class="lamda">Notez que le premier appel à lsne renvoie rien, car second_directoryil est initialement vide.</p>
                 <p class="lamda">Une autre utilisation courante de .est en conjonction avec la findcommande, qui grepest incroyablement puissante, mais dans ma propre utilisation, cela ressemble à ceci 99 % du temps :</p>
                 <p class="cod">
                    $ cd <br>
                    $ find . -name '*.txt' <br>
                    ./text_files/sonnet_1.txt <br>
                    ./text_files/sonnet_1_reversed.txt <br>
                    ./text_files/sonnets.txt
                 </p>
                 <p class="lamda">En d'autres termes, cela permet de trouver les fichiers dont les noms correspondent au modèle *.txt, en commençant dans le répertoire courant  ., puis dans ses sous-répertoires. 2L' findutilitaire est incroyablement utile pour trouver un fichier égaré sur la ligne de commande.</p>
                 <p class="lamda">Mon utilisation préférée de .est peut-être dans « open dot », qui ne fonctionnera que sur macOS :</p>
                 <p class="cod">$ cd ~/ruby/projets <br>
                    $ ouvrir .</p>
                 <p class="lamda">La commande remarquable openouvre son argument en utilisant le programme par défaut pour le fichier ou le répertoire donné.(Une commande similaire, xdg-open, fonctionne sur certains systèmes Linux.)Par exemple, open foo.pdfouvrirait le fichier PDF avec la visionneuse par défaut (qui est Aperçu sur la plupart des Mac).Dans le cas d'un répertoire tel que ., ce programme par défaut est le Finder, open .il produit donc un résultat comme celui montré dans la Figure  4.1 .</p>
                 <p class="lamda">Une dernière commande de navigation, et l'une de mes préférées, est cd -, qui cdrenvoie au répertoire précédent , où qu'il se trouve :</p>
                 <p class="cod">
                    $ pwd <br>
                    /Users/mhartl/second_directory <br>
                    $ cd ~/fichiers_texte <br>
                     $ pwd <br>
                    /Users/mhartl/fichiers_texte <br>
                    $ cd - <br>
                     /Users/mhartl/second_directory
                 </p>
                 <p class="lamda">Je trouve que cela cd -est particulièrement utile lors de la combinaison de commandes, comme décrit dans l'encadré  4.2 .</p>
                 <div class="comment">
                    Encadré 4.2. Combinaison de commandes <br>
                    Il est souvent pratique de combiner des commandes sur la ligne de commande, comme lors de l'installation de logiciels à l'aide des programmes Unix configureet make, qui apparaissent souvent dans la séquence suivante :
                    <p class="cod">
                    $ ./configure ; faire ; faire installer </p>
                    Cette ligne exécute le configureprogramme à partir du répertoire courant ., puis exécute les deux makeet make install.(On ne s'attend pas à ce que vous compreniez ce que font ces programmes, et en effet, ils ne fonctionneront pas sur votre système à moins que vous ne vous trouviez dans le répertoire d'un programme conçu pour être installé de cette façon.)Parce qu'ils sont séparés par le caractère point-virgule  ;, trois commandes sont exécutées en séquence.
                    
                    Une façon encore meilleure de combiner des commandes est d'utiliser la double esperluette &&:
                    <p class="cod">
                    $ ./configure && make && make install </p>
                    La différence est que les commandes séparées par &&s'exécutent uniquement si la commande précédente a réussi .En revanche, ;toutes les commandes seront exécutées quoi qu'il arrive, ce qui provoquera une erreur dans le cas probable où les commandes suivantes dépendront des résultats de celles qui les précèdent.
                    
                    J'aime particulièrement l'utiliser &&en combinaison avec cd -, ce qui me permet de faire des choses comme ceci :
                    <p class="cod">
                    $ build_article && cd ~/tau && déployer && cd - </p>
                    cdEncore une fois, on ne s'attend pas à ce que vous compreniez ces commandes, mais l'idée générale est que nous pouvons (par exemple) créer un article dans un répertoire, dans un répertoire différent, déployer (peut-être un site Web ) en production, puis cdrevenir ( cd -) au répertoire d'origine, où nous pouvons continuer notre travail.Ensuite, si besoin est, nous pouvons simplement utiliser la flèche vers le haut (ou l'une des techniques de l'encadré  3.1 ) pour récupérer le tout et tout recommencer.
                 </div>
                 <h2 id="qsept">4.3.1 Exercices</h2>
                 <p class="exo">1-En quoi les effets de cdet cd ~diffèrent-ils (ou diffèrent-ils) ?</p>
                 <p class="exo">2-Passez à text_files, puis passez à second_directoryl'utilisation de l'opérateur à double point « un répertoire vers le haut »  ...</p>
                 <p class="exo">3-Où que vous soyez, créez un fichier vide appelé nilen text_filesutilisant la méthode de votre choix.</p>
                 <p class="exo">4-Retirez nilde l'exercice précédent en utilisant un chemin différent de celui que vous avez utilisé auparavant.(En d'autres termes, si vous avez ~/text_filesdéjà utilisé le chemin, utilisez quelque chose comme ../text_filesou /Users/<username>/text_files.)
                </p>








                <button class="btn">Commencer: le chapitre</button>

                 
             </div>
             
         </div>
 
         
        </section>
        <!-- 22 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 4</h3>
                 <h2 id="qhuit">4.4 Renommer, copier et supprimer des répertoires</h2>
                <p class="lamda">Les commandes permettant de renommer, copier et supprimer des répertoires sont similaires à celles des fichiers ( Section  2.3 ), mais il existe quelques différences subtiles qui méritent d'être notées.La commande avec la moindre différence est mv, qui fonctionne exactement comme pour les fichiers :</p>
                <p class="cod">
                    $ mkdir foo <br>
                    $ mv foo/ bar/ <br>
                    $ cd foo/ <br>
                    -bash: cd: foo: Aucun fichier ou répertoire de ce type <br>
                   $ cd bar/
                </p>
                <p class="lamda">Ici, le message d'erreur indique que le mvtravail a fonctionné : il n'y a pas de fichier ou de répertoire appeléfoo :</p>
                <p class="cod">$ cd foo/ <br>
                    -bash : cd : foo : Aucun fichier ou répertoire de ce type</p>
                <p class="lamda">(Le mot bashfait référence au nom du programme shell particulier en cours d'exécution, qui dans ce cas est le « Bourne Again SHell ».)La seule subtilité mineure est que les barres obliques de fin (qui sont généralement ajoutées automatiquement par la saisie semi-automatique des tabulations ( encadré  2.4 )) sont facultatives :</p>
                <p class="cod">
                    $ cd <br>
                    $ mv bar foo <br>
                     $ cd foo/
                </p>
                <p class="lamda">Ce problème avec les barres obliques de fin ne fait jamais de différence avec mv, mais avec cp, il peut être une source de grande confusion.En particulier, lors de la copie de répertoires, le comportement que vous souhaitez généralement est de copier le contenu du répertoire , y compris le répertoire, ce qui, sur de nombreux systèmes, nécessite de laisser de côté la barre oblique de fin.Lors de la copie de fichiers, vous devez également inclure l' -roption (pour « récursif »).Par exemple, pour copier le contenu du text_filesrépertoire dans un nouveau répertoire appelé foobar, nous utilisons la commande indiquée dans la liste  4.1 .</p>
                <p class="cod">
                    Liste 4.1 : Copie d’un répertoire. <br>
                    $ cd <br>
                    $ mkdir foobar <br>
                     $ cd foobar/ <br>
                     $ cp -r ../fichiers_texte . <br>
                     $ ls <br>
                     fichiers_texte
                </p>
                <p class="lamda">Notez que nous avons l'habitude ..de créer un chemin relatif , en remontant d'un répertoire puis en entrant dans text_files.Notez également l' absence de barre oblique finale dans cp -r ../text_files .; si nous l'incluions, nous obtiendrions la liste  4.2 à la place.</p>
                <p class="cod">
                    Liste 4.2 : Copie avec une barre oblique finale. <br>
                    $ cp -r ../fichiers_texte/ . <br>
                     $ ls <br>
                     sonnet_1.txt sonnet_1_reversed.txt sonnets.txt fichiers_texte
                </p>
                <p class="lamda">En d’autres termes, la liste  4.2 copie les fichiers individuels, mais pas le répertoire lui-même.Par conséquent, je recommande de toujours omettre la barre oblique finale, comme dans la liste  4.1 ; si vous souhaitez copier uniquement les fichiers, soyez explicite en utilisant l'opérateur étoile, comme dans :</p>
                <p class="cod">$ cp ../fichiers_texte/* .</p>
                <p class="lamda">Contrairement au renommage (déplacement) et à la copie de répertoires, qui utilisent les mêmes commandes mvque cpcelles utilisées pour les fichiers, dans le cas de la suppression de répertoires, il existe une commande dédiée appelée rmdir.Cependant, d’après mon expérience, cela fonctionne rarement, comme on le voit ici :</p>
                <p class="cod">$ cd  <br>
                    $ rmdir second_directory <br>
                     rmdir: second_directory/: Répertoire non vide</p>
                <p class="lamda">Le message d'erreur ici est ce qui se produit 99% du temps lorsque j'essaie de supprimer des répertoires, car cela rmdirnécessite que le répertoire soit vide.Vous pouvez bien sûr le vider à la main (en l'utilisant rmà plusieurs reprises), mais cela est souvent gênant, et j'utilise presque toujours la commande plus puissante (mais beaucoup plus dangereuse) « remove recursive force » rm -rf, qui supprime un répertoire, ses fichiers et tous les sous-répertoires sans confirmation ( Listing  4.3 ).</p>
                <p class="cod">
                    Liste 4.3 : Utilisation rm -rfpour supprimer un répertoire. <br>
                    $ rm -rf second_directory/ <br>
                     $ ls second_directory <br>
                     ls: second_directory: Aucun fichier ou répertoire de ce type
                </p>
                <p class="lamda">Comme l’indique le message d’erreur de lsla liste  4.3 (« Aucun fichier ou répertoire de ce type »), notre utilisation de rm -rfa réussi à supprimer le répertoire.</p>
                <p class="lamda">Le commandement puissant rm -rfest trop pratique pour être ignoré, mais rappelez-vous : « Un grand pouvoir implique de grandes responsabilités » ( Figure  4.2 ). 3</p>
                <p class="cycle spec"><img src="/ressources/t17.jpg" alt=""></p>
                <p class="fig">Figure 4.2 : Ce super-héros sait comment utiliser le pouvoir de rm -rfmanière responsable.</p>

                <h2 id="qneuf">4.4.1 Grep redux</h2>
                <p class="lamda">Maintenant que nous en savons un peu plus sur les répertoires, nous sommes en mesure d’ajouter une grepvariante utile à notre boîte à outils de la section  3.4 .Comme avec cpet rm, grepprend une option « récursive », -r, qui dans ce cas parcourt les fichiers d'un répertoire et les fichiers de ses sous-répertoires.Ceci est incroyablement utile lorsque vous recherchez une chaîne dans un fichier quelque part dans une hiérarchie de répertoires, mais que vous n'êtes pas sûr de l'emplacement du fichier.Voici la configuration, qui place le mot « sesquipedalian » dans un fichier appelé long_word.txt:</p>
                <p class="cod">
                    $ cd fichiers_texte/ <br>
                    $ mkdir foo <br>
                    $ cd foo/ <br>
                    $ echo sesquipedalian > long_word.txt <br>
                    $ cd
                </p>
                <p class="lamda">La finale cdnous ramène dans le répertoire home.Supposons que nous voulions maintenant trouver le fichier contenant « sesquipedalian ».La façon de ne pas le faire est la suivante :</p>
                <p class="cod">
                    $ grep sesquipedalian text_files     # Cela ne fonctionne pas.  <br>
                    grep: text_files: Est un répertoire
                </p>
                <p class="lamda">Voici grepun message d'erreur indiquant que la commande n'a pas fonctionné, mais l'ajout -rfait l'affaire :</p>
                <p class="cod">
                    $ grep -r sesquipedalian fichiers_texte  <br>
                    fichiers_texte/foo/long_word.txt:sesquipedalian
                </p>
                <p class="lamda">
                    Étant donné que nous ne nous soucions généralement pas de la casse lors de la recherche de fichiers, je recommande de prendre l'habitude d'ajouter l' -ioption lors de la recherche récursive, comme suit :
                </p>
                <p class="cod">
                    $ grep -ri sesquipedalian fichiers_texte  <br>
                    fichiers_texte/foo/long_word.txt:sesquipedalian
                </p>
                <p class="lamda">
                    Armés de grep -ri, nous sommes désormais équipés pour trouver des chaînes de notre choix dans des hiérarchies de répertoires arbitrairement profondes.
                </p>
                <h2 id="cun">4.4.2 Exercices</h2>
                <p class="exo">1-Créez un répertoire fooavec un sous-répertoire bar, puis renommez le sous-répertoire en baz.</p>
                <p class="exo">2-Copiez tous les fichiers dans text_files, avec le répertoire, dans foo</p>
                <p class="exo">3-Copiez tous les fichiers de text_files, sans répertoire, dans bar</p>
                <p class="exo">4-Supprimez footout ce qu'il contient à l'aide d'une seule commande</p>

                <button class="btn">Commencer: le chapitre</button>
                 
             </div>
             
         </div>
 
        
        </section>
        <!-- 23 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 4</h3>
                 <h2 id="cdeux">4.5 Résumé</h2>
                 <p class="lamda">Les commandes importantes de ce chapitre sont résumées dans le tableau  4.1 .</p>
                 <table class="tabular">
                    <tbody>
                    <tr class="bottom_border">
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Commande</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Description</font></font></strong></td>
                    <td class="align_left"><strong><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Exemple</font></font></strong></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">mkdir &lt;name&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Créer un répertoire avec un nom</font></font></td>
                    <td class="align_left"><code>$ mkdir foo</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">pwd</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Imprimer le répertoire de travail</font></font></td>
                    <td class="align_left"><code>$ pwd</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">cd &lt;dir&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Changer vers &lt;dir&gt;</font></font></td>
                    <td class="align_left"><code>$ cd foo/</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">cd ~/&lt;dir&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">cd par rapport à la maison</font></font></td>
                    <td class="align_left"><code>$ cd ~/foo/</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">cd</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Changer de répertoire personnel</font></font></td>
                    <td class="align_left"><code>$ cd</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">cd -</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Passer au répertoire précédent</font></font></td>
                    <td class="align_left"><code>$ cd &amp;&amp; pwd &amp;&amp; cd -</code></td>
                    </tr>
                    <tr>
                    <td class="align_left">
                    <code class="tt">.</code><span class="intersentencespace"></span>
                    </td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Le répertoire courant</font></font></td>
                    <td class="align_left">
                    <code>$ cp ~/foo.txt .</code><span class="intersentencespace"></span>
                    </td>
                    </tr>
                    <tr>
                    <td class="align_left">
                    <code class="tt">..</code><span class="intersentencespace"></span>
                    </td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Un répertoire plus haut</font></font></td>
                    <td class="align_left"><code>$ cd ..</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">find</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Rechercher des fichiers et des répertoires</font></font></td>
                    <td class="align_left"><code>$ find . -name foo*.*</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">cp -r &lt;old&gt; &lt;new&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Copier récursivement</font></font></td>
                    <td class="align_left">
                    <code>$ cp -r ~/foo .</code><span class="intersentencespace"></span>
                    </td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">rmdir &lt;dir&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Supprimer le répertoire (vide)</font></font></td>
                    <td class="align_left"><code>$ rmdir foo/</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">rm -rf &lt;dir&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Supprimer le répertoire et son contenu</font></font></td>
                    <td class="align_left"><code>$ rm -rf foo/</code></td>
                    </tr>
                    <tr>
                    <td class="align_left"><code class="tt">grep -ri &lt;string&gt; &lt;dir&gt;</code></td>
                    <td class="align_left"><font dir="auto" style="vertical-align: inherit;"><font dir="auto" style="vertical-align: inherit;">Grep récursivement (insensible à la casse)</font></font></td>
                    <td class="align_left"><code>$ grep -ri foo bar/</code></td>
                    </tr>
                    </tbody>
                    </table>

                    <p class="lamda">Tableau 4.1 : Commandes importantes du chapitre  4 .</p>
                    <h2 id="ctrois">4.5.1 Exercices</h2>
                    <p class="exo">1-En partant de votre répertoire personnel, exécutez une seule commande de ligne de commande pour créer un répertoire foo, accédez-y, créez un fichier baravec le contenu « baz », imprimez barle contenu de , puis cdrevenez au répertoire d'où vous venez. Astuce : combinez les commandes comme décrit dans l’encadré  4.2 .</p>
                    <p class="exo">2-Que se passe-t-il lorsque vous exécutez à nouveau la commande précédente ?Combien de commandes ont été exécutées ?Pourquoi?
                    </p>
                    <p class="exo">3-Expliquez pourquoi la commande rm -rf /est incroyablement dangereuse et pourquoi vous ne devriez jamais la saisir dans une fenêtre de terminal, même pas pour plaisanter.</p>
                    <p class="exo">4-Comment la commande précédente peut-elle être rendue encore plus dangereuse ? Astuce : reportez-vous à l’encadré  4.1 .(Cette commande est si dangereuse que vous ne devriez même pas y penser , et encore moins la taper.)</p>

                    <button class="btn">Commencer: le chapitre</button>
             </div>
             
         </div>
 
         
        </section>
        <!-- 24 -->
        <section>
         <div class="container-video">
 
             <video src="/ressources/video.mp4" class="video"></video>
     
             <div class="controls">
                 <div class="barre-orange">
                     <div class="juice"></div>
                 </div>
     
                 <div class="buttons">
                     <button id="play-pause">
                         <img src="/ressources/play.svg">
                     </button>
                     <button id="mute">Mute</button>
                     <input type="range" id="volume-slider" min="0" max="100" value="50" step="1">
                     <button id="fullscreen">
                         <img src="/ressources/fullscreen.svg">
                     </button>
                 </div>
             </div>
     
         </div>
     
         <div class="contenu">
             <div class="intro">
                 <h3>Chapitre 4</h3>
                 <h2 id="cquatre">4.6 Conclusion</h2>
                 <p class="lamda">Félicitations!Vous avez officiellement appris suffisamment de lignes de commande  .Bien sûr, ce n’est qu’une étape d’un voyage plus long, vers l’excellence de la ligne de commande ( encadré  4.3 ) et vers la maîtrise du développement logiciel.Au fur et à mesure que vous avancez dans ce voyage, vous découvrirez probablement qu’apprendre la magie informatique peut être passionnant et stimulant, mais cela peut aussi être difficile .En effet, vous avez peut-être déjà découvert ce fait, soit par vous-même, soit en suivant ce tutoriel.À ces courageux magiciens en formation qui souhaitent continuer, j'offre la séquence suivante :</p>
                 <button class="btn">Bonne chance 💪💪💪  </button> 
             </div>
             
         </div>
 
         
        </section>
       
    </main>
   
    
        <a href="#home" id="home" class="scroll-up-btn">
                <i class="fas fa-arrow-up"></i>
        </a>
   
        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-migrate/3.0.0/jquery-migrate.min.js"></script>
    <script src="/js/app.js"></script>
</body>
</html>